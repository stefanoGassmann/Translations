<!DOCTYPE html>

<html>
  <head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title> Guia Beej's Para Programação em Rede</title>
   <!-- <link rel="stylesheet" href="bgnet.css" type="text/css">-->
  </head>

<body bgcolor="#ffffff">



<!-- CSS EMBUTIDO NA PÁGINA -->
<!-- A CÓPIA EXATA DO bgnet.css -->
<style>
body {
	background-color: white;
	color: black;
	font-family: "Times New Roman", "Times", "Georgia", serif;
	font-size: 12pt;
	margin: 35pt;
	margin-top: 10pt;
	margin-bottom: 10pt;
}

#adsense {
  float: right;
  margin-top: 20px;
  margin-left: 20px;
}


*.joetable {
	border-width: 1px;
	border-style: solid;
	padding: 0.2em;
}

*.navtable {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 0.8em;
	border-width: 1px;
	border-style: solid;
	background-color: #e7e7e7;
	border-color: #666;
	padding: 0.5em;
}

*.sect1title {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 1.7em;
	font-weight: bold;
	margin-bottom: 0.0em;
}

*.sect2title {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 1.16em;
	font-weight: bold;
	margin-top: 1.5em;
	margin-bottom: 0.0em;
}

*.sect3title {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	margin-top: 1.5em;
	margin-bottom: 0.0em;
}

*.guidetitle {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	font-size: 2em;
	margin-bottom: 0em;
}

*.guidesubtitle {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	font-style: italic;
	font-size: 1.666em;
	margin-top: 0em;
}

*.guidetitleauthor {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	margin-bottom: 0em;
}

*.guideversion,*.guidedate {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 0.8em;
}

*.guidecopyright {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 0.666em;
}

*.guidetitleemail {
	font-family: "Courier New","Courier",monospace; 
	font-weight: bold;
	font-size: 0.8em;
}

*.mainsectbreak {
	margin-top: 1em;
	color: #000;
	border: 0px;
	background-color: #000;
	height: 1px;
}

*.mainsecthr {
	color: #000;
	border: 0px;
	background-color: #000;
	height: 0.2em;
}

*.floatleft {
	float:left;
}

*.floatright {
	float:right;
}

*.padfive {
	padding-top:5px;
	padding-left:5px;
	padding-right:5px;
	padding-bottom:5px;
}

*.type,*.const,*.var,*.email,*.func,*.tt,*.operator {
	font-family: "Courier New","Courier",monospace; 
	font-size: 0.9em;
}

*.code,*.screen {
	font-family: "Courier New","Courier",monospace; 
	font-size: 0.765em;
}

*.em1 {
	font-size: 1em;
}

*.com {
	font-weight: bold;
}

*.var {
	font-style: oblique;
}

*.func {
	font-weight: bold;
}

*.titlefunc {
	font-family: "Courier New","Courier",monospace; 
	font-weight: bold;
}

*.titletype {
	font-family: "Courier New","Courier",monospace; 
	font-weight: bold;
}

*.titlevar {
	font-style: oblique;
	font-weight: bold;
}

*.command {
	font-family: "Courier New","Courier",monospace; 
	font-weight:bold;
}

*.singleborder {
	border: #000,solid,2px;
	border-color: #222;
	border-style: solid;
	border-width: 1px;
	margin: 1em;
	padding: 1em;
}

pre.code {
	background-color: #e7e7e7;
	border-color: #000;
	border-style: solid;
	border-width: 1px;
	border-right-width: 2px;
	border-bottom-width: 2px;
	margin: 0.2em;
	padding: 0.2em;
}

pre.screen {
	font-weight: bold;
	background-color: #e0e0e0;
	border-color: #000;
	border-style: solid;
	border-right-style: dashed;
	border-bottom-style: dashed;
	border-width: 1px;
	margin: 0.2em;
	padding: 0.2em;
}
</style>
<!-- CSS EMBUTIDO NA PÁGINA -->



    <h1 class="guidetitle">Guia Beej's Para Programação em Rede</h1>

    <h2 class="guidesubtitle">Usando Internet Sockets</h2>



    
        <b class="guidetitleauthor">Brian "Beej Jorgensen" Hall</b> <br/>

        <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt><br/><br/>

    

       <span class="guideversion">Versão 3.0.21</span> <br/>

    <span class="guidedate">08 de junho de 2016</span> <br/>

    <p> <small class="guidecopyright">Copyright &#xA9; 2015  Brian "Beej Jorgensen" Hall</small></p>
    
    <p> <small class="guidecopyright">Tradução por cv8minix3, 06.03.2019 | 2ooosblmcnaqvmju.onion | terroristcv8@keemail.me</small></p>


    

<hr class="mainsectbreak" />
<h2 class="sect1title">Conteúdo</h2> <hr class="mainsecthr" />
<dl>
<dt> 1. <a href="#intro">Intro</a></dt>
<dd> 1.1. <a href="#audience">Ao público</a></dd>
<dd> 1.2. <a href="#platform">Plataforma e Compilador</a></dd>
<dd> 1.3. <a href="#homepage">Homepage Oficial e livros a venda</a></dd>
<dd> 1.4. <a href="#solaris">Nota para programadores Solaris/SunOS</a></dd>
<dd> 1.5. <a href="#windows">Observação para programadores Windows</a></dd>
<dd> 1.6. <a href="#emailpolicy">Política Email</a></dd>
<dd> 1.7. <a href="#mirroring">Mirroring</a></dd>
<dd> 1.8. <a href="#xlate">Nota para Tradutores</a></dd>
<dd> 1.9. <a href="#copyright">Direitos do autor e Distribuição</a></dd>
<p> <dt> 2. <a href="#theory">O que é um socket?</a></dt>
<dd> 2.1. <a href="#twotypes">Dois tipos de Internet Sockets</a></dd>
<dd> 2.2. <a href="#lowlevel">Baixo nível nonsense e Teoria de Rede</a></dd>
<p> <dt> 3. <a href="#ipstructsdata">Endereços IP, <nobr> <tt class="type">struct</tt></nobr>s, e Data Munging</a></dt>
<dd> 3.1. <a href="#ipaddrs1">Endereços IP, versões 4 e 6</a></dd>
<dd> 3.2. <a href="#byteorder">Byte Order</a></dd>
<dd> 3.3. <a href="#structs"><nobr> <tt class="type">struct</tt></nobr>s</a></dd>
<dd> 3.4. <a href="#ipaddrs2">Endereços IP, Parte Dois</a></dd>
<p> <dt> 4. <a href="#ip4to6">Saltando de IPv4 para IPv6</a></dt>
<p> <dt> 5. <a href="#syscalls">Chamadas de Sistema</a></dt>
<dd> 5.1. <a href="#getaddrinfo"><b> <tt class="func">getaddrinfo()</tt></b>—Prepare para começar!</a></dd>
<dd> 5.2. <a href="#socket"><b> <tt class="func">socket()</tt></b>—Obtenha o descritor de arquivo!</a></dd>
<dd> 5.3. <a href="#bind"><b> <tt class="func">bind()</tt></b>—Em que porta eu estou?</a></dd>
<dd> 5.4. <a href="#connect"><b> <tt class="func">connect()</tt></b>—Ei, você!</a></dd>
<dd> 5.5. <a href="#listen"><b> <tt class="func">listen()</tt></b>—Alguém por favor pode me ligar?</a></dd>
<dd> 5.6. <a href="#accept"><b> <tt class="func">accept()</tt></b>—"Obrigado por ligar para a porta 3490."</a></dd>
<dd> 5.7. <a href="#sendrecv"><b> <tt class="func">send()</tt></b> e <b> <tt class="func">recv()</tt></b>—Fale comigo, baby!</a></dd>
<dd> 5.8. <a href="#sendtorecv"><b> <tt class="func">sendto()</tt></b> e
<b> <tt class="func">recvfrom()</tt></b>—Fale comigo, DGRAM-style</a></dd>
<dd> 5.9. <a href="#closedown"><b> <tt class="func">close()</tt></b> e
<b> <tt class="func">shutdown()</tt></b>—Não olhe mais na minha cara!</a></dd>
<dd> 5.10. <a href="#getpeername"><b> <tt class="func">getpeername()</tt></b>—Quem é você?</a></dd>
<dd> 5.11. <a href="#gethostname"><b> <tt class="func">gethostname()</tt></b>—Quem sou eu?</a></dd>
<p> <dt> 6. <a href="#clientserver">Cliente-Servidor Background</a></dt>
<dd> 6.1. <a href="#simpleserver">Um Servidor Stream Simples</a></dd>
<dd> 6.2. <a href="#simpleclient">Um Cliente Stream Simples</a></dd>
<dd> 6.3. <a href="#datagram">Sockets Datagram</a></dd>
<p> <dt> 7. <a href="#advanced">Técnicas Ligeiramente avançadas</a></dt>
<dd> 7.1. <a href="#blocking">Blocking</a></dd>
<dd> 7.2. <a href="#select"><b> <tt class="func">select()</tt></b>—Multiplexação Síncrona de E/S</a></dd>
<dd> 7.3. <a href="#sendall">Manipulando<b> <tt class="func">send()</tt></b>s parcialmente</a></dd>
<dd> 7.4. <a href="#serialization">Serialização—Como embalar Dados</a></dd>
<dd> 7.5. <a href="#sonofdataencap">Bases do encapsulamento de dados</a></dd>
<dd> 7.6. <a href="#broadcast">Pacotes Broadcast—Olá, mundo!</a></dd>
<p> <dt> 8. <a href="#faq">Dúvidas Frequentes</a></dt>
<p> <dt> 9. <a href="#man">Páginas de Manual</a></dt>
<dd> 9.1. <a href="#acceptman"><b> <tt class="func">accept()</tt></b></a></dd>
<dd> 9.2. <a href="#bindman"><b> <tt class="func">bind()</tt></b></a></dd>
<dd> 9.3. <a href="#connectman"><b> <tt class="func">connect()</tt></b></a></dd>
<dd> 9.4. <a href="#closeman"><b> <tt class="func">close()</tt></b></a></dd>
<dd> 9.5. <a href="#getaddrinfoman"><b> <tt class="func">getaddrinfo()</tt></b>, <b> <tt class="func">freeaddrinfo()</tt></b>,
<b> <tt class="func">gai_strerror()</tt></b></a></dd>
<dd> 9.6. <a href="#gethostnameman"><b> <tt class="func">gethostname()</tt></b></a></dd>
<dd> 9.7. <a href="#gethostbynameman"><b> <tt class="func">gethostbyname()</tt></b>, <b> <tt class="func">gethostbyaddr()</tt></b></a></dd>
<dd> 9.8. <a href="#getnameinfoman"><b> <tt class="func">getnameinfo()</tt></b></a></dd>
<dd> 9.9. <a href="#getpeernameman"><b> <tt class="func">getpeername()</tt></b></a></dd>
<dd> 9.10. <a href="#errnoman"><i><tt class="var">errno</tt></i></a></dd>
<dd> 9.11. <a href="#fcntlman"><b> <tt class="func">fnctl()</tt></b></a></dd>
<dd> 9.12. <a href="#htonsman"><b> <tt class="func">htons()</tt></b>, <b> <tt class="func">htonl()</tt></b>,
<b> <tt class="func">ntohs()</tt></b>, <b> <tt class="func">ntohl()</tt></b></a></dd>
<dd> 9.13. <a href="#inet_ntoaman"><b> <tt class="func">inet_ntoa()</tt></b>, <b> <tt class="func">inet_aton()</tt></b>,
<b> <tt class="func">inet_addr</tt></b></a></dd>
<dd> 9.14. <a href="#inet_ntopman"><b> <tt class="func">inet_ntop()</tt></b>, <b> <tt class="func">inet_pton()</tt></b></a></dd>
<dd> 9.15. <a href="#listenman"><b> <tt class="func">listen()</tt></b></a></dd>
<dd> 9.16. <a href="#perrorman"><b> <tt class="func">perror()</tt></b>, <b> <tt class="func">strerror()</tt></b></a></dd>
<dd> 9.17. <a href="#pollman"><b> <tt class="func">poll()</tt></b></a></dd>
<dd> 9.18. <a href="#recvman"><b> <tt class="func">recv()</tt></b>, <b> <tt class="func">recvfrom()</tt></b></a></dd>
<dd> 9.19. <a href="#selectman"><b> <tt class="func">select()</tt></b></a></dd>
<dd> 9.20. <a href="#setsockoptman"><b> <tt class="func">setsockopt()</tt></b>, <b> <tt class="func">getsockopt()</tt></b></a></dd>
<dd> 9.21. <a href="#sendman"><b> <tt class="func">send()</tt></b>, <b> <tt class="func">sendto()</tt></b></a></dd>
<dd> 9.22. <a href="#shutdownman"><b> <tt class="func">shutdown()</tt></b></a></dd>
<dd> 9.23. <a href="#socketman"><b> <tt class="func">socket()</tt></b></a></dd>
<dd> 9.24. <a href="#sockaddr_inman"><nobr> <tt class="type">struct sockaddr</tt></nobr> e companhia</a></dd>
<p> <dt> 10. <a href="#reference">Mais Referências</a></dt>
<dd> 10.1. <a href="#books">Livros</a></dd>
<dd> 10.2. <a href="#webref">Web Referências</a></dd>
<dd> 10.3. <a href="#rfcs">RFCs</a></dd>
<p> <dt><a href="#zindex">Índice</a></dt>
</dl> <p>



<hr class="mainsectbreak"/> <h2 class="sect1title">1. <a name="intro">Intro</a></h2> <hr class="mainsecthr"/>


<p> Hey! Programação de Sockets tem lhe deixado para baixo? É muito difícil entender a partir das
páginas <b class="com">man</b>? Você quer fazer programas legais para Internet mas você não tem tempo
para percorrer diversas <nobr> <tt class="type">struct</tt></nobr>s tentando descobrir se você precisa chamar
<b> <tt class="func">bind()</tt></b> antes de <b> <tt class="func">connect()</tt></b>, etc., etc.</p>

<p> Bem, adivinhe! Eu já fiz este trabalho desagradável, e estou
morrendo de vontade de compartilhar com todos o que aprendi! Você veio ao lugar
certo. Este documento deve dar ao programador C médio competente
o impulso que ele precisa para obter controle sobre a confusão que é redes.</p>

<p>E confira: Eu finalmente caminhei para o futuro (apenas no momento certo!) e atualizei o 
Guia para IPv6! Divirta-se!</p>


<h3 class="sect2title">1.1. <a name="audience">Ao público</a></h3>


<p> Este documento foi escrito como um tutorial, não como uma referência completa.
Ele provavelmente será mais eficiente quando lido por pessoas que estejam
apenas começando com programação de sockets e à procura de uma direção a seguir.
Certamente este não é um guia <i>completo e total</i> para programação de sockets, de qualquer forma.</p>

<p> Espero, entretanto, que ele seja suficiente para que as páginas de manual comecem a
fazer sentido... <tt>:-)</tt></p>








<h3 class="sect2title">1.2. <a name="platform">Plataforma e Compilador</a></h3>


<p> Os códigos contidos neste documento foram compilados em um PC Linux
usando compiladores GNU<a name="indexId434909-2"></a> <b class="com">gcc</b>. Estes
devem, no entanto, ser compilados em praticamente qualquer plataforma que use
<b class="com">gcc</b>. Naturalmente, isto não se aplica se você está programando para
Windows—consulte a <a href="#windows">seção sobre programação no Windows</a>, abaixo.</p>








<h3 class="sect2title">1.3. <a name="homepage">Homepage Oficial e livros a venda</a></h3>


<p> Esta é a localização oficial deste documento <tt class="tt"><a href="http://beej.us/guide/bgnet/" target="_blank">http://beej.us/guide/bgnet/</a></tt>. Lá você
também encontrará códigos de exemplo e traduções do guia em vários idiomas.</p>

<p> Para comprar cópias impressas bem encadernadas (alguns chamam de "livros"), visite
<tt class="tt"><a href="http://beej.us/guide/url/bgbuy" target="_blank">http://beej.us/guide/url/bgbuy</a></tt>. Eu aprecio a compra
porque ajuda a sustentar o meu estilo de vida de escritor de documentações.</p>








<h3 class="sect2title">1.4. <a name="solaris">Nota para programadores Solaris/SunOS</a></h3>


<p> Ao compilar para <a name="indexId434909-3"></a> Solaris ou <a name="indexId434909-4"></a> SunOS, você precisa especificar algumas opções extras na linha de comando
para ligar às bibliotecas adequadas. A fim de fazer isso, basta adicionar&nbsp;&nbsp;"<tt class="tt"><nobr>-lnsl</nobr> <nobr> -lsocket</nobr> <nobr> -lresolv</nobr></tt>" ao final do comando de compilação,
como isso:</p>

<pre class="screen">$ cc -o server server.c -lnsl -lsocket -lresolv</pre>


<p> Se você ainda receber erros, você pode tentar ainda adicionar&nbsp; 
"<tt class="tt">-lxnet</tt>" &nbsp;ao final da linha de comando. Eu não sei por que
contece, exatamente, mas algumas pessoas parecem precisar.</p>

<p> Outro lugar em que você pode encontrar problemas é na chamada de
<b> <tt class="func">setsockopt()</tt></b>. O protótipo é diferente do que há no meu ambiente
Linux, assim em vez de:</p>

<pre class="code">int yes=1;</pre>


<p> Digite o seguinte:</p>

<pre class="code">char yes='1';</pre>


<p> Como eu não tenho um ambiente Sun, eu não testei qualquer das instruções a cima,
é apenas o que as pessoas me disseram por e-mail.</p>



<h3 class="sect2title">1.5. <a name="windows">Observação para programadores Windows</a></h3>


<p> Neste ponto do guia, historicamente, eu fiz pouco caso <a name="indexId434909-5"></a> do Windows,
simplesmente devido ao fato de que eu não gosto muito.
Mas eu realmente devo ser justo e dizer-lhe que o Windows tem uma enorme base de instalações e é,
obviamente, perfeitamente um sistema operacional.</p>

<p>Dizem que a ausência do Windows nos torna pessoas melhores, e, neste caso, eu
acredito que seja verdade (Ou talvez seja a idade). Mas o que eu posso dizer é que
depois de uma década sem usar sistemas operacionais da Microsoft para o meu trabalho pessoal,
Eu sou muito mais feliz! Como tal, eu posso sentar e dizer com segurança: "Claro, sinta-se
livre para usar Windows!"... Ok, sim, mas isso me faz cerrar os dentes ao dizer.</p>

<p> Então, eu ainda o encorajo a experimentar <a name="indexId434909-6"></a> <a href="http://www.linux.com/" target="_blank">Linux</a>, <a href="http://www.bsd.org/" target="_blank">BSD</a>, ou
algum sabor de Unix, em vez disso.</p>

<p>Como as pessoas gostam do que gostam, o pessoal do Windows ficará satisfeito em saber que
essas informações são geralmente também aplicáveis ao Windows, com algumas pequenas alterações, se houverem.</p>

<p> Uma coisa legal que você pode fazer é instalar <a name="indexId434909-7"></a> <a href="http://www.cygwin.com/" target="_blank">Cygwin</a>, que é um conjunto de ferramentas Unix
para Windows. Um passarinho me contou que elas permitem que todos os programas do Guia sejam compilados sem modificações.</p>

<p> Mas alguns de vocês podem querer fazer as coisas na forma puramente Windows.
Isso é muito corajoso de sua parte, e é isso que você tem que fazer: correr e pegar um Unix imediatamente!
Não, não, estou brincando. Eu echo que sou mais Windows-friendly(er) hoje em dia...</p>

<p> Isto é o que você terá que fazer (a menos que você instale <a href="http://www.cygwin.com/" target="_blank">Cygwin</a>!): Em primeiro lugar, ignore praticamente
todos os arquivos de cabeçalho do sistema que menciono aqui. Tudo que você precisa incluir é:</p>

<pre class="code"><a name="indexId434909-8"></a>#include &lt;winsock.h&gt;</pre>


<p> Espere! Você também precisa fazer uma chamada a&nbsp;<a name="indexId434909-9"></a> <b> <tt class="func">WSAStartup()</tt></b> antes de fazer qualquer outra coisa
com a biblioteca de sockets. O código para isso é algo como:</p>

<pre class="code">#include &lt;winsock.h&gt;

{
    WSADATA wsaData; //se isso não funcionar
    //WSAData wsaData; //tente isso em vez de

    //MAKEWORD(1,1) para Winsock 1.1, MAKEWORD(2,0) para Winsock 2.0:

    if (WSAStartup(MAKEWORD(1,1), &amp;wsaData) != 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }</pre>


<p> Você também tem que dizer ao seu compilador para vincular a biblioteca Winsock,
usualmente chamada <i><tt class="var">wsock32.lib</tt></i> ou <i><tt class="var">winsock32.lib</tt></i>,
ou <i><tt class="var">ws2_32.lib</tt></i> para Winsock 2.0. Em VC++, isso pode ser
feito através do menu <tt class="tt">Project</tt>, em <tt class="tt">Settings...</tt>
Clique na guia <tt class="tt">Link</tt>, e procure a caixa intitulada  "Object/library modules".
Adicione "wsock32.lib" (ou qualquer lib de sua preferência) para a lista.</p>

<p>Ou foi pelo menos assim que ouvi falarem.</p>

<p> Finalmente, você precisa chamar <a name="indexId434909-10"></a> <b> <tt class="func">WSACleanup()</tt></b> quando terminar o uso das
biblioteca de sockets. Consulte a ajuda online para obter detalhes.</p>

<p> Depois de fazer isso, o resto dos exemplos neste tutorial devem
geralmente se aplicar, com algumas exceções. Por um lado, você não pode usar
<b> <tt class="func">close()</tt></b>para fechar um socket—você precisa usar <a name="indexId434909-11"></a> <b> <tt class="func">closesocket()</tt></b>, em vez disso.
Além disso, <a name="indexId434909-12"></a> <b><tt class="func">select()</tt></b> só funciona com descritores de sockets,
não descritores de arquivos (como <tt class="const">0</tt> para <tt class="tt">stdin</tt>).</p>

<p> Há também uma classe socket que você pode usar, <a name="indexId434909-13"></a> <nobr> <tt class="type">CSocket</tt></nobr>.
Verifique as páginas de ajuda de seu compilador para mais informações.</p>

<p>Para mais informações sobre Winsock, leia o <a name="indexId434909-14"></a><a href="http://tangentsoft.net/wskfaq/" target="_blank">Winsock FAQ</a> e inicie por lá.</p>

<p>Finalmente, ouvi dizer que o Windows não possui a chamada de sistema <a name="indexId434909-15"></a> <b> <tt class="func">fork()</tt></b>, que é, infelizmente,
utilizada em alguns dos meus exemplos. Talvez você tenha que usar uma biblioteca POSIX ou algo para fazê-lo funcionar, ou você pode usar <a name="indexId434909-16"></a> <b> <tt class="func">CreateProcess()</tt></b> em seu lugar.
<b><tt class="func">fork()</tt></b> não tem argumentos, e <b><tt class="func">CreateProcess()</tt></b>
leva cerca de 48 bilhões argumentos. Se você não está à altura, a <a name="indexId434909-17"></a> <b><tt class="func">CreateThread()</tt></b> é um pouco mais fácil de digerir...
infelizmente uma discussão sobre multithreading está além do escopo deste documento. Eu só posso falar um tanto sobre, você sabe!</p>



<h3 class="sect2title">1.6. <a name="emailpolicy">Política Email</a></h3>


<p> Eu geralmente estou disponível a ajudar com <a name="indexId434909-18"></a>perguntas por e-mail, então fique à vontade para escrever,
mas não posso garantir uma resposta. Eu levo uma vida muito ocupada e há momentos em que simplesmente não
consigo responder a uma dúvida que você possua. Quando esse é o caso, normalmente apenas excluo a mensagem.
Não é nada pessoal; Eu só nunca terei tempo para dar a resposta detalhada que você precisa.</p>

<p>Como regra geral, quanto mais complexa a questão, é menos provável que eu responda.
Se você puder refinar sua pergunta antes de enviá-la e incluir todas as informações pertinentes
(como plataforma, compilador, mensagens de erro recebidas e qualquer outra coisa que possa ajudar a solucionar os problemas),
é muito mais provável que você receba uma resposta. Para mais dicas, leia o documento do ESR, <a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank">Como fazer perguntas de maneira inteligente</a>.</p>

<p>Se você não obtiver uma resposta, faça um pouco mais, tente encontrar a resposta e,
se ainda não for suficiente, escreva-me novamente com as informações que encontrou e espero que seja o suficiente para eu o ajudar.</p>

<p>Agora que te atormentei sobre como escrever e não me escrever, 
gostaria apenas de lhe dizer que aprecio <i>plenamente</i> todos os elogios que o guia recebeu 
ao longo dos anos. 
É um verdadeiro impulso moral, e fico feliz em saber que está sendo usado para o bem! <tt>:-)</tt> Obrigado!









<h3 class="sect2title">1.7. <a name="mirroring">Mirroring</a></h3>


<p> <a name="indexId434909-19"></a> Você é mais que bem-vindo para espelhar este site, seja pública ou privadamente.
Se você espelhar publicamente o site e quiser que eu faça um link para ele a partir da página principal, me envie uma linha em
<tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>.</p>









<h3 class="sect2title">1.8. <a name="xlate">Nota para Tradutores</a></h3>


<p> <a name="indexId434909-20"></a> Se você quiser traduzir o guia para
outra língua, escreva-me em <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt> e eu adicionarei uma ligação para
sua tradução a partir da página principal. Sinta-se livre para adicionar seu nome e
informações de contato na tradução.</p>

<p> Observe as restrições de licença na seção Direitos do autor e Distribuição, abaixo.</p>

<p> Caso queira que eu hospede a tradução, basta pedir. Eu também adicionarei uma ligação para
ela caso você a hospede; de qualquer forma, tudo bem.</p>








<h3 class="sect2title">1.9. <a name="copyright">Direitos do autor e Distribuição</a></h3>


<p>Beej's Guide to Network Programming is Copyright © 2015
Brian "Beej Jorgensen" Hall.</p>

<p> Com exceções específicas para traduções e códigos fonte, abaixo, esta obra está licenciada sob a Creative Commons Attribution-
Noncommercial- No Derivative Works 3.0 License. 
Para ver uma cópia desta licença, visite <tt class="tt"><a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">http://creativecommons.org/licenses/by-nc-nd/3.0</a></tt> ou envie uma carta para Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</p>

<p> Uma exceção específica à parte "Sem obras derivadas" da licença é a seguinte: 
este guia pode ser traduzido livremente para qualquer idioma, desde que a tradução seja exata e o guia seja reimpresso em sua totalidade. 
As mesmas restrições de licença se aplicam à tradução do guia original. 
A tradução também pode incluir o nome e as informações de contato do tradutor.</p>

<p> O código-fonte C apresentado neste documento é concedido ao domínio público e está completamente livre de qualquer restrição de licença.</p>

<p> Os educadores são encorajados a recomendar ou fornecer cópias deste guia aos seus alunos.</p>

<p> <tt class="email">Entre em contato com <a href="mailto:beej@beej.us">beej@beej.us</a></tt> para mais informações.</p>



 








<hr class="mainsectbreak"/> <h2 class="sect1title">2. <a name="theory">O que é um socket?</a></h2> <hr class="mainsecthr" />


<p>Você ouve falar em "<a name="indexId434909-21"></a>sockets" o tempo todo, e 
talvez esteja se perguntando o que são exatamente. Bem, eles são isso: Um modo de falar com outros programas usando <a name="indexId434909-22"></a>descritores de arquivos padrão do Unix.</p>

<p> O quê?</p>

<p> Ok, você pode ter ouvido algum hacker de Unix dizer "Ei,
<i>tudo</i> no Unix é arquivo!" O que essa pessoa disse é o fato de que quando os programas Unix fazem qualquer tipo de
E/S, eles fazem isso pela leitura ou escrita em um descritor de arquivo. Um descritor de arquivo é simplesmente um inteiro associado a um arquivo aberto. 
Mas (e aqui está o segredo), esse arquivo pode ser uma conexão de rede, um FIFO, um
pipe, um terminal, um arquivo real no disco, ou qualquer outra coisa.
Tudo no Unix <i>é</i> um arquivo! Então, quando você quiser se comunicar com outro programa através da Internet você vai fazê-lo
através de um descritor de arquivo, é melhor você acreditar.</p>

<p> "Onde posso obter este descritor de arquivo para comunicação de rede, Sr. Sabichão?" É provavelmente a última pergunta em sua mente agora, mas
eu vou responder a isso de qualquer maneira: Você faz uma chamada a função <a name="indexId434909-23"></a> <b> <tt class="func">socket()</tt></b>. Ela retorna o
<a name="indexId434909-24"></a>descritor de socket, e você se comunica
através dele usando as chamadas de sistema especializadas em sockets <a name="indexId434909-25"></a><b><tt class="func">send()</tt></b>
e <a name="indexId434909-26"></a><b><tt class="func">recv()</tt></b> (<b class="com"><a href="#sendman">man
send</a></b>, <b class="com"><a href="#recvman">man recv</a></b>).</p>

<p> "Mas, Ei!" você pode estar exclamando agora. "Se é um descritor de arquivo, por que raios eu não posso simplesmente usar as chamadas normais <a name="indexId434909-27"></a> <b><tt class="func">read()</tt></b><a name="indexId434909-28"></a> e <b><tt class="func">write()</tt></b> para me comunicar através do socket?"
A resposta curta é: "Você pode!"; A resposta mais longa é: "Você pode, mas <a name="indexId434909-29"></a> <b> <tt class="func">send()</tt></b> e <a name="indexId434909-30"></a> <b> <tt class="func">recv()</tt></b> oferecem muito mais controle sobre a sua transmissão de dados."</p>

<p> O que vem depois? Veja mais: existem diversos tipos de sockets. Como <a name="indexId434909-31"></a> DARPA Internet addresses (Internet Sockets), path names em um nó local (Unix Sockets), CCITT X.25 addresses (Sockets tipo X.25 podem ser ignorados traquilamente de forma segura), e provavelmente muitos
outros, dependendo do sabor Unix executado. Este documento trata somente do primeiro: Internet Sockets.</p>







<h3 class="sect2title">2.1. <a name="twotypes">Dois tipos de Internet Sockets</a></h3>


<p> Como é? <a name="indexId434909-32"></a> Existem dois tipos de Internet
sockets? Sim. Bem, não, estou mentindo. Há mais tipos mas eu não quero te assustar.
Eu só vou falar sobre dois tipos aqui. Exceto por
esta frase, onde eu vou dizer-lhe que "<a name="indexId434909-33"></a><a name="indexId434909-34"></a>Raw Sockets" também são muito poderosos e
você deve procurá-los.</p>

<p> Tudo bem, agora. Quais são os dois tipos? Um deles é "<a name="indexId434909-35"></a>Stream Socket"; o outro é
"<a name="indexId434909-36"></a>Datagram Socket", que daqui em diante
podem ser referidos como "<tt class="const">SOCK_STREAM</tt>" e
"<tt class="const">SOCK_DGRAM</tt>", respectivamente. Sockets Datagram são
às vezes chamados de "sockets sem conexão" (Embora possam ser usados com <a name="indexId434909-37"></a> <b> <tt class="func">connect()</tt></b> caso você realmente queira. Veja <b><tt class="func"><a href="#connect">connect()</a></tt></b>, abaixo).</p>

<p> Sockets stream são fluxos de comunicação confiáveis ligados bidirecionalmente.
Se você envia dois itens ao socket na ordem "1,2", eles vão
chegam na ordem "1,2" na extremidade oposta. Eles também serão
livres de erros. Eu estou tão certo, na verdade, que eles estarão livres de erros, que estou
pondo agora meus dedos em meus ouvidos e cantando <i>lá lá lá lá</i>
antes que alguém tente dizer o contrário.</p>

<p> O que usa <a name="indexId434909-38"></a> sockets stream? Bem, você pode já
ter ouvido falarem da aplicação <a name="indexId434909-39"></a><b class="com">telnet</b>, sim?
Ela usa sockets stream. Todos os caracteres que você digita precisam chegar na mesma ordem que você 
digitou, certo? Além disso, os navegadores web usam o<a name="indexId434909-40"></a> protocolo HTTP que utiliza sockets stream para obter
as páginas. De fato, se você executa telnet contra um site na porta 80, e digita
"<tt class="tt">GET / HTTP/1.0</tt>" e pressiona RETURN duas vezes, ele irá retornar o HTML a você!</p>

<p> Como sockets stream conseguem atingir um nível tão elevado de qualidade de transmissão de dados? 
Ele usa um protocolo chamado "The Transmission Control Protocol", também conhecido como <a name="indexId434909-41"></a>"TCP" (veja <a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC 793</a> para informações extremamente detalhadas
sobre TCP). TCP garante que seus dados cheguem sequencialmente e livres de erros.
Você pode ter ouvido "TCP" antes como a melhor parte do "TCP/IP", onde <a name="indexId434909-42"></a> "IP" significa "Internet Protocol" (veja <a href="http://tools.ietf.org/html/rfc791" target="_blank">RFC 791</a>.). O IP lida principalmente com o roteamento da Internet e geralmente não é responsável pela integridade dos dados.</p>

<p> Legal. <a name="indexId434909-43"></a> E quanto aos sockets datagram? Por que eles são chamados sem conexão? Qual é o problema aqui, afinal? 
Por que eles não são confiáveis? Bem, aqui estão alguns fatos: se você enviar um datagram, ele pode chegar. Pode chegar fora de ordem. 
Se chegar, os dados dentro do pacote estarão livres de erros.</p>

<p> Sockets datagram também usam IP para roteamento, mas eles não usam TCP;
eles usam o "User Datagram Protocol", ou <a name="indexId434909-44"></a> "UDP" (veja
<a href="http://tools.ietf.org/html/rfc768" target="_blank">RFC 768</a>.)</p>

<p> Por que eles são sem conexão? Bem, basicamente, é porque você não precisa manter uma conexão 
aberta como você faz com sockets stream. 
Você apenas constrói um pacote, coloca um cabeçalho IP nele com informações de destino e envia-o para fora. 
Nenhuma conexão é necessária. Eles geralmente são usados quando uma pilha TCP não está disponível ou quando alguns pacotes descartados aqui e ali não significam o fim do Universo. 

Aplicações de exemplo: <b class="com">TFTP</b> (trivial file transfer protocol, um irmão mais novo do FTP), <b class="com">dhcpcd</b> (um cliente DHCP), jogos multiplayer,
streaming de áudio, video conferência, etc.</p>

<p> "Espere um minuto! <b class="com">TFTP</b> e <b class="com">dhcpcd</b> são usados ​​para
transferir dados e também aplicações binárias de um host a outro! Os dados não podem ser
perdidos se você espera que o aplicativo funcione ao chegar! Que tipo
de magia negra é essa? "</p>

<p> Bem, meu amigo humano, <b class="com">TFTP</b> e outros programas semelhantes têm
seus próprios protocolos em cima do UDP. Por exemplo, o protocolo TFTP diz
que para cada pacote que é enviado, o destinatário tem de enviar de volta um
pacote que diz: "Eu consegui!" (Um pacote "ACK".) Se o remetente do
pacote original não recebe a resposta, digamos, em cinco segundos, ele vai retransmitir
o pacote até que ele finalmente receba um ACK. Este procedimento de reconhecimento
é muito importante na implementação confiável de <tt class="const">SOCK_DGRAM</tt>
 em aplicações.</p>

<p> Para aplicações não confiáveis, como jogos, áudio ou vídeo, você pode só
ignorar os pacotes perdidos, ou talvez tentar compensá-los de forma inteligente 
(Jogadores de Quake conhecem bem a manifestação deste efeito pelo
termo técnico: <i>lag maldito</i>. A palavra "maldito", neste
caso, representa qualquer enunciado extremamente profano).</p>

<p> Por que você usaria um protocolo subjacente não confiável? Duas razões:
velocidade e velocidade. É a maneira mais rápida de mirar e atirar do que é para se certificar
de que um dado chegou em segurança e ainda ter certeza que o mesmo está na ordem correta. 
Se você estiver enviando mensagens de bate-papo, o TCP é ótimo; Se você estiver enviando
40 atualizações posicionais por segundo para jogadores ao redor do mundo, talvez não 
importe muito perder um ou dois pacotes, e o UDP é uma boa escolha.</p>



<h3 class="sect2title">2.2. <a name="lowlevel">Baixo nível nonsense e Teoria de Rede</a></h3>


<p> Agora que acabei de mencionar a divisão de camadas de protocolos, é hora de falar
sobre como as redes realmente funcionam, e mostrar alguns exemplos de como pacotes<a name="indexId434909-45"></a> <tt class="const">SOCK_DGRAM</tt>são construídos.
Na prática, você provavelmente pode pular esta seção. É uma boa teoria de background, no entanto.</p>

<a name="figure1"></a> <center>
<div> <img src="data:png;base64,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
heAiDXj+D6I1FigGR/QEAAAAAElFTkSuQmCC" alt="[Encapsulated Protocolos Diagrama]"/></div>

<p> <b> Data Encapsulation.</b></p>
</center>


<p> Ei, crianças, é hora de aprender sobre <a name="indexId434909-46"></a> <i><a href="#figure1">Encapsulamento de Dados</a></i>! Isto é muito, muito importante. 
É tão importante que para que você possa aprender sobre é necessário fazer o curso de redes aqui na Chico State <tt>;-)</tt>. Basicamente, ele diz o seguinte: um pacote
nasce, é envolto ( "encapsulado") em um <a name="indexId434909-47"></a> cabeçalho (e raramente <a name="indexId434909-48"></a>um rodapé) pelo primeiro
protocolo (por exemplo, o <a name="indexId434909-49"></a> protocolo TFTP), o conjunto da coisa (com cabeçalho TFTP já incluído) é encapsulado novamente pelo seguinte protocolo
(digamos, <a name="indexId434909-50"></a> UDP), em seguida, novamente pelo próximo (<a name="indexId434909-51"></a>IP),
em seguida, novamente pelo protocolo final sobre a camada de hardware (física) (por exemplo,
<a name="indexId434909-52"></a>Ethernet).</p>

<p> Quando outro computador recebe o pacote, o hardware retira o
cabeçalho Ethernet, o kernel retira os cabeçalhos IP e UDP, o programa TFTP retira o cabeçalho TFTP, e finalmente tem os dados.</p>

<p> Agora posso finalmente falar sobre o infame <a name="indexId434909-53"></a> <i>Modelo de Rede em Camadas</i> (conhecido como "ISO/OSI"). 
Este modelo de rede descreve um sistema de funcionalidades de rede que tem muitas vantagens sobre outros modelos. Por exemplo, você pode escrever programas com sockets que são exatamente 
os mesmos sem se importar com a forma como os dados são transmitidos fisicamente (serial, thin Ethernet, AUI, o que for) porque os programas em níveis mais baixos lidam com isso para você. 
O hardware e a topologia de rede reais são transparentes para o programador do socket.</p>

<p> Sem mais delongas, vou apresentar as camadas do modelo de forma completa. 
Lembre-se disso para seus exames do curso de redes:</p>

<ul>

<li> Aplicação</li>

<li> Apresentação</li>

<li> Sessão</li>

<li> Transporte</li>

<li> Rede</li>

<li> Enlace</li>

<li> Física</li>

</ul>


<p> A camada física é o hardware (serial, Ethernet, etc.). A
Camada de Aplicação é quase tão distante da camada física quanto você
possa imaginar—é onde os usuários interagem com a rede.</p>

<p>Agora, este modelo é tão geral que você provavelmente poderia usá-lo como um guia de reparação de 
automóveis, se você realmente quiser. Um modelo em camadas mais consistente com Unix poderia ser:</p>

<ul>

<li> Camada de Aplicação (<i>telnet, ftp, etc.</i>)</li>

<li> Camada de Transporte Host-para-Host (<i>TCP, UDP</i>)</li>

<li> Camada de Internet (<i>IP e roteamento</i>)</li>

<li> Camada de Acesso à Rede (<i>Ethernet, Wi-Fi, ou outros</i>)</li>

</ul>


<p> Neste momento, você provavelmente já pode ver como essas camadas
correspondem ao encapsulamento dos dados originais.</p>

<p> Viu quanto trabalho existe na construção de um pacote simples? Eita!
E você só tem que digitar os cabeçalhos dos pacotes usando
"<b class="com">cat</b>"! Estou brincando. Tudo que você tem que fazer para sockets stream
é usar <a name="indexId434909-54"></a> <b> <tt class="func">send()</tt></b> para enviar os dados. Tudo que você precisa
fazer para sockets datagram é encapsular o pacote no método da sua
escolher e usar <a name="indexId434909-55"></a> <b> <tt class="func">sendto()</tt></b>. 
O kernel constrói a Camada de Transporte e a Camada de Internet para você e o hardware faz a Camada de Acesso a Rede. Ah, a tecnologia moderna.</p>

<p> Assim termina nossa breve incursão na teoria de rede. Ah sim, eu esqueci de
dizer-lhe tudo o que eu queria dizer sobre roteamento: nada! Isso mesmo, eu não vou falar sobre isso. 
O roteador abre o cabeçalho IP do pacote, consulta sua tabela de roteamento, <a name="indexId434909-56"></a> blá-blá-blá. Confira o <a href="http://tools.ietf.org/html/rfc791" target="_blank">IP RFC</a> se você realmente se importa em saber. E se
você nunca souber, bem, você ainda estará vivo.</p>



 

<hr class="mainsectbreak"/><h2 class="sect1title">3. <a name="ipstructsdata">Endereços IP, <nobr><b><tt class="titletype">struct</tt></b></nobr>s, e Data Munging</a></h2><hr class="mainsecthr"/>

<p> Aqui está a parte do jogo em que podemos falar sobre algumas mudanças no código.</p>

<p> Mas, primeiro, vamos discutir mais não-códigos! Sim! Primeiro quero falar um pouco 
sobre <a name="indexId434909-57"></a>endereços IP e portas e então teremos o assunto resolvido.
Em seguida, falaremos sobre como a API de sockets armazena e manipula os endereços IP e outros dados.


<h3 class="sect2title">3.1. <a name="ipaddrs1">Endereços IP, versões 4 e 6</a></h3>


<p> Nos bons e velhos tempos, quando Ben Kenobi ainda era chamado Obi Wan
Kenobi, havia um maravilhoso sistema de roteamento de rede chamado The Internet
Protocol Version 4, também chamado <a name="indexId434909-58"></a> IPv4. Ele tinha endereços
compostos de quatro bytes (ou quatro "octetos"), e era escrito comumente na forma de "pontos e números", assim: <tt class="tt">192.0.2.111</tt>.</p>

<p> Você provavelmente já viu isso por aí.</p>

<p> Na verdade, até o momento desta escrita, praticamente todos os sites da Internet usam o IPv4.</p>

<p> Todos, incluindo Obi Wan, estavam felizes. As coisas eram ótimas, até que algum opositor com o nome de Vint Cerf avisou que estávamos prestes a ficar sem endereços IPv4!</p>

<p> (Além de avisar a todos sobre o futuro destino apocalíptico de tristeza do IPv4, <a name="indexId434909-59"></a> <a href="http://en.wikipedia.org/wiki/Vinton_Cerf" target="_blank">Vint Cerf</a> também é conhecido 
por ser o Pai da Internet. Então, eu realmente não estou em posição de o julgar.)</p>

<p> Ficar sem endereços? Como isso poderia acontecer? Quer dizer, existem bilhões de endereços IP em um endereço IPv4 de 32 bits. 
Nós realmente temos bilhões de computadores por aí?</p>

<p> Sim.</p>

<p> Além disso, no início, quando havia apenas alguns computadores e todos pensavam que um bilhão era um número incrivelmente grande, algumas grandes organizações receberam generosamente milhões de endereços IP para uso próprio
(Como Xerox, MIT, Ford, HP, IBM, GE, AT&amp;T e uma pequena empresa chamada Apple, para citar alguns.).</p>

<p> Na verdade, se não fosse por várias medidas paliativas, já teríamos
os esgotado há muito tempo.</p>

<p> Mas agora estamos vivendo em uma era em que todos os seres humanos têm um endereço IP, todos os computadores, todas as calculadoras, todos os telefones, todos os parquímetros e (por que não) todos os filhotes de cachorros, também.</p>

<p> E assim, <a name="indexId434909-60"></a> o IPv6 nasceu. Como Vint Cerf é provavelmente
imortal (mesmo que sua forma física passe, Deus nos livre, ele provavelmente já está existindo como uma espécie hiper-inteligente de programa <a href="http://en.wikipedia.org/wiki/ELIZA" target="_blank">ELIZA</a> nas profundezas do
Internet2), ninguém quer ter de ouvi-lo dizer novamente "eu avisei" se não tivermos endereços suficientes na próxima versão do Internet Protocol.</p>

<p> O que isso lhe sugere?</p>

<p> Que precisamos de <i>muito</i> mais endereços. Que não precisamos apenas
de duas vezes mais de endereços, nem um bilhão de vezes mais, nem mil
trilhões de vezes mais, mas <i>79 MILHÕES BILHÕES TRILHÕES de vezes mais
endereços possíveis!</i> Isso vai mostrar a eles!</p>

<p> Você está dizendo: "Beej, isso é verdade? Eu tenho todos os motivos para
descrer de grandes números." Bem, as diferenças entre 32 bits e 128
bits podem não parecer grandes; são apenas mais 96 bits, certo? Mas
lembre-se, estamos falando de poderes aqui: 32 bits representam cerca de 4 bilhões
de números (2 <sup> <small> 32</small></sup>), enquanto 128 bits representam cerca de 340
trilhões de trilhões de trilhões de números (na verdade, 2 <sup> <small> 128</small></sup>).
Isso é como um milhão de Internets IPv4 para <i>cada estrela no
Universo</i>.</P>

<p> Esqueça a aparência destes pontos-e-números do IPv4, também; agora temos uma 
representação hexadecimal, com cada bloco de dois bytes separados por dois
pontos, como isso: <tt class="tt">2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551</tt></p>

<p> Isso não é tudo! Muitas vezes, você terá um endereço IP com muitos zeros e poderá compactá-los entre dois-pontos. 
E você pode deixar zeros à esquerda para cada par de bytes. Por exemplo, cada um desses pares de endereços é equivalente:</p>

<pre class="screen">2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
</pre>


<p> O endereço <tt class="tt">::1</tt> é o <i>endereço de auto-retorno</i>. Isto
sempre significa "esta máquina que eu estou correndo agora". Em IPv4, o endereço de auto-retorno é 127.0.0.1.</p>

<p> Finalmente, há um modo de compatibilidade IPv4 para endereços IPv6 com o qual
você pode se deparar. Se você quiser, por exemplo, para representar o IPv4 
192.0.2.33 como um endereço IPv6, você usaria a seguinte notação:
"<tt class="tt">::ffff:192.0.2.33</tt>"</p>

<p> Estamos falando de muita diversão.</p>

<p> Na verdade, é tão divertido, que os criadores do IPv6 mativeram trilhões e trilhões de endereços 
para uso reservado, mas temos tantos, francamente, quem ainda está contando? 
Há muito de sobra para cada homem, mulher, criança, cachorrinho e parquímetro em todos os planetas da galáxia. 
E acredite em mim, cada planeta da galáxia tem parquímetros. Você sabe que é verdade.</p>



<h4 class="sect3title">3.1.1. <a name="netslash">Subnets</a></h4>


<p> Por motivos organizacionais, às vezes é conveniente declarar que
"Nesta primeira parte do endereço IP até este bit é a <i>parte da rede</i> do endereço IP, e o restante é a
<i>parte do host</i>".</p>

<p> Por exemplo, com IPv4, você pode ter <tt class="tt">192.0.2.12</tt>, e poderíamos dizer
que os três primeiros campos são a rede e o último o endereço do host. Ou, dito de outra forma, estamos falando do host <tt class="tt">12</tt> na
rede <tt class="tt">192.0.2.0</tt> (veja como podemos zerar o byte de endereço do host.)</p>

<p> E agora, para mais informações desatualizadas! Pronto? Nos tempos antigos,
houveram "classes" de sub-redes, onde o primeiro, dois, ou três
bytes do endereço formavam a parte de rede. 
Se você tivesse a sorte de ter um byte para a rede e três para o host, você poderia ter 24 bits de hosts na sua rede (16 milhões ou mais). 
Essa era uma rede "Classe A". No extremo oposto, havia uma "Classe C", com três bytes de rede e um byte de host (256 hosts, menos uma dupla que estavam reservados).</p>

<p> Então, como você pode ver, havia apenas alguns Classe A, uma pilha enorme de Classe C e alguns Classe B no meio.</p>

<p> A porção da rede do endereço IP é descrita por algo
chamado <i>netmask</i>, que você associa com o endereço IP
para obter o número da rede. A netmask geralmente tem um formato parecido
com <tt class="tt">255.255.255.0</tt>. (Por exemplo, com essa netmask, se o seu
IP é <tt class="tt">192.0.2.12</tt>, então sua rede é <tt class="tt">192.0.2.12</tt> E
<tt class="tt">255.255.255.0</tt> o que dá <tt class="tt">192.0.2.0</tt>.)</p>

<p> Infelizmente, descobriu-se que isso não era suficiente para
as eventuais necessidades da Internet; nós estávamos ficando sem classes C 
muito rapidamente, e nós estávamos definitivamente fora das Classes A, então
nem se incomode em perguntar. Para remediar isso, os números permitidos para a netmask são 
combinados arbitrários de bits, não apenas 8, 16 ou 24. 
Então você pode ter uma netmask de, digamos, <tt class="tt">255.255.255.252</tt>, que
é de 30 bits de rede e 2 bits de host, permitindo quatro hosts na
rede. (Note que a netmask é <i>SEMPRE</i> um monte de bits 1 seguido por um monte de bits 0.)</p>

<p> Mas é um pouco difícil de usar uma grande série de números como
<tt class="tt">255.192.0.0</tt> como netmask. Primeiro de tudo, as pessoas não têm
uma ideia intuitiva da quantidade de bits, e em segundo lugar, não é realmente
compacta. Então, o Novo Estilo surgiu e é muito melhor. Você apenas
precisa colocar uma barra após o endereço IP e, em seguida, o número de
bits de rede em decimal. Assim: <tt class="tt">192.0.2.12/30</tt>.</p>

<p>Ou, para IPv6, algo como isso: <tt class="tt">2001:db8::/32</tt> ou
<tt class="tt">2001:db8:5413:4028::9db9/64</tt>.</p>





<h4 class="sect3title">3.1.2. <a name="portnums">Números de portas</a></h4>


<p> Se você se lembra, apresentamos anteriormente o <a href="#lowlevel">Modelo de rede em camadas</a> que tinha a camada de Internet (IP) separada da Camada de Transporte Host-para-Host (TCP e
UDP). Atenção a isso antes do próximo parágrafo.</P>

<p> Acontece que, além de um endereço IP (usado pela camada IP),
há outro endereço usado pelo TCP (sockets stream) e,
coincidentemente, por UDP (sockets datagram). É o <i>número da porta</i>. É um número de 16 bits que é como o endereço local da conexão.</p>


<p> Pense no endereço IP como o endereço de um hotel e o endereço 
da porta como o número do quarto. Essa é uma analogia decente; talvez mais tarde
eu venha com uma envolvendo a indústria automobilística.</p>

<p> Digamos que você queira ter um computador que lide com e-mails recebidos
E serviços web—como você diferencia os dois em um único computador com um único endereço IP?</p>

<p> Bem, serviços diferentes na Internet têm diferentes
números de porta bem conhecidos. Você pode vê-los todos em <a href="http://www.iana.org/assignments/port-numbers" target="_blank">the Big IANA Port List</a> ou, se você estiver em um ambiente Unix, em seu
<i>arquivo <tt class="var">/etc/services</tt></i>. O HTTP (a web) usa a porta 80, o telnet usa a porta 23, 
SMTP a porta 25, o jogo <a href="http://en.wikipedia.org/wiki/Doom_(video_game)" target="_blank">DOOM</a>
usa a porta 666, etc. E assim por diante. Portas abaixo de 1024 são frequentemente consideradas especiais, 
e geralmente exigem privilégios especiais do Sistema Operacional para seu uso.</p>

<p> E é isso!</p>

 

 



<h3 class="sect2title">3.2. <a name="byteorder">Byte Order</a></h3>


<p> <a name="indexId434909-61"></a> Por ordem do rei! Haverá duas ordenações de bytes, a seguir conhecidas como ótima e péssima!</p>

<p> Brincadeira, mas uma é realmente melhor do que a outra. <tt>:-)</tt></p>

<p> Não há uma maneira fácil de dizer isso, então só vou deixar escapar: seu computador pode estar armazenando bytes em ordem inversa bem abaixo do seu nariz. Eu sei! Ninguém queria te dizer.</p>

<p> O fato é que todos no mundo da Internet geralmente concordam que se você quiser representar o número hexadecimal de dois bytes, digamos
<tt class="tt">b34f</tt>, você poderá armazená-lo em dois bytes sequenciais <tt class="tt">b3</tt>
seguido de <tt class="tt">4F</tt>. Faz sentido, e, como <a href="http://en.wikipedia.org/wiki/Wilford_Brimley" target="_blank">Wilford Brimley</a> diria, é a coisa
certa a se fazer. Esse número, armazenado com a parte mais significativa primeiro, é chamado <i>Big-Endian</i>.</p>

<p> Infelizmente, alguns computadores espalhados aqui e ali ao longo
o mundo, ou seja, qualquer coisa com um processador Intel ou compatível com Intel,
armazena os bytes de forma invertida, de modo que <tt class="tt">b34f</tt> seria armazenado na memória como
os bytes sequenciais <tt class="tt">4F</tt> seguido de <tt class="tt">B3</tt>. Este método de armazenamento é chamado <i>Little-Endian</i>.</p>

<p> Mas espere, ainda não terminei com a terminologia! O
<i>Big-Endian</i>, o mais sensato, também é chamado <i>Network Byte Order</i>
porque essa é a ordem em que os tipos de rede funcionam.</p>


<p>Seu computador salva números em <i>Host Byte Order</i>. Se ele é um Intel 80x86, o Host Byte Order é Little-Endian.  
Se é um Motorola 64k, o Host Byte Order é Big-Endian. Se é um PowerPC, o Host Byte Order
é..., isso depende!</p>


<p> Muitas vezes, quando você cria pacotes ou preenche estruturas de dados você precisa se certificar de que seus números de dois e quatro bytes estão
em Network Byte Order. Mas como você pode fazer isso se você não conhece o Host Byte Order nativo?</p>

<p> Boas notícias! Você acabou de supor que o Host Byte Order não está correto,
e você sempre passa os valore através de uma função para configurá-los para Network
Byte Order. A função fará a conversão mágica se for necessário e ,desta forma, o seu código torna-se portátil entre máquinas com endianness diferentes.</p>

<p>Tudo certo. Existem dois tipos de números que você pode converter:
<nobr><tt class="type">short</tt></nobr> (dois bytes) e <nobr><tt class="type">long</tt></nobr> (quatro bytes).
Essas funções funcionam para variações de <nobr><tt class="type">unsigned</tt></nobr>.
Digamos que você queira converter um <nobr><tt class="type">short</tt></nobr> de Host Byte Order para
Network Byte Order. Comece com "h" para "host", siga com "to",
depois, "n" para "rede" e "s" para "short": h-to-n-s, ou
<b><tt class="func">htons()</tt></b> (Leia: "Host to Network Short").</p>

<p>Isso é quase um tanto fácil...</p>

<p>Você pode usar todas as combinações de "n", "h", "s" e "l" desejadas,
sem contar as realmente estúpidas. Por exemplo, NÃO há função
<b><tt class="func">stolh()</tt></b> ("Short to Long Host")—não aqui, de qualquer forma. 
Mas há:</p>

<center><table class="joetable" cellspacing="0" cellpadding="10" border="0">

<tbody><tr><td width="20%%" valign="top" align="left"><a name="indexId434909-62"></a><b><tt class="func">htons()</tt></b></td>
<td width="78%%" valign="top" align="left"><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">s</tt></b>hort</td>
</tr>

<tr><td valign="top" align="left"><a name="indexId434909-63"></a><b><tt class="func">htonl()</tt></b></td>
<td valign="top" align="left"><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">l</tt></b>ong</td>
</tr>

<tr><td valign="top" align="left"><a name="indexId434909-64"></a><b><tt class="func">ntohs()</tt></b></td>
<td valign="top" align="left"><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">s</tt></b>hort</td>
</tr>

<tr><td valign="top" align="left"><a name="indexId434909-65"></a><b><tt class="func">ntohl()</tt></b></td>
<td valign="top" align="left"><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">l</tt></b>ong</td>
</tr>

</tbody></table></center>

<p> Basicamente, você precisará converter os números para Network Byte Order
antes de saírem pelo fio e convertê-los de volta a Host Byte Order quando recebidos pelo fio.</p>

<p> Eu não conheço sobre a variante de 64 bits, desculpe. E se você quiser fazer com
ponto flutuante, confira a seção sobre <a href="#serialization">Serialização</a>, bem abaixo.</p>

<p> Suponha que os números neste documento estejam em Host Byte Order, a menos que eu
diga o contrário.</p>
 



<h3 class="sect2title">3.3. <a name="structs"><nobr> <b> <tt class="titletype">struct</tt></b></nobr>s</a></h3>


<p> Bem, finalmente estamos aqui. É hora de falar sobre programação.
Nesta seção, cobrirei vários tipos de dados usados pelas interfaces de sockets, 
uma vez que alguns deles são verdadeiros mistérios a se descobrir.</p>

<p> Primeiro, o mais fácil: o descritor de socket<a name="indexId434909-66"></a>.
Um descritor de socket é do seguinte tipo:</p>

<pre class="code">int</pre>


<p> Apenas um <nobr><tt class="type">int</tt></nobr> regular.</p>

<p> As coisas ficam estranhas a partir daqui, então apenas leia comigo e acredite.</p>

<p> Minha Primeira Struct <sup> <small> TM</small></sup>—<a name="indexId434909-67"></a> <nobr> <tt class="type">struct
addrinfo</tt></nobr>. Essa estrutura é uma invenção mais recente e é usada para preparar as estruturas de 
endereço do socket para uso posterior. Também é usada em pesquisas de nome de host e pesquisas de nome de 
serviço. Isso fará mais sentido mais tarde quando chegarmos ao seu uso real, mas saberemos por enquanto que é uma 
das primeiras coisas que você ligará ao fazer uma conexão.</p>

<pre class="code">struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 para "qualquer"
    size_t           ai_addrlen;   // tamanho de ai_addr em bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in ou _in6
    char            *ai_canonname; // nome de host dentro dos padrões e completo

    struct addrinfo *ai_next;      // lista ligada, próximo nó
};</pre>


<p> Você vai carregar essa struct rapidamente, e depois chamar <a name="indexId434909-68"></a> <b> <tt class="func">getaddrinfo()</tt></b>. 
Ela retornará um ponteiro para uma nova lista ligada dessa estrutura preenchida com todos os itens necessários.</p>

<p> Você pode forçá-la a usar IPv4 ou IPv6 no campo <i><tt class="var">ai_family</tt></i>, ou deixá-lo como <tt class="const">AF_UNSPEC</tt> para usar qualquer um. Isto é
legal porque o seu código pode ser funcional com qualquer versão IP.</p>


<p>Note que esta é uma lista ligada: <i><tt class="var">ai_next</tt></i> aponta para o próximo elemento—pode haver vários resultados para você escolher. 
Eu usaria o primeiro resultado que funcionasse, mas você poderia ter necessidades de negócios diferentes; 
Eu não sei tudo, man!</p>

<p> Você verá que o campo <i><tt class="var">ai_addr</tt></i> na <nobr><tt class="type">struct addrinfo</tt></nobr> é um ponteiro para uma <a name="indexId434909-69"></a> <nobr> <tt class="type">struct sockaddr</tt></nobr>. 
É ai que começamos a entrar nos detalhes básicos do que está dentro de uma struct de endereço IP.</p>

<p> Você não precisa escrever a essas estruturas usualmente; muitas vezes,
uma chamada a <b> <tt class="func">getaddrinfo()</tt></b> para preencher a sua <nobr> <tt class="type">struct
addrinfo</tt></nobr> é tudo que você precisa. Você <i>terá</i>,
no entanto, que espiar dentro destas <nobr><tt class="type">struct</tt></nobr>s para obter seus valores 
de retorno, então vou aprensentá-los aqui.</p>

<p> (Além disso, todo o código escrito antes de <nobr> <tt class="type">struct addrinfo</tt></nobr> ser inventada 
eram embalados à mão, então você vai ver um monte de códigos IPv4 em estado bruto que fazem exatamente isso. 
Você sabe, em versões antigas deste guia e assim por diante.)</p>

<p> Algumas <nobr> <tt class="type">struct</tt></nobr>s são IPv4, algumas são IPv6, e algumas são ambas.
Vou fazer anotações de quais são o que.</p>

<p> De qualquer forma, a <nobr> <tt class="type">struct sockaddr</tt></nobr> detém informações de endereço de socket 
para muitos tipos de sockets.</p>

<pre class="code">struct sockaddr {
    unsigned short    sa_family;    // família de endereços, AF_xxx
    char              sa_data[14];  // 14 bytes para endereço do protocolo
}; 
</pre>


<p> <i><tt class="var">sa_family</tt></i> pode ser uma variedade de coisas, mas vai ser 
<a name="indexId434909-70"></a> <tt class="const">AF_INET</tt> (IPv4) ou <a name="indexId434909-71">
</a> <tt class="const">AF_INET6</tt> (IPv6) para tudo o que fizermos neste
 documento. <i><tt class="var">sa_data</tt></i> contém um endereço de destino
e o número da porta para o socket. Isto é bastante complicado, pois você não
quer embalar tediosamente o endereço no <i><tt class="var">sa_data</tt></i> manualmente.</p>

<p> Para lidar com <nobr> <tt class="type">struct sockaddr</tt></nobr>, os programadores criaram um
estrutura paralela: <a name="indexId434909-72"></a> <nobr><tt class="type">struct sockaddr_in</tt></nobr> ( "in" para "Internet") para ser usada com IPv4.</p>

<p> E <i>esta é a parte importante</i>: um ponteiro para uma <nobr><tt class="type">struct
sockaddr_in</tt></nobr> pode ser convertido para um ponteiro para uma <nobr><tt class="type">struct
sockaddr</tt></nobr> e vice-versa. Assim, mesmo que <b><tt class="func">connect()</tt></b>
queira uma <nobr><tt class="type">struct sockaddr*</tt></nobr>, você ainda pode usar uma <nobr>
<tt class="type">struct sockaddr_in</tt></nobr> e converte-lá no último minuto!</p>

<pre class="code">// (IPv4 somente--veja struct sockaddr_in6 para IPv6)

struct sockaddr_in {
    short int          sin_family;  // Família de endereços, AF_INET
    unsigned short int sin_port;    // Número de Porta
    struct in_addr     sin_addr;    // Endereço Internet
    unsigned char      sin_zero[8]; // Mesmo tamanho que struct sockaddr
};
</pre>


<p> Esta estrutura facilita a referência de elementos de endereço do socket. 
Note que <i><tt class="var">sin_zero</tt></i> (que está incluso na struct para indicar 
o comprimento de uma <nobr> <tt class="type">struct sockaddr</tt></nobr>) deve ser
todo definido para zero com a função <b> <tt class="func">memset()</tt></b>. Além disso, observe
que <i><tt class="var">sin_family</tt></i> corresponde a <i><tt class="var">sa_family</tt></i>
em uma <nobr> <tt class="type">struct sockaddr</tt></nobr> e deve ser configurado para
<tt class="const">"AF_INET"</tt>. Finalmente, o <i><tt class="var">sin_port</tt></i> deve estar
em <a name="indexId434909-73"></a> <i>Network Byte Order</i> (usando <a name="indexId434909-74"></a> <b> <tt class="func">htons()</tt></b>!)</p>

<p> Vamos cavar mais fundo! Você vê que o campo <i><tt class="var">sin_addr</tt></i> é uma 
<nobr> <tt class="type">struct in_addr</tt></nobr>. Que coisa é essa? Bem, para não ser
excessivamente dramático, mas é uma das mais assustadoras unions de todos os tempos:</p>


<pre class="code">// (IPv4 somente--veja struct in6_addr para IPv6)

// Internet address (uma estrutura por razões históricas)
struct in_addr {
    uint32_t s_addr; // é um int de 32 bits (4 bytes)
};</pre>


<p> Uau! Bem, isso <i>era usado</i> para ser uma união, mas agora aqueles dias
parecem ter desaparecido. Boa viagem. Então, se você declarou
<i><tt class="var">ina</tt></i> para ser do tipo <nobr> <tt class="type">struct sockaddr_in</tt></nobr>, então
<i><tt class="var">ina.sin_addr.s_addr</tt></i> faz referência ao endereço IP de 4 bytes (Network Byte Order). 
Observe que, mesmo que o seu sistema ainda use a terrível union em <nobr> <tt class="type">struct em_addr</tt></nobr>, 
você ainda pode referenciar o endereço IP de 4 bytes exatamente da mesma maneira que eu fiz acima (isto devido a <tt class="tt">#define</tt>s.)</p>

<p> E sobre <a name="indexId434909-75"></a> IPv6? Existem<nobr> <tt class="type">struct</tt></nobr>s 
para ele, assim:</p>

<pre class="code">// (IPv6 somente--veja struct sockaddr_in e struct in_addr para IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // Família de Endereços, AF_INET6
    u_int16_t       sin6_port;     // Número da Porta, Network Byte Order
    u_int32_t       sin6_flowinfo; // Informação de Fluxo IPv6
    struct in6_addr sin6_addr;     // Endereço IPv6
    u_int32_t       sin6_scope_id; // ID do escopo
};

struct in6_addr {
    unsigned char   s6_addr[16];   // Endereço IPv6 
};</pre>

<p> Observe que o IPv6 tem um endereço IPv6 e um número de porta, assim como IPv4
tem um endereço IPv4 e um número de porta.</p>

<p> Além disso, note que eu não estou começando a falar sobre as informações de fluxo IPv6
ou campos de identificação de escopo neste momento ... este é apenas um guia de iniciação.<tt>:-)</tt></p>

<p> Por último, mas não menos importante, aqui está outra estrutura simples, <nobr> <tt class="type">struct sockaddr_storage</tt></nobr> que é projetada para ser grande o suficiente para manter ambas as estruturas IPv4 e IPv6. 
Veja, para algumas chamadas, às vezes você não sabe com antecedência se vai preencher sua <nobr> 
	<tt class="type">struct sockaddr</tt></nobr> com um endereço IPv4 ou IPv6. Assim
você passa por esta estrutura paralela, muito semelhante à <nobr> <tt class="type">struct
sockaddr</tt></nobr>, exceto maior, e depois a converte para o tipo que você precisa:</p>

<pre class="code">struct sockaddr_storage {
    sa_family_t  ss_family;     // Família de endereços

    // tudo isso é preenchimento, implementação específica, ignorá-lo:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};</pre>


<p> O que é importante é que você pode ver a família de endereços no campo
<i><tt class="var">ss_family</tt></i>—verifique isso para ver se é
<tt class="const">AF_INET</tt> ou <tt class="const">AF_INET6</tt> (para IPv4 ou
IPv6). Então você pode converter para uma <nobr> <tt class="type">struct sockaddr_in</tt></nobr> ou
<nobr> <tt class="type">struct sockaddr_in6</tt></nobr> se você quiser.</p>

 






<h3 class="sect2title">3.4. <a name="ipaddrs2">Endereços IP, Parte Dois</a></h3>


<p> Felizmente para você, há diversas funções que lhe permitem
manipular <a name="indexId434909-76"></a> endereços IP. Não há necessidade de os descobrir
à mão e enchê-las por um <nobr><tt class="type">longo</tt></nobr> tempo usando o operador <tt class="tt">&lt;&lt;</tt>.</p>

<p> Primeiro, digamos que você tenha uma <nobr> <tt class="type">struct sockaddr_in ina</tt></nobr>, e
você tem um endereço IP "<tt class="tt">10.12.110.57</tt>" ou
"<tt class="tt">2001:db8:63b3:1::3490</tt>" que você deseja armazenar nela. A
função que você desejará usar, <a name="indexId434909-77"></a> <b><tt class="func">inet_pton()</tt></b>, converte um endereço IP em notação de números e pontos
 em uma <nobr> <tt class="type">struct in_addr</tt></nobr> ou uma <nobr> <tt class="type">struct in6_addr</tt></nobr> dependendo se você especificar <tt class="const">AF_INET</tt>
ou <tt class="const">AF_INET6</tt>. ("pton" significa "presentation to network"—você pode chamar isso de "printable to network" se for mais fácil
para lembrar.) A conversão pode ser feita da seguinte forma:</p>

<pre class="code">struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

inet_pton(AF_INET, "10.12.110.57", &amp;(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &amp;(sa6.sin6_addr)); // IPv6</pre>


<p> (Nota rápida: a velha maneira de fazer as coisas utilizado uma função chamada <a name="indexId434909-78"></a> <b> <tt class="func">inet_addr()</tt></b> ou outra função chamada
<a name="indexId434909-79"></a> <b> <tt class="func">inet_aton()</tt></b>; são agora obsoletas 
e não funcionam com o IPv6.)</p>

<p> Agora, o trecho de código acima não é muito robusto porque não há
verificação de erros. Veja, <b><tt class="func">inet_pton()</tt></b> retorna
<tt class="const">-1</tt> em caso de erro, ou 0 se o endereço é confuso. Portanto, para garantir verifique se 
o resultado é superior a 0 antes de usar!</p>

<p> Tudo bem, agora você pode converter strings de endereços IP em suas representações binárias. 
E o contrário? E se você tem uma<nobr> <tt class="type">struct in_addr</tt></nobr> e você quiser imprimi-lá em notação de números-e-pontos? 
(Ou uma <nobr> <tt class="type">struct in6_addr</tt></nobr> que você quer na notação hex-e-dois-pontos). Neste caso, você vai querer usar a
função <a name="indexId434909-80"></a> <b> <tt class="func">inet_ntop()</tt></b> ("ntop" significa "network to presentation"—você pode chamá-lo de "network to printable"
se for mais fácil de lembrar), assim:</p>

<pre class="code">// IPv4:

char ip4[INET_ADDRSTRLEN];  // espaço para manter a string IPv4
struct sockaddr_in sa;      // fingir que isso é carregado com alguma coisa

inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf("O endereço IPv4 é: %s\n", ip4);


// IPv6:

char ip6[INET6_ADDRSTRLEN]; // espaço para manter a string IPv6
struct sockaddr_in6 sa6;    // fingir que isso é carregado com alguma coisa

inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);

printf("O endereço IPv6 é: %s\n", ip6);</pre>


<p> Quando você executa, você passa o tipo de endereço (IPv4 ou IPv6), o
endereço, um ponteiro para uma string que manterá o resultado e o máximo
comprimento dessa string. (Duas macros seguram convenientemente o tamanho da 
grande string de endereço IPv4 ou IPv6:
<tt class="const">INET_ADDRSTRLEN</tt> e <tt class="const">INET6_ADDRSTRLEN</tt>.)</p>

<p> (Outra nota rápida a mencionar, mais uma vez a velha maneira de fazer as
coisas: a função histórica para fazer esta conversão foi chamada <a name="indexId434909-81"></a> <b> <tt class="func">inet_ntoa()</tt></b>. 
Também é obsoleta e não vai funcionar com o IPv6.)</p>

<p> Por fim, essas funções só funcionam com endereços de IP numéricos, 
elas não irão fazer qualquer pesquisa de servidor de nomes DNS para um nome de host,
como "www.example.com". Você usará <b> <tt class="func">getaddrinfo()</tt></b> para fazer
isso, como você verá mais tarde.</p>



<h4 class="sect3title">3.4.1. <a name="privnet">Redes Privadas (ou desconectadas)</a></h4>


<p> <a name="indexId434909-82"></a> Muitos lugares têm um <a name="indexId434909-83"></a> firewall que oculta a rede local do restante do mundo para sua própria proteção. 
E muitas vezes, o firewall traduz endereços IP "internos" para "externos" (que todos os outros no mundo conhecem) usando um processo chamado 
<i>Network Address Translation</i>, ou <a name="indexId434909-84"></a>NAT.</p>

<p> Você ainda está ficando nervoso? "Onde ele está indo com todas estas coisas estranhas?"</p>

<p> Bem, relaxe e compre uma bebida não-alcoólica (ou alcoólica)
porque, como iniciante, você não precisa nem se preocupar com o NAT,
ele é feito para você de forma transparente. Mas eu queria falar sobre a rede
atrás do firewall no caso de você começar a ficar confuso com números de rede que esteja vendo.</p>

<p> Por exemplo, eu tenho um firewall em casa. Eu tenho dois endereços IPv4 estáticos 
alocados para meu uso pela empresa do DSL, e ainda tenho sete computadores na rede. 
Como isso é possível? Dois computadores não podem
compartilhar um mesmo endereço IP, ou então os dados não saberiam para qual deles se destinam!</p>

<p> A resposta é: eles não compartilham os mesmos endereços IP. Eles estão em uma
rede privada, com 24 milhões de endereços IP alocados para eles. Eles são
todos só para mim. Bem, tudo para mim, tanto quanto para qualquer outra pessoa que esteja preocupada.
Aqui está o que está acontecendo:</p>

<p> Se eu fizer login em um computador remoto, ele me informará que estou logado em 192.0.2.33, que é o endereço IP público que meu ISP forneceu para mim.
Mas se eu perguntar ao meu computador local qual é seu endereço IP, ele diz 10.0.0.5.
Quem está traduzindo o endereço IP de um para o outro? Está certo, o firewall! Está fazendo NAT!</p>

<p>10.<i>x</i>.<i>x</i>.<i>x</i> é um dos poucos endereços de rede reservados que só deve ser usado em redes totalmente desconectadas,
ou em redes que estão atrás de firewalls. Os detalhes de quais
números de redes privadas estão disponíveis para uso estão descritos na <a href="http://tools.ietf.org/html/rfc1918" target="_blank">RFC 1918</a>,
mas alguns comuns que você verá são <a name="indexId434909-85"></a> 10.<i>x</i>.<i>x</i>.<i>x</i> e <a name="indexId434909-86"></a>192.168.<i>x</i>.<i>x</i>, onde <i>x</i>
é 0-255, geralmente. Menos comum é
172.<i>y</i>.<i>x</i>.<i>x</i>, onde <i>y</i> varia entre 16 e 31.</p>

<p> Redes atrás de um firewall NAT não <i>necessitam</i> estar em uma faixa de IP´s reservados, mas eles geralmente estão.</p>

<p> (Curiosidade! Meu endereço IP externo não é realmente 192.0.2.33.
A rede 192.0.2.<i>x</i> é reservada para simular um IP "real" em documentações, assim como neste guia! Uau!)</p>

<p> <a name="indexId434909-87"></a> O IPv6 também possui redes privadas. 
Elas começam com <tt class="tt">fd<i>xx</i>:</tt> (ou talvez no futuro <tt class="tt">fc<i>XX</i>:</tt>), conforme <a href = "http://tools.ietf.org/html/rfc4193" target = "_ blank" > RFC 4193</a>. NAT e IPv6 não
se misturam geralmente, no entanto (a menos que você esteja fazendo gateway IPv6 para IPv4, o que está além do escopo deste documento)—em teoria
você terá tantos endereços à sua disposição que você não precisará
usar NAT por muito mais tempo. Mas se você quiser alocar endereços para você
em uma rede que não será encaminhada para fora, é assim que se faz.</p>



<hr class="mainsectbreak" /> <h2 class="sect1title">4. <a name="ip4to6">Saltando de IPv4 para IPv6</a></h2> <hr class="mainsecthr" />


<p> <a name="indexId434909-88"></a> Mas eu só quero saber o que mudar no meu código para continuar com o IPv6! Diga-me agora!</p>

<p> Ok! Ok!</p>

<p> Quase tudo aqui já foi dito a cima, mas a versão curta para os impacientes. (Claro, há mais que isso, mas isso é o que se aplica ao guia.)</p>

<ol>

<li> Em primeiro lugar, tente usar <a name="indexId434909-89"></a> <a href="#getaddrinfo"><b> <tt class="func">getaddrinfo()</tt></b></a> para obter todas as
informações para <nobr> <tt class="type">struct sockaddr</tt></nobr>, em vez de embalar a estrutura manualmente. 
Isto irá mantê-la compatível entre versões de IP, e irá eliminar muitos dos passos seguintes.</li>


<li> Em qualquer lugar em que você perceba estar codificando qualquer coisa relacionada a versão IP, 
tente a embalar com uso de uma função auxiliar.</li>


<li> Alterar <tt class="const">AF_INET</tt> para <tt class="const">AF_INET6</tt>.</li>


<li> Alterar <tt class="const">PF_INET</tt> para <tt class="const">PF_INET6</tt>.</li>


<li><p> Alterar atribuições <tt class="const">INADDR_ANY</tt> para
atribuições <tt class="const">in6addr_any</tt>, que são ligeiramente diferentes:</p>

<pre class="code">struct sockaddr_in sa;
struct sockaddr_in6 sa6;

sa.sin_addr.s_addr = INADDR_ANY;  // use meu endereço IPv4
sa6.sin6_addr = in6addr_any; // use meu endereço IPv6</pre>


<p> Além disso, o valor <tt class="const">IN6ADDR_ANY_INIT</tt> pode ser usado como um
inicializador quando a <nobr> <tt class="type">struct in6_addr</tt></nobr> é declarada, assim:</p>

<pre class="code">struct in6_addr ia6 = IN6ADDR_ANY_INIT;</pre>

<p></p> 
</li>


<li> Em vez de <nobr> <tt class="type">struct sockaddr_in</tt></nobr> use <nobr> <tt class="type">struct
sockaddr_in6</tt></nobr>, certificando-se de adicionar "6" para os campos conforme apropriado
(Veja <a href="#structs"><nobr> <tt class="type">struct</tt></nobr></a>, acima). Não há campo <i><tt class="var">sin6_zero</tt></i>.</li>


<li> Em vez de <nobr> <tt class="type">struct in_addr</tt></nobr> use <nobr> <tt class="type">struct
in6_addr</tt></nobr>, certificando-se de adicionar "6" para os campos conforme apropriado (ver
<a href="#structs"><nobr> <tt class="type">struct</tt></nobr>s</a>, acima).</li>


<li> Em vez de <b> <tt class="func">inet_aton()</tt></b> ou <b> <tt class="func">inet_addr()</tt></b>, use
<b><tt class="func">inet_pton()</tt></b>.</li>


<li> Em vez de <b> <tt class="func">inet_ntoa()</tt></b>, use
<b><tt class="func">inet_ntop()</tt></b>.</li>


<li> Em vez de <b> <tt class="func">gethostbyname()</tt></b>, utilize a superior
<b><tt class="func">getaddrinfo()</tt></b>.</li>


<li> Em vez de <b> <tt class="func">gethostbyaddr()</tt></b>, use a <a name="indexId434909-90"></a> <b> <tt class="func">getnameinfo()</tt></b> (embora
<b><tt class="func">gethostbyaddr()</tt></b> ainda possa trabalhar com IPv6).</li>


<li> <tt class="const">INADDR_BROADCAST</tt> não funciona mais. Use multicast IPv6 em seu lugar.</li>


</ol>


<p><i>E é isso</i>!</p>




<hr class="mainsectbreak"/> <h2 class="sect1title">5. <a name="syscalls">Chamadas de Sistema</a></h2> <hr class="mainsecthr" />


<p> Esta é a seção onde nós entramos nas chamadas de sistema (e outras
chamadas de bibliotecas) que permitem que você acesse funcionalidades de rede de um
ambiente Unix, ou qualquer ambiente que suporte a API de sockets para esses assuntos (BSD,
Windows, Linux, Mac, o-que-você-tiver.). Quando você chama uma dessas funções, o kernel assume o controle e faz todo o trabalho para você
automagicamente.</p>

<p> O lugar onde a maioria das pessoas ficam presas aqui é na ordem de chamada das funções. 
Para essas funções, as páginas <b class="com">man</b> não fazem nenhum sentido,
como você já deve ter descoberto. Bem, para ajudar nessa terrível situação, tentei expor as chamadas do sistema nas seções a seguir
<i>exatamente</i> (aproximadamente) na mesma ordem em que você precisa chamá-las em seus programas.</p>

<p> Isso, juntamente com algumas amostras de códigos aqui e ali, um pouco de leite com biscoitos (que temo que você tenha que fornecer a si mesmo),
e algumas vísceras cruas com coragem, e você estará transmitindo dados pela Internet como o Filho de Jon Postel!</p>

<p> <i>(Observe que, por brevidade, muitos trechos de código abaixo não fazem as verificações 
necessárias de erros. E eles muito comumente assumem que
os resultados de chamadas a <b><tt class="func">getaddrinfo()</tt></b> têm sucesso e retornam uma
entrada válida para a lista ligada. Ambas as situações são adequadamente
abordados nos programas autônomos, portanto, use-os como um modelo.)</i></p>




<h3 class="sect2title">5.1. <a name="getaddrinfo"><b><tt class="titlefunc">getaddrinfo()</tt></b>—Prepare Para Começar!</a></h3>

<p> <a name="indexId434909-91"></a> Esta função é um verdadeiro burro de carga com diversas opções, mas seu uso é realmente muito simples. 
Ela ajuda a definir as <nobr> <tt class="type">struct</tt></nobr>s que você irá precisar mais tarde.</p>

<p> Um pouco de história: Costumávamos usar uma função
chamada <b><tt class="func">gethostbyname()</tt></b> para fazer pesquisas de DNS. Então carregávamos 
essa informação à mão em uma <nobr><tt class="type">struct sockaddr_in</tt></nobr>,
e usávamos isso em nossas chamadas.</p>

<p> Isto não é mais necessário, felizmente (Também não é desejável, se
você quer escrever código que funcione tanto para IPv4 quanto para IPv6!). Nestes
tempos modernos, você tem agora a função <b><tt class="func">getaddrinfo()</tt></b> que
faz todos os tipos de coisas boas para você, incluindo pesquisas de nomes DNS e serviço,
e preenche as <nobr> <tt class="type">struct</tt></nobr>s que você precisa, além disso!</p>

<p> Vamos dar uma olhada!</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node,     // Ex. "www.example.com" ou IP
                const char *service,  // Ex. "http" ou número da porta
                const struct addrinfo *hints,
                struct addrinfo **res);</pre>


<p> Você passa à essa função três parâmetros de entrada, e dá-lhe um
ponteiro para uma lista ligada, <i><tt class="var">res</tt></i>, para resultados.</p>

<p> O parâmetro <i><tt class="var">node</tt></i> é o nome do host a se conectar, ou
um endereço IP.</p>

<p> Em seguida vem o parâmetro <i><tt class="var">service</tt></i>, que pode ser um número de porta, como "80", ou o nome de um determinado serviço (encontrados em <a href="http://www.iana.org/assignments/port-numbers" target="_blank">The IANA Port List</a> ou no
arquivo <i><tt class="var">/etc/services</tt></i> em sua máquina Unix) como "http" ou "ftp" ou "telnet" ou "smtp" ou qualquer outro.</p>

<p> Finalmente, o parâmetro <i><tt class="var">hints</tt></i> aponta para uma <nobr><tt class="type">struct
addrinfo</tt></nobr> já preenchida por você com informações relevantes.</p>

<p>Aqui está uma chamada de exemplo, se você é um servidor no IP do seu próprio host, porta 3490.
Observe que isso não faz realmente nenhuma escuta ou configuração de rede; ele simplesmente configura estruturas que usaremos depois:</p>

<pre class="code">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // apontará para os resultados

memset(&amp;hints, 0, sizeof hints); // verifique se a estrutura está vazia
hints.ai_family = AF_UNSPEC;     // não me importo se IPv4 ou IPv6
hints.ai_socktype = SOCK_STREAM; // sockets stream TCP
hints.ai_flags = AI_PASSIVE;     // preencha meu IP para mim

if ((status = getaddrinfo(NULL, "3490", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1);
}

// servinfo agora aponta para uma lista encadeada de 1 ou mais struct addrinfos

// ... faça tudo até que você não precise mais de servinfo ....

freeaddrinfo(servinfo); // liberar a lista encadeada</pre>


<p> Observe que eu defini o <i><tt class="var">ai_family</tt></i> para
<tt class="const">AF_UNSPEC</tt>, dizendo com isso que eu não me importo se usarmos
IPv4 ou IPv6. Você pode configurá-lo para <tt class="const">AF_INET</tt> ou
<tt class="const">AF_INET6</tt> se você quiser um ou outro especificamente.</p>

<p> Além disso, você verá a flag <tt class="const">AI_PASSIVE</tt> ali; isto
diz a <b> <tt class="func">getaddrinfo()</tt></b> para atribuir o endereço do meu host local
a estrutura do socket. Isso é bom porque você não precisa codificá-lo. (Ou você pode colocar um endereço específico como primeiro
parâmetro de <b><tt class="func">getaddrinfo()</tt></b>, onde eu tenho atualmente
<tt class="const">NULL</tt>, lá em cima.)</p>

<p> Então nós fazemos a chamada. Se houver um erro
(<b> <tt class="func">getaddrinfo()</tt></b> retornar diferente de zero), podemos imprimi-lo usando
a função <b> <tt class="func">gai_strerror()</tt></b>, como você pode ver. Se tudo
funcionar corretamente, porém, <i><tt class="var">servinfo</tt></i> irá apontar para uma lista ligada
de <nobr><tt class="type">struct addrinfo</tt></nobr>s, cada uma das quais contém uma <nobr><tt class="type">struct
sockaddr</tt></nobr> de algum tipo que podemos usar mais tarde! Bacana!</p>

<p> Finalmente, quando terminamos de usar a lista ligada que
<b> <tt class="func">getaddrinfo()</tt></b> tão graciosamente alocou para nós, nós podemos (e
devemos) liberar tudo com uma chamada a <b><tt class="func">freeaddrinfo()</tt></b>.</p>

<p> Aqui está um exemplo de chamada se você é um cliente que quer se conectar a um
determinado servidor, digamos "www.example.net" na porta 3490. Novamente, isto não faz
realmente se conectar, mas configura as estruturas que usaremos mais tarde:</p>

<pre class="code">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  //apontará para os resultados

memset(&amp;hints, 0, sizeof hints); // verifique se a estrutura está vazia
hints.ai_family = AF_UNSPEC;     // não me importo se IPv4 ou IPv6
hints.ai_socktype = SOCK_STREAM; // sockets stream TCP

// prepare-se para conectar
status = getaddrinfo("www.example.net", "3490", &amp;hints, &amp;servinfo);

// servinfo agora aponta para uma lista encadeada de 1 ou mais struct addrinfos

// etc.</pre>


<p> Eu continuo dizendo que <i><tt class="var">servinfo</tt></i> é uma lista ligada com todos os
tipos de informações de endereço. Vamos escrever um programa de demonstração rápida para mostrar essas informações. 
<a href="http://beej.us/guide/bgnet/examples/showip.c" target="_blank">Esta pequeno programa</a> irá imprimir os endereços IP para qualquer host que você
especifique na linha de comando:</p>

<pre class="code">/*
** showip.c -- mostra endereços IP para um host dado na linha de comando
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;

int main(int argc, char *argv[])
{
    struct addrinfo hints, *res, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"uso: showip nome_do_host\n");
        return 1;
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // AF_INET ou AF_INET6 para forçar versão
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
        return 2;
    }

    printf("Endereço IP para %s:\n\n", argv[1]);

    for(p = res;p != NULL; p = p-&gt;ai_next) {
        void *addr;
        char *ipver;

        // pegue o ponteiro para o endereço em si,
        // campos diferentes em IPv4 e IPv6:
        if (p-&gt;ai_family == AF_INET) { // IPv4
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr;
            addr = &amp;(ipv4-&gt;sin_addr);
            ipver = "IPv4";
        } else { // IPv6
            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-&gt;ai_addr;
            addr = &amp;(ipv6-&gt;sin6_addr);
            ipver = "IPv6";
        }

        // converta o IP em uma string e imprima:
        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr);
        printf("  %s: %s\n", ipver, ipstr);
    }

    freeaddrinfo(res); // liberar a lista ligada

    return 0;
}</pre>


<p> Como você pode ver, o código chama <b><tt class="func">getaddrinfo()</tt></b> para o que quer que você
passe na linha de comando, que preenche a lista ligada apontado por
<i><tt class="var">res</tt></i>, e então nós podemos iterar sobre a lista e imprimir coisas ou fazer qualquer coisa.</p>

<p> (Há um pouco de feiúra lá onde nós temos que cavar diferentes tipos de <nobr><tt class="type">struct sockaddr</tt></nobr>s dependendo da versão IP. Me desculpe por isso! Eu não tenho certeza de uma maneira melhor de contornar isso.)</p>

<p> Execução de exemplo! Todo mundo adora screenshots:</p>

<pre class="screen">$ <b class="com">showip www.example.net</b>
Endereço IP para www.example.net:

  IPv4: 192.0.2.88

$ <b class="com">showip ipv6.example.com</b>
Endereço IP para ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171</pre>

<p> Agora que temos isso sob controle, usaremos os resultados que obtivemos
de <b><tt class="func">getaddrinfo()</tt></b> para passar a outras funções de socket e,
finalmente, estabelecer a nossa conexão de rede! Continue lendo!</p>

 






<h3 class="sect2title">5.2. <a name="socket"><b> <tt class="titlefunc">socket()</tt></b>—Obtenha o descritor de arquivo!</a></h3>


<p> Eu acho que não posso mais deixar de falar—eu tenho que falar sobre a chamada de sistema
<a name="indexId434909-92"></a> <b><tt class="func">socket()</tt></b>. Aqui está o detalhamento:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol); 
</pre>


<p> Mas o que são esses argumentos? Eles permitem que você diga que tipo de
socket deseja (IPv4 ou IPv6, stream ou datagram, e TCP ou UDP).</p>

<p> As pessoas costumavam codificar esses valores, e você  ainda pode fazer isso. 
(<i><tt class="var">domain</tt></i> é <tt class="const">PF_INET</tt> ou <tt class="const">PF_INET6</tt>, <i><tt class="var">type</tt></i>
é <tt class="const">SOCK_STREAM</tt> ou <tt class="const">SOCK_DGRAM</tt>, e
<i><tt class="var">protocol</tt></i> pode ser definido como <tt class="const">0</tt> para escolher o
protocolo apropriado para o dado <tt class="const">type</tt>. Ou você pode chamar
<b><tt class="func">getprotobyname()</tt></b> para procurar o protocolo desejado, "tcp" ou "udp".)</p>

<p> (Este <tt class="const">PF_INET</tt> é um parente próximo do <a name="indexId434909-93"></a> <tt class="const">AF_INET</tt> que você pode usar ao inicializar
o campo <i><tt class="var">sin_family</tt></i> em sua <nobr><tt class="type">struct sockaddr_in</tt></nobr>.
Na verdade, eles são tão intimamente relacionados que possuem realmente o mesmo valor, e muitos programadores chamam <b><tt class="func">socket()</tt></b> e passam
<tt class="const">AF_INET</tt> como o primeiro argumento em vez de
<b><tt class="func">PF_INET</tt></b>. Agora, pegue um pouco de leite com biscoitos, porque é hora da história. 
Era uma vez, há muito tempo, pensava-se que talvez uma família de endereços (o que significa o "AF" em "<tt class="const">AF_INET</tt>") pudesse suportar vários protocolos que foram referidos por
sua família de protocolo (o que significa "PF" em "<tt class="const">PF_INET</tt>"). Isso não aconteceu. E todos viveram felizes para sempre, fim. Então a coisa mais certa a fazer é usar <tt class="const">AF_INET</tt>
em sua <nobr><tt class="type">struct sockaddr_in</tt></nobr> e <tt class="const">PF_INET</tt> em sua chamada a <b><tt class="func">socket()</tt></b>.)</p>

<p> De qualquer forma, chega disso. O que você realmente precisa fazer é usar os valores
a partir dos resultados da execução de <b><tt class="func">getaddrinfo()</tt></b>, e alimentá-los em <b><tt class="func">socket()</tt></b> diretamente assim:</p>

<pre class="code">int s;
struct addrinfo hints, *res;

// faça a pesquisa
// [fingir que já preenchemos a estrutura "hints"]
getaddrinfo("www.example.com", "http", &amp;hints, &amp;res);

// [novamente, você deve fazer a verificação de erros em getaddrinfo() e percorrer
// a lista vinculada "res" procurando entradas válidas
// assumindo que a primeiro é válida (como muitos desses exemplos fazem.)
// <a href="#clientserver">Veja a seção sobre cliente/servidor</a> para exemplos reais.]

s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</pre>


<p> <b><tt class="func">socket()</tt></b> simplesmente retorna a você um <i>descritor de socket</i> que você pode usar em chamadas de sistema posteriores, ou
<tt class="const">-1</tt> em caso de erro. A variável global <i><tt class="var">errno</tt></i> é definida
para o valor do erro (veja a página man <a href="#errnoman"><i><tt class="var">errno</tt></i></a> para mais detalhes, e uma
nota rápida sobre o uso de <i><tt class="var">errno</tt></i> em programas multithreaded).</p>

<p> Bem, bem, bem, mas o que é bom neste socket? A resposta é que não é muito bom por si só, e você precisa ler e fazer mais chamadas de sistema para que possa fazer qualquer sentido.</p>




<h3 class="sect2title">5.3. <a name="bind"><b> <tt class="titlefunc">bind()</tt></b>—Em que porta eu estou?</a></h3>


<p> <a name="indexId434909-94"></a> Depois de ter um socket, você pode ter que associar
esse socket com uma porta <a name="indexId434909-95"></a>em sua máquina local. (Isto
é comumente feito se você estiver usando <a name="indexId434909-96"></a><b> <tt class="func">listen()</tt></b> para conexões de entrada em uma
porta específica—jogos de rede multijogador fazem isso quando dizem para 
"conectar a 192.168.5.10 na porta 3490".) O número da porta é usado pelo kernel para combinar um pacote de entrada ao descritor de socket de um determinado processo. 
Se você estiver apenas usando <a name="indexId434909-97"></a> <b> <tt class="func">connect()</tt></b> (porque você é o cliente, não
o servidor), isso provavelmente será desnecessário. Leia de qualquer maneira, apenas para diversão.</p>

<p> Aqui está a sinopse para a chamada de sistema <b><tt class="func">bind()</tt></b>:</p>


<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o descritor de arquivo de socket retornado por
<b><tt class="func">socket()</tt></b>. <i><tt class="var">my_addr</tt></i> é um ponteiro para uma
<nobr><tt class="type">struct sockaddr</tt></nobr> que contém informações sobre o seu
endereço, ou seja, porta e <a name="indexId434909-98"></a>endereço IP.
<i><tt class="var">addrlen</tt></i> é o comprimento em bytes desse endereço.</p>

<p> Uau. Isso é uma amostra para que possamos absorver em pouco tempo. Vamos a um
exemplo de uso de sockets com bind() no host onde o programa é executado, porta 3490:</p>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// primeiro, carregar estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // usar IPv4 ou IPv6, qualquer que seja
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // preencha meu IP para mim

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// cria o socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// Usa bind na porta que passamos a getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<p> Ao utilizar a flag <tt class="const">AI_PASSIVE</tt>, estou dizendo ao programa para usar bind() no IP da máquina em que está sendo executado. Se você deseja usar bind em um
endereço IP local específico, ignore <tt class="const">AI_PASSIVE</tt> e ponha o endereço IP como primeiro argumento de <b> <tt class="func">getaddrinfo()</tt></b>.</p>

<p> <b> <tt class="func">bind()</tt></b> também retorna <tt class="const">-1</tt>
em caso de erro e põe em <i><tt class="var">errno</tt></i> o valor do erro.</p>

<p> Muitos códigos antigos empacotam manualmente a <nobr><tt class="type">struct sockaddr_in</tt></nobr>
antes de chamar <b><tt class="func">bind()</tt></b>. Obviamente, isso é específico para IPv4,
mas não há realmente nada que impeça você de fazer a mesma coisa com
IPv6, exceto que o uso de <b><tt class="func">getaddrinfo()</tt></b> será
mais fácil, em geral. De qualquer forma, o código antigo é algo como isto:</p>


<pre class="code">// !!! ESTE É O MODO ANTIGO !!!

int sockfd;
struct sockaddr_in my_addr;

sockfd = socket(PF_INET, SOCK_STREAM, 0);

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(MYPORT);     // short, network byte order
my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof my_addr);</pre>


<p> No código acima, você também pode atribuir <tt class="const">INADDR_ANY</tt> ao
campo <i><tt class="var">s_addr</tt></i>, se você quiser usar bind no seu endereço de IP local 
(como a flag <tt class="const">AI_PASSIVE</tt>, acima). A versão IPv6
de <tt class="const">INADDR_ANY</tt> é uma variável global
<i><tt class="var">in6addr_any</tt></i> que é atribuída ao campo <i><tt class="var">sin6_addr</tt></i>
de sua <nobr><tt class="type">struct sockaddr_in6</tt></nobr>. (Há também uma macro
<tt class="const">IN6ADDR_ANY_INIT</tt> que você pode usar em uma variável inicializadora.)</p>

<p> Outra coisa a observar ao chamar <b><tt class="func">bind()</tt></b>:
não use números baixos como endereços de portas. <a name="indexId434909-99"></a> Todas as portas
abaixo de 1024 são RESERVADAS (a menos que você seja o superusuário)! Você pode ter qualquer
número de porta acima disso, até 65535 (desde que não esteja sendo usada por outro programa).</p>

<p> Às vezes, você pode perceber, você tenta executar novamente um servidor e
<b><tt class="func">bind()</tt></b> falha, alegando <a name="indexId434909-100"></a> "Endereço
já em uso." O que significa isso? Bem, parte de um socket
que estava conectado ainda está pendurada no kernel e está monopolizando a porta. Você pode esperar que ele seja limpo (um minuto ou mais)
ou adicionar ao seu programa código que lhe permita reutilizar a porta, como isso:</p>

<pre class="code"><a name="indexId434909-101"></a><a name="indexId434909-102"></a>int yes=1;
//char yes='1'; // usuários Solaris façam isso

// contornar a mensagem de erro "Endereço já em uso"
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof yes) == -1) {
    perror("setsockopt");
    exit(1);
} 
</pre>


<p> <a name="indexId434909-103"></a> Uma pequena nota final extra sobre
<b><tt class="func">bind()</tt></b>: há momentos em que você absolutamente não precisará chamá-la. 
Se você está conectado com <a name="indexId434909-104"></a> <b><tt class="func">connect()</tt></b> a uma
máquina remota e você não se importa com a porta local (como é o caso com <b class="com">telnet</b>, onde você só se preocupa com a porta remota),
você pode simplesmente chamar <b><tt class="func">connect()</tt></b>, ela verificará se o socket está desativado, e fará <b><tt class="func">bind()</tt></b> para uma porta local não usada, se necessário.</p>








<h3 class="sect2title">5.4. <a name="connect"><b><tt class="titlefunc">connect()</tt></b>—Ei, você!</a></h3>


<p> <a name="indexId434909-105"></a> Vamos fingir por alguns minutos que você é
uma aplicação telnet. Seu usuário ordena que você (assim como no filme
<a name="indexId434909-106"></a><i>TRON</i>) obtenha um descritor de arquivo de socket. Você
obedece e chama <b><tt class="func">socket()</tt></b>. Em seguida, o usuário diz-lhe para
conectar-se a "<tt class="tt">10.12.110.57</tt>" na porta "<tt class="tt">23</tt>" (a porta padrão
para telnet.) Uau! O que você faz agora?</p>

<p> Para sua sorte, programa, você está agora examinando a seção sobre
<b><tt class="func">connect()</tt></b>—como se conectar a um host remoto. Então leia
furiosamente a seguir! Não há tempo a perder!</p>

<p> A chamada <b><tt class="func">connect()</tt></b> é a seguinte:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o nosso descritor de arquivo socket amigável, como retornado pela chamada a <b><tt class="func">socket()</tt></b>, 
<i><tt class="var">serv_addr</tt></i> é uma <nobr><tt class="type">struct sockaddr</tt></nobr> contendo a porta de destino e o endereço IP, e
<i><tt class="var">addrlen</tt></i> é o comprimento em bytes da estrutura de endereço do servidor.</p>

<p> Todas essas informações podem ser adquiridas a partir dos resultados da chamada de <b><tt class="func">getaddrinfo()</tt></b>.</p>

<p> Isso está começando a fazer mais sentido? Eu não posso lhe ouvir a partir daqui, por isso,
eu espero que esteja. Vamos dar um exemplo onde fazemos uma conexão a "www.example.com", porta 3490:</p>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// Primeiro, carregue as estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);

// crie o socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// conectar!

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<p> Mais uma vez, os programas old-school preenchiam suas próprias <nobr><tt class="type">struct sockaddr_in</tt></nobr> para passar a <b><tt class="func">connect()</tt></b>. 
Você pode fazer isso se você quiser. Veja a nota similar na seção <a href="#bind"><b><tt class="func">bind()</tt></b></a>, acima.</p>

<p> Certifique-se de verificar o valor de retorno de
<b><tt class="func">connect()</tt></b>—ela retornará <tt class="const">-1</tt> em caso de erro
e configurará a variável <i><tt class="var">errno</tt></i>.</p>

<p> <a name="indexId434909-107"></a> Além disso, observe que nós não chamamos
<b><tt class="func">bind()</tt></b>. Basicamente, nós não nos importamos com o nosso número de porta local; 
nós só nos importamos com para onde estamos indo (a porta remota). O kernel
irá escolher uma porta local para nós, e o site ao qual nos conectaremos receberá automaticamente essas informações. Não se preocupe.</p>








<h3 class="sect2title">5.5. <a name="listen"><b> <tt class="titlefunc">listen()</tt></b>—Alguém por favor pode me ligar?</a></h3>


<p> <a name="indexId434909-108"></a> Ok, tempo para uma mudança de ritmo. E se você não quiser se conectar a um host remoto? Digo, apenas por diversão, você quer
esperar conexões de entrada e tratá-las de alguma forma. O processo é executado em dois passos: primeiro você usa <b><tt class="func">listen()</tt></b>, então você
<a name="indexId434909-109"></a> usa <b><tt class="func">accept()</tt></b> (veja abaixo).</p>

<p> A chamada de escuta (listen) é bastante simples, mas requer um pouco de explicação:</p>

<pre class="code">int listen(int sockfd, int backlog); 
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o descritor de arquivo de socket de costume
da chamada de sistema <b><tt class="func">socket()</tt></b>.
<a name="indexId434909-110"></a> <i><tt class="var">backlog</tt></i> é o número de
conexões permitidas na fila de entrada. O que isso significa? Bem,
conexões de entrada vão esperar nesta fila até que você as aceite com 
<b><tt class="func">accept()</tt></b> (veja abaixo) e este é o limite de quantas
podem entrar na fila. A maioria dos sistemas limita silenciosamente esse número para cerca de 20; você
provavelmente pode definir como <tt class="const">5</tt> ou <tt class="const">10</tt>.</p>

<p> Mais uma vez, como de costume, <b><tt class="func">listen()</tt></b> retorna
<tt class="const">-1</tt> em erros e configura <i><tt class="var">errno</tt></i>.</p>

<p> Bem, como você provavelmente pode imaginar, precisamos chamar
<b><tt class="func">bind()</tt></b> antes de chamarmos <b><tt class="func">listen()</tt></b> para que o
servidor esteja sendo executado em uma porta específica. (Você tem que ser capaz de dizer aos seus
amigos em que porta conectarem-se!) Então, se você estiver ouvindo as conexões de entrada, 
a seqüência de chamadas de sistema que você fará é:</p>

<pre class="code">getaddrinfo();
socket();
bind();
listen();
/* accept() aceita aqui */ 
</pre>


<p> Eu só vou deixar isso no lugar do código de exemplo, uma vez que é
bastante autoexplicativo. (O código na seção <b><tt class="func">accept()</tt></b>, 
abaixo, é mais completo.) A parte realmente complicada de todas estas coisas é a chamada de <b><tt class="func">accept()</tt></b>.</p>








<h3 class="sect2title">5.6. <a name="accept"><b> <tt class="titlefunc">accept()</tt></b>—"Obrigado por ligar para a porta 3490."</a></h3>


<p> <a name="indexId434909-111"></a> Prepare-se—a chamada a <b><tt class="func">accept()</tt></b> é meio estranha! 
O que vai acontecer é o seguinte: alguém de muito longe
vai tentar usar <b><tt class="func">connect()</tt></b> contra a sua máquina em uma porta em que você
usou <b><tt class="func">listen()</tt></b>. As conexões serão enfileiradas
esperando para serem aceitas com <b><tt class="func">accept()</tt></b>. Você chama <b><tt class="func">accept()</tt></b>
e diz a ela para obter a conexão pendente. Ela vai retornar para você um novo
<i>descritor de arquivo socket</i> para utilizar com esta única conexão! É isso mesmo, de repente você tem <i>dois descritores de arquivos sockets</i> pelo preço de um! O original ainda continua
esperando novas conexões, e o recém-criado está finalmente
pronto para o uso de <b><tt class="func">send()</tt></b> e <b><tt class="func">recv()</tt></b>. Chegamos lá!</p>

<p> A chamada é a seguinte:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o descritor de socket de 
<b><tt class="func">listen()</tt></b>. Bastante fácil.
<i><tt class="var">addr</tt></i> normalmente será um ponteiro para uma <nobr><tt class="type">struct sockaddr_storage</tt></nobr> local. É onde as informações
sobre a conexão de entrada irão (e com elas você pode determinar
qual host está lhe chamando de qual porta). <i><tt class="var">addrlen</tt></i> é uma
variável local do tipo inteira que deve ser definida para <tt class="tt">sizeof (struct
sockaddr_storage)</tt> antes de seu endereço ser passado a 
<b><tt class="func">accept()</tt></b>. <b><tt class="func">accept()</tt></b> não vai colocar mais bytes do que 
<i><tt class="var">addr</tt></i> foi configurado para guardar. Se ele colocar um menor número, ele ira
alterar o valor de <i><tt class="var">addrlen</tt></i> para refletir isso.</p>

<p> Adivinha? <b><tt class="func">accept()</tt></b> retorna <tt class="const">-1</tt> e define
<i><tt class="var">errno</tt></i> se ocorrer um erro. Aposto que não percebeu.</p>

<p> Como antes, isso é muito para absorver em tão pouco tempo, então aqui está um
fragmento de código de exemplo para leitura:</p>

<pre class="code">#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MYPORT "3490"  // a porta onde os usuários estarão se conectando
#define BACKLOG 10     // quantidade de conexões enfileiradas

int main(void)
{
    struct sockaddr_storage their_addr;
    socklen_t addr_size;
    struct addrinfo hints, *res;
    int sockfd, new_fd;

    // !! não esqueça de fazer verificação de erros para as chamadas !!

    // primeiro, carregue as estruturas de endereços com getaddrinfo():

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;  // usar IPv4 ou IPv6, o que for
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;     // preencha meu IP para mim

    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

    // cria um socket, liga-o com bind, e ouve nele com listen:

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    listen(sockfd, BACKLOG);

    // agora aceita uma conexão de entrada:

    addr_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

    // pronto para se comunicar no descritor de socket new_fd!
    .
    .
    .</pre>


<p> Mais uma vez, note que vamos usar o descritor de socket
<i><tt class="var">new_fd</tt></i> para todas as chamadas <b><tt class="func">send()</tt></b> e
<b><tt class="func">recv()</tt></b>. Se você está recebendo apenas uma única conexão, você pode fechar com <b><tt class="func">close()</tt></b> a escuta de <i><tt class="var">sockfd</tt></i>
a fim de evitar mais conexões de entrada na mesma porta, se você assim desejar.</p>








<h3 class="sect2title">5.7. <a name="sendrecv"><b><tt class="titlefunc">send()</tt></b> e <b><tt class="titlefunc">recv()</tt></b>—Fale comigo, baby!</a></h3>


<p> Estas duas funções são para comunicação através de sockets stream ou
sockets datagram conectados. Se você quiser usar sockets datagram regulares desconectados, você precisa ver a seção sobre <a href="#sendtorecv"><b><tt class="func">sendto()</tt></b> e <b><tt class="func">recvfrom()</tt></b></a>, abaixo.</p>

<p> <a name="indexId434909-112"></a> A chamada <b><tt class="func">send()</tt>:</b></p>

<pre class="code">int send(int sockfd, const void *msg, int len, int flags); 
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o descritor de socket para o qual você quer
enviar dados (seja ele o retornado por
<b><tt class="func">socket()</tt></b> ou o que você recebeu com <b><tt class="func">accept()</tt></b>.) 
<i><tt class="var">msg</tt></i> é um ponteiro
para os dados que você deseja enviar, e <i><tt class="var">len</tt></i> é o
comprimento desses dados em bytes. Basta definir <i><tt class="var">flags</tt></i> para
<tt class="const">0</tt>. (Veja a página man de <b><tt class="func">send()</tt></b> para mais informações sobre flags.)</p>

<p> Um código de exemplo pode ser:</p>

<pre class="code">char *msg = "Beej was here!";
int len, bytes_sent;
.
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
. 
</pre>


<p> <b><tt class="func">send()</tt></b> retorna o número de bytes realmente
enviados<i>—isso pode ser menor do que o número que você disse para ela
enviar!</i> Veja, às vezes você diz para enviar um monte de dados e
ela simplesmente não pode lidar com isso. Ela irá disparar tanto dos dados quanto possível,
e confiará em você para enviar o resto mais tarde. Lembre-se, se o valor retornado
por <b><tt class="func">send()</tt></b> não coincide com o valor no <i><tt class="var">len</tt></i>,
cabe a você enviar o resto da string. A boa notícia é a seguinte:
se o pacote for pequeno (menos de 1K ou quase isso) ela irá <i>provavelmente</i>
gerenciar para enviar a coisa toda de uma só vez. Mais uma vez, <tt class="const">-1</tt>
é devolvido em caso de erro, e <i><tt class="var">errno</tt></i> é definido para o número do erro.</p>

<p> <a name="indexId434909-113"></a>A chamada de <b><tt class="func">recv()</tt></b> é semelhante em muitos aspectos:</p>

<pre class="code">int recv(int sockfd, void *buf, int len, int flags);</pre>

<p> <i><tt class="var">sockfd</tt></i> é o descritor de socket a ser lido, 
<i><tt class="var">buf</tt></i> é o buffer para receber as informações, 
<i><tt class="var">len</tt></i> é o comprimento máximo do buffer,
e <i><tt class="var">flags</tt></i> pode ser novamente ajustada para
<tt class="const">0</tt>. (Veja a página man de <b><tt class="func">recv()</tt></b> para obter informações sobre flags.)</p>

<p> <b><tt class="func">recv()</tt></b> retorna o número de bytes realmente
lidos no buffer, ou <tt class="const">-1</tt> em caso de erro (com
<i><tt class="var">errno</tt></i> ajustado de acordo.)</p>

<p> Espere! <b><tt class="func">recv()</tt></b> pode retornar
<tt class="const">0</tt>. Isso só pode significar uma coisa: o lado remoto
terminou a conexão com você! Um valor de retorno
<tt class="const">0</tt> é a forma de <b><tt class="func">recv()</tt></b> informar que isso ocorreu.</p>

<p> Agora, isso foi fácil, não foi? Agora você pode enviar e receber dados em sockets stream! Uau! Você é um Programador de Rede Unix!</p>








<h3 class="sect2title">5.8. <a name="sendtorecv"><b><tt class="titlefunc">sendto()</tt></b> e
<b><tt class="titlefunc">recvfrom()</tt></b>—Fale comigo, DGRAM-style</a></h3>


<p> <a name="indexId434909-114"></a> "Isto é tudo muito bom e elegante," Eu ouvi você dizendo: "mas onde é que isto me deixa com sockets datagram desconectados?" Sem problema, amigo. Nós temos a coisa.</p>

<p> Como sockets datagram não estão conectados a um host remoto, adivinha qual informação precisamos fornecer antes de enviar um pacote? Está certo! O endereço de destino! Aqui está o escopo:</p>

<pre class="code">int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen);</pre>


<p> Como você pode ver, esta chamada é basicamente a mesma que a chamada 
<b><tt class="func">send()</tt></b> com a adição de dois outros pedaços de 
informação. <i><tt class="var">to</tt></i> é um ponteiro para uma <nobr> <tt class="type">struct
sockaddr</tt></nobr> (que provavelmente será outra <nobr><tt class="type">struct
sockaddr_in</tt></nobr> ou <nobr><tt class="type">struct sockaddr_in6</tt></nobr> ou <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> que você converteu no último minuto), que contém
o endereço IP de destino <a name="indexId434909-115"></a> e <a name="indexId434909-116"></a> porta.
<i><tt class="var">tolen</tt></i>, um <nobr><tt class="type">int</tt></nobr> lá no fundo, pode simplesmente ser definido
para <tt class="tt">sizeof *to</tt> ou <tt class="tt">sizeof(struct sockaddr_storage)</tt>.</p>

<p> Para colocar as mãos na estrutura de endereço de destino, você 
provavelmente a obterá de <b><tt class="func">getaddrinfo()</tt></b>, ou a partir de
<b><tt class="func">recvfrom()</tt></b>, abaixo, ou preencherá manualmente.</p>

<p> Assim como com <b><tt class="func">send()</tt></b>,
<b><tt class="func">sendto()</tt></b> retorna o número de bytes realmente enviados
(que, novamente, pode ser menor do que o número de bytes que você disse para ela
enviar), ou <tt class="const">-1</tt> em caso de erro.</p>

<p> Igualmente semelhantes são <b><tt class="func">recv()</tt></b> e
<a name="indexId434909-117"></a> <b><tt class="func">recvfrom()</tt></b>. A sinopse
de <b><tt class="func">recvfrom()</tt></b> é:</p>

<pre class="code">int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen);</pre>


<p> Novamente, isso é exatamente como <b><tt class="func">recv()</tt></b> com a
adição de alguns campos. <i><tt class="var">from</tt></i> é um ponteiro para uma
<a name="indexId434909-118"></a> <nobr><tt class="type">struct sockaddr_storage</tt></nobr>
que será preenchida com o endereço IP e a porta da máquina de origem. 
<i><tt class="var">fromlen</tt></i> é um ponteiro para um <nobr><tt class="type">int</tt></nobr> local, que deve ser inicializado para <tt class="tt">sizeof *from</tt> ou
<tt class="tt">sizeof (struct sockaddr_storage)</tt>. Quando a função retornar,
<i><tt class="var">fromlen</tt></i> irá conter o comprimento do endereço armazenado em <i><tt class="var">from</tt></i>.</p>

<p> <b><tt class="func">recvfrom()</tt></b> retorna o número de bytes
recebidos, ou <tt class="const">-1</tt> em caso de erro (com
<i><tt class="var">errno</tt></i> ajustado em conformidade.)</p>

<p> Então, aqui vai uma pergunta: Por que usamos <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> como o tipo de socket? Por que não <nobr><tt class="type">struct
sockaddr_in</tt></nobr>? Porque, veja, nós não queremos nos amarrar ao IPv4 ou IPv6. Então, usamos uma struct genérica <nobr><tt class="type">struct
sockaddr_storage</tt></nobr>, que sabemos que será grande o suficiente para ambos.</p>

<p> (Então... aqui está uma outra questão: por que <nobr><tt class="type">struct
sockaddr</tt></nobr> não é grande o suficiente para qualquer endereço? Nós até definimos a 
<nobr><tt class="type">struct sockaddr_storage</tt></nobr> de propósito geral para a 
<nobr><tt class="type">struct sockaddr</tt></nobr> de propósito geral! Parece estranho e
redundante, hum. A resposta é, ela simplesmente não é grande o suficiente, e eu acho que
alterá-la neste momento seria problemático. Então, eles fizeram uma nova.)</p>

<p> Lembre-se, se você usa <a name="indexId434909-119"></a> <b><tt class="func">connect()</tt></b> com um socket datagram, 
então você pode simplesmente usar <b><tt class="func">send()</tt></b> e
<b><tt class="func">recv()</tt></b> para todas as suas transações. O socket em si ainda é
um socket datagram e os pacotes ainda usam UDP, mas a interface do socket
irá adicionar automaticamente as informações de destino e fonte
para você.</p>










<h3 class="sect2title">5.9. <a name="closedown"><b><tt class="titlefunc">close()</tt></b> e
<b><tt class="titlefunc">shutdown()</tt></b>—Não olhe mais na minha cara!</a></h3>


<p> Ufa! Você está enviando dados com <b><tt class="func">send()</tt></b> e
recebendo com <b><tt class="func">recv()</tt></b> o dia inteiro, você pode fazer isso.
Você está pronto para fechar a conexão em seu descritor de socket. Isso é
fácil. Você pode apenas usar a função para descritores de arquivos comuns Unix
<a name="indexId434909-120"></a> <b><tt class="func">close()</tt></b>:</p>

<pre class="code">close(sockfd); 
</pre>


<p> Isso evitará mais leituras e gravações no socket. Qualquer um
tentando ler ou escrever no socket na extremidade remota receberá um
erro.</p>

<p> Apenas no caso de você querer um pouco mais de controle sobre como o socket
fecha, você pode usar a função <a name="indexId434909-121"></a> <b><tt class="func">shutdown()</tt></b>. 
Ela permite que você interrompa a comunicação em um determinado
sentido, ou em ambos os sentidos (assim como <b><tt class="func">close()</tt></b> faz.)
Sinopse:</p>

<pre class="code">int shutdown(int sockfd, int how); 
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o descritor de arquivo socket que você
deseja desligar, e <i><tt class="var">how</tt></i> é um dos seguintes:</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="10%%"><tt class="const">0</tt></td>
<td valign="top" align="left" width="88%%">Recebimentos seguintes desativados</td>
</tr>

<tr><td valign="top" align="left"><tt class="const">1</tt></td>
<td valign="top" align="left">Envios seguintes desativados</td>
</tr>

<tr><td valign="top" align="left"><tt class="const">2</tt></td>
<td valign="top" align="left">Envios e recebimentos seguintes desativados (como <b><tt class="func">close()</tt></b>)</td>
</tr>

</table></center>


<p> <b><tt class="func">shutdown()</tt></b> retorna <tt class="const">0</tt> em
caso de sucesso, e <tt class="const">-1</tt> em caso de erro (com
<i><tt class="var">errno</tt></i> ajustado em conformidade.)</p>

<p> Se você se atrever a usar <b><tt class="func">shutdown()</tt></b> em sockets datagram desconectados, 
ela simplesmente tornará o socket indisponível para posteriores chamadas de 
<b><tt class="func">send()</tt></b> e <b><tt class="func">recv()</tt></b>
(lembre-se de que você pode usá-las se você usou <b><tt class="func">connect()</tt></b> com sockets datagram.)</p>

<p> É importante notar que <b><tt class="func">shutdown()</tt></b>
na verdade não fecha o descritor de arquivo—apenas altera a sua
usabilidade. Para liberar um descritor de socket, você precisa usar
<b><tt class="func">close()</tt></b>.</p>

<p> Nada mais sobre.</p>

<p> (Exceto para lembrar que, se você estiver usando <a name="indexId434909-122"></a> Windows
e <a name="indexId434909-123"></a> Winsock você deverá chamar <a name="indexId434909-124"></a> <b><tt class="func">closesocket()</tt></b> em vez de
<b><tt class="func">close()</tt></b>.)</p>









<h3 class="sect2title">5.10. <a name="getpeername"><b><tt class="titlefunc">getpeername()</tt></b>—Quem é você?</a></h3>


<p> <a name="indexId434909-125"></a> Essa função é tão fácil.</p>

<p> É tão fácil, que eu quase não lhe dei a sua própria secção. Mas aqui está, de qualquer forma.</p>

<p> A função <b><tt class="func">getpeername()</tt></b> informará quem está na outra extremidade
de um socket stream conectado. A sinopse:</p>

<pre class="code">#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); 
</pre>


<p> <i><tt class="var">sockfd</tt></i> é o descritor do socket stream conectado, <i><tt class="var">addr</tt></i> é um ponteiro para uma
<nobr><tt class="type">struct sockaddr</tt></nobr> (ou uma <nobr><tt class="type">struct sockaddr_in</tt></nobr>) que
conterá as informações sobre o outro lado da conexão, e
<i><tt class="var">addrlen</tt></i> é um ponteiro para um <nobr><tt class="type">int</tt></nobr>, que
deve ser inicializado para <tt class="tt">sizeof *addr</tt> ou <tt class="tt">sizeof (struct
sockaddr)</tt>.</p>

<p> A função retorna <tt class="const">-1</tt> em caso de erro e define
<i><tt class="var">errno</tt></i> em conformidade.</p>

<p> Depois de ter seu endereço, você pode usar <a name="indexId434909-126"></a> <b><tt class="func">inet_ntop()</tt></b>, <a name="indexId434909-127"></a><b><tt class="func">getnameinfo()</tt></b> ou <a name="indexId434909-128"></a><b><tt class="func">gethostbyaddr()</tt></b> para imprimir ou obter mais
informações. Não, você não pode obter o seu nome de login. (Ok, ok. Se o
outro computador está executando um daemon ident, isso é possível. Isso,
no entanto, está além do escopo deste documento. Confira <a href="http://tools.ietf.org/html/rfc1413" target="_blank">RFC 1413</a> para mais informações.)</p>









<h3 class="sect2title">5.11. <a name="gethostname"><b><tt class="titlefunc">gethostname()</tt></b>—Quem sou eu?</a></h3>


<p> <a name="indexId434909-129"></a> Ainda mais fácil do que <b><tt class="func">getpeername()</tt></b>
é a função <b><tt class="func">gethostname()</tt></b>. Ela retorna o nome do
computador em que seu programa está sendo executado. O nome pode ser usado por
<a name="indexId434909-130"></a> <b><tt class="func">gethostbyname()</tt></b>, a seguir, para
determinar o <a name="indexId434909-131"></a> endereço IP da sua máquina local.</p>

<p> O que poderia ser mais divertido? Eu poderia pensar em algumas coisas, mas elas
não pertencem à programação de sockets. De qualquer forma, aqui está sua composição:</p>

<pre class="code">#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size); 
</pre>


<p> Os argumentos são simples: <i><tt class="var">hostname</tt></i> é um
ponteiro para um vetor de caracteres que conterá o nome do host ao retorno da função, e <i><tt class="var">size</tt></i> é o comprimento em
bytes do vetor <i><tt class="var">hostname</tt></i>.</p>

<p> A função retorna <tt class="const">0</tt> ao completar com sucesso, e <tt class="const">-1</tt> em caso de erro, estabelecendo
<i><tt class="var">errno</tt></i> como de costume.</p>



  







<hr class="mainsectbreak"/> <h2 class="sect1title">6. <a name="clientserver">Cliente-Servidor Background</a></h2> <hr class="mainsecthr"/>


<p> <a name="indexId434909-132"></a> Isso é o um mundo cliente-servidor, baby. Quase tudo na rede 
é baseado em processos cliente falando
processos servidores e vice-versa. Como <b class="com">telnet</b>, por exemplo.
Quando você se conecta a um servidor remoto na porta 23 com o telnet (o cliente), um
programa naquele host (chamado <b class="com">telnetd</b>, o servidor) ganha vida. 
Ele lida com a conexão telnet de entrada, prepara um prompt de login, etc.</p>

<a name="figure2"><center>
    <div><img src="data:png;base64,
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
QB78P8Tqkydine14AAAAAElFTkSuQmCC" alt="[Diagrama Interação Cliente-Servidor]"/></div>

    <p> <b> Interação Cliente-Servidor.</b></p>
</center></a>


<p> A troca de informações entre cliente e servidor é
resumida no <a href="#figure2">diagrama acima</a>.</p>

<p> Note que o par cliente-servidor podem falar
<tt class="const">SOCK_STREAM</tt>, <tt class="const">SOCK_DGRAM</tt>, ou
qualquer outra coisa (contanto que eles estejam falando a mesma coisa.) Alguns bons
exemplos de pares de cliente-servidor são
<b class="com">telnet</b>/<b class="com">telnetd</b>, <b class="com">ftp</b>/<b class="com">ftpd</b>, ou
<b class="com">Firefox</b>/<b class="com">Apache</b>. Toda vez que você usa
<b class="com">ftp</b>, há um programa remoto, <b class="com">ftpd</b>, que serve você.</p>

<p> Geralmente, haverá apenas um servidor em uma máquina, e esse servidor
lidará com vários clientes usando <a name="indexId434909-133"></a> <b><tt class="func">fork()</tt></b>. A rotina básica é: o servidor espera 
por uma conexão, a aceita com <b><tt class="func">accept()</tt></b>, e cria um novo processo filho com <b><tt class="func">fork()</tt></b>
para lidar com isso. Isso é o que o nosso servidor de exemplo faz na próxima seção.</p>







<h3 class="sect2title">6.1. <a name="simpleserver">Um Servidor Stream Simples</a></h3>


<p> <a name="indexId434909-134"></a> Tudo o que esse servidor faz é enviar a string
"<tt class="tt">Olá, mundo!</tt>" por uma conexão stream. Tudo que você precisa
fazer para testar este servidor é executá-lo em uma janela, e com telnet conectar a ele a partir de outra com:</p>

<pre class="screen">$ telnet remotehostname 3490</pre>


<p> Onde <tt class="tt">remotehostname</tt> é o nome da máquina em que você está executando o servidor.</p>

<p> <a href="http://beej.us/guide/bgnet/examples/server.c" target="_blank">O código do servidor</a>:</p>

<pre class="code">/*
** server.c -- uma demonstração de socket stream como servidor
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT "3490"  // a porta que os usuários usarão para se conectarem

#define BACKLOG 10     // a quantidade de conexões pendentes mantidas na fila

void sigchld_handler(int s)
{
    // waitpid() pode sobrescrever errno, então nós salvamos e restauramos:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) &gt; 0);

    errno = saved_errno;
}


// obtém sockaddr, IPv4 ou IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // ouça em sock_fd, nova conexão em new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // informações de endereço do cliente
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop através de todos os resultados e fazer bind para o primeiro que pudermos
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("servidor: socket");
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror("setsockopt");
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("servidor: bind");
            continue;
        }

        break;
    }

    freeaddrinfo(servinfo); // tudo feito com essa estrutura

    if (p == NULL)  {
        fprintf(stderr, "servidor: falha ao fazer bind\n");
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // colher todos os processos mortos
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    printf("servidor: aguardando por conexões...\n");

    while(1) {  // loop principal de accept()
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror("accept");
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf("servidor: tenho uma conexão de %s\n", s);

        if (!fork()) { // este é o processo filho
            close(sockfd); // processo filho não precisa ouvir
            if (send(new_fd, "Olá, mundo!", 12, 0) == -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // pai não precisa disso
    }

    return 0;
}</pre>


<p> Caso você esteja curioso, eu tenho o código em uma grande função
<b><tt class="func">main()</tt></b> para manter (eu sinto) a clareza sintática.
Sinta-se livre para dividi-la em funções menores, se isso te faz se sentir melhor.</p>

<p> (Além disso, toda esta coisa de <a name="indexId434909-135"></a> <b><tt class="func">sigaction()</tt></b>
pode ser nova para você—isso é ok. O código que está lá é
responsável por colher os processos <a name="indexId434909-136"></a> zumbis que
aparecem quando os processos filhos de <b><tt class="func">fork()</tt></b> terminam. Se você criar
lotes de zumbis e não terminá-los, o administrador do sistema se tornará raivoso.)</p>

<p> Você pode obter os dados desse servidor usando o cliente listado na próxima seção.</p>




<h3 class="sect2title">6.2. <a name="simpleclient">Um Cliente Stream Simples</a></h3>


<p> <a name="indexId434909-137"></a> Esse cara é ainda mais fácil que o servidor. Tudo
o que este cliente faz é conectar-se ao host especificado na linha de comandos,
porta 3490. Ele obtém a string que o servidor envia.</p>

<p> <a href="http://beej.us/guide/bgnet/examples/client.c" target="_blank">O código do cliente</a>:</p>

<pre class="code">/*
** client.c -- uma demonstração de socket stream como cliente
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT "3490" // a porta onde o cliente conectará 

#define MAXDATASIZE 100 // número máximo de bytes a obter de uma só vez 

// obtém sockaddr, IPv4 ou IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"uso: cliente hostname\n");
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // percorrer todos os resultados e conectar-se ao primeiro que pudermos
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("cliente: socket");
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("cliente: connect");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "cliente: falha a conectar\n");
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf("cliente: conectando a %s\n", s);

    freeaddrinfo(servinfo); // tudo feito com essa estrutura

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror("recv");
        exit(1);
    }

    buf[numbytes] = '\0';

    printf("cliente: recebido '%s'\n",buf);

    close(sockfd);

    return 0;
}</pre>


<p> Observe que, se você não executar o servidor antes de executar o cliente,
<b><tt class="func">connect()</tt></b> retornará
<a name="indexId434909-138"></a> "Conexão recusada". Muito útil.</p>









<h3 class="sect2title">6.3. <a name="datagram">Sockets Datagram</a></h3>


<p> Nós já cobrimos o básico de sockets UDP datagram com a nossa
discussão sobre <b><tt class="func">sendto()</tt></b> e <b><tt class="func">recvfrom()</tt></b>, acima,
então eu vou apresentar apenas alguns programas de exemplo: <i><tt class="var">talker.c</tt></i>
e <i><tt class="var">listener.c</tt></i>.</p>

<p> <a name="indexId434909-139"></a> <b class="com">listener</b> fica em uma máquina
à espera de um pacote de entrada na porta 4950. <b class="com">talker</b> envia um
pacote para essa porta, na máquina especificada, que contém o que o usuário digita na linha de comando.</p>

<p> Aqui está o código fonte para <a href="http://beej.us/guide/bgnet/examples/listener.c" target="_blank">
<i><tt class="var">listener.c</tt></i></a>:</p>

<pre class="code">/*
** listener.c -- uma demonstração de socket "servidor" com datagram
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT "4950"    // a porta onde os usuários se conectarão

#define MAXBUFLEN 100

// obtém sockaddr, IPv4 ou IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd;
    struct addrinfo hints, *servinfo, *p;
    int rv;
    int numbytes;
    struct sockaddr_storage their_addr;
    char buf[MAXBUFLEN];
    socklen_t addr_len;
    char s[INET6_ADDRSTRLEN];

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // configure com AF_INET para forçar IPv4
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE; // use meu IP

    if ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop através de todos os resultados e fazer bind para o primeiro que pudermos
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("listener: socket");
            continue;
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("listener: bind");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "listener: falha ao fazer bind para o socket\n");
        return 2;
    }

    freeaddrinfo(servinfo);

    printf("listener: aguardando por recvfrom...\n");

    addr_len = sizeof their_addr;
    if ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
        (struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
    }

    printf("listener: tenho um pacote de %s\n",
        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s));
    printf("listener: o pacote tem %d bytes de comprimento\n", numbytes);
    buf[numbytes] = '\0';
    printf("listener: conteúdo do pacote \"%s\"\n", buf);

    close(sockfd);

    return 0;
}</pre>


<p> Observe que, em nossa chamada a <b><tt class="func">getaddrinfo()</tt></b> estamos finalmente
usando <tt class="const">SOCK_DGRAM</tt>. Além disso, observe que não há necessidade de
<b><tt class="func">listen()</tt></b> ou <b><tt class="func">accept()</tt></b>. Esta é uma das
vantagens de usar sockets datagram desconectados!</p>

<p><a name="indexId434909-140"></a>Em seguida vem o código fonte de <a href="http://beej.us/guide/bgnet/examples/talker.c" target="_blank"><i><tt class="var">talker.c</tt></i></a>:</p>

<pre class="code">/*
** talker.c --  um "cliente" de demonstração com datagram
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT "4950"    // a porta onde se conectar

int main(int argc, char *argv[])
{
    int sockfd;
    struct addrinfo hints, *servinfo, *p;
    int rv;
    int numbytes;

    if (argc != 3) {
        fprintf(stderr,"uso: talker hostname mensagem\n");
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;

    if ((rv = getaddrinfo(argv[1], SERVERPORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    //  Percorrer todos os resultados e criar socket
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("talker: socket");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "talker: falha ao criar o socket\n");
        return 2;
    }

    if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
             p-&gt;ai_addr, p-&gt;ai_addrlen)) == -1) {
        perror("talker: sendto");
        exit(1);
    }

    freeaddrinfo(servinfo);

    printf("talker: enviados %d bytes para %s\n", numbytes, argv[1]);
    close(sockfd);

    return 0;
}</pre>



<p> E isso é tudo que existe sobre o assunto! Execute <b class="com">listener</b> em alguma
máquina, em seguida, execute <b class="com">talker</b> em outra. Veja-os se comunicarem!
Diversão garantida para toda a família!</p>

<p> Você nem precisa executar o servidor dessa vez! Você pode rodar
<b class="com">talker</b>, por si só, e ele feliz e simplesmente dispara pacotes para o além, 
onde desaparecem se ninguém estiver pronto com
<b><tt class="func">recvfrom()</tt></b> no outro lado. Lembre-se: dados enviados usando
sockets datagram UDP não possuem garantia de entrega!</p>

<p> Com exceção de um pequeno detalhe que eu já mencionei muitas vezes no
passado: <a name="indexId434909-141"></a> sockets datagram conectados. Eu preciso falar sobre isso aqui, já que estamos na seção datagram do documento. 
Digamos que <b class="com">talker</b> chame
<b><tt class="func">connect()</tt></b> e especifique o endereço de <b class="com">listener</b>'s.
Daquele ponto em diante, <b class="com">talker</b> só pode enviar e receber do endereço especificado por <b><tt class="func">connect()</tt></b>. 
Por esta razão, você não tem que usar <b><tt class="func">sendto()</tt></b> e <b><tt class="func">recvfrom()</tt></b>; você
pode simplesmente usar <b><tt class="func">send()</tt></b> e <b><tt class="func">recv()</tt></b>.</p>




<hr class="mainsectbreak" /> <h2 class="sect1title">7. <a name="advanced">Técnicas Ligeiramente avançadas</a></h2> <hr class="mainsecthr" />


<p> Estas técnicas não são <i>realmente</i> avançadas, mas elas saem dos níveis mais básicos já cobertos. 
Na verdade, se você chegou até aqui, você deve se considerar bastante realizado
nos fundamentos da programação de rede Unix! Parabéns!</p>

<p> Então, aqui vamos nós para o admirável mundo novo de algumas das coisas mais
esotéricas que você pode querer aprender sobre sockets. Veja agora!</p>







<h3 class="sect2title">7.1. <a name="blocking">Blocking</a></h3>


<p> <a name="indexId434909-142"></a>Blocking. Você já ouviu falar sobre isso—agora, o que
diabos é isso? Em poucas palavras, "block" é jargão técnico para "sleep".
Você provavelmente reparou que quando você executa <b class="com">listener</b>, acima,
ele fica ali até que um pacote chegue. O que acontece é que ele chamou
<b><tt class="func">recvfrom()</tt></b>, não havia dados e, portanto, por
<b><tt class="func">recvfrom()</tt></b> é feito "block" (ou seja, dormir lá) até que alguns dados cheguem.</p>

<p> Muitas funções fazem block. <b><tt class="func">accept()</tt></b> faz block.
Todas funções <b><tt class="func">recv()</tt></b> fazem block. A razão pela qual elas
podem fazer isso é porque elas estão autorizadas. Quando você cria pela primeira vez o
descritor de socket com <b><tt class="func">socket()</tt></b>, o kernel o configura
para blocking. <a name="indexId434909-143"></a> Se você não quer um socket fazendo blocking, você tem que
fazer uma chamada a <a name="indexId434909-144"></a> <b><tt class="func">fcntl()</tt></b>:</p>

<pre class="code">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
. 
</pre>


<p> Ao definir um socket para non-blocking, você pode efetivamente "pesquisar"
o socket para obter informações. Se você tenta ler de um socket non-blocking
e não houverem dados lá, não será permitido fazer blocking—ele retornará <tt class="const">-1</tt> e <i><tt class="var">errno</tt></i> será definido como
<a name="indexId434909-145"></a> <tt class="const">EAGAIN</tt> ou
<a name="indexId434909-146"></a> <tt class="const">EWOULDBLOCK</tt>.</p>

<p> (Espera—ele pode retornar <a name="indexId434909-147"></a> <tt class="const">EAGAIN</tt>
<i>ou</i> <a name="indexId434909-148"></a> <tt class="const">EWOULDBLOCK</tt>? Por qual
você verificará? A especificação na verdade não diz qual o seu
sistema retornará, então para a portabilidade, confira ambos.)</p>

<p> De um modo geral, no entanto, este tipo de pesquisa é uma má idéia.
Se você colocar seu programa em uma espera ocupada procurando dados sobre o socket,
você irá sugar tempo de CPU de modo burro. Uma solução mais elegante
para verificar se há dados esperando para serem lidos vem na seção
a seguir em <a name="indexId434909-149"></a> <b><tt class="func">select()</tt></b>.</p>









<h3 class="sect2title">7.2. <a name="select"><b> <tt class="titlefunc">select()</tt></b>—Multiplexação Síncrona de E/S</a></h3>


<p> <a name="indexId434909-150"></a> Esta função é um pouco estranha, mas é muito
útil. Considere a seguinte situação: você é um servidor e deseja
ouvir as conexões de entrada, bem como manter a leitura das
conexões que você já possui.</p>

<p> Não há problema, você diz, apenas um <b><tt class="func">accept()</tt></b> e uns
pares de <b><tt class="func">recv()</tt></b> já resolveriam. Não tão rápido, imbecil! E se
você estiver em blocking em uma chamada <b><tt class="func">accept()</tt></b>? Como você receberá dados com 
<b><tt class="func">recv()</tt></b> ao mesmo tempo? "Use
sockets non-blocking!" De jeito nenhum! Você não quer ser um parasita de CPU. O que,
então?</p>

<p> <b> <tt class="func">select()</tt></b> lhe dá o poder para monitorar
vários sockets ao mesmo tempo. Ele lhe dirá quais estão prontos
para a leitura, quais estão prontos para a escrita, e quais sockets geraram
exceções, se você realmente quer saber isso.</p>

<p> Dito isto, nos tempos modernos, <b><tt class="func">select()</tt></b>, embora muito
portátil, é um dos métodos mais lentos para monitorar sockets. Uma
possível alternativa é o <a href="http://www.monkey.org/~provos/libevent/" target="_blank">libevent</a>, ou
algo semelhante, que encapsula todo o material dependente do sistema
envolvido na obtenção de notificações de sockets.</p>

<p> Sem mais delongas, vou oferecer a sinopse de <b><tt class="func">select()</tt></b>:</p>

<pre class="code">#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout); 
</pre>


<p> A função monitora "sets" (conjuntos) de descritores de arquivos; em particular
<i><tt class="var">readfds</tt></i>, <i><tt class="var">writefds</tt></i>, e
<i><tt class="var">exceptfds</tt></i>. Se você quiser ver se pode ler
da entrada padrão e de algum descritor de socket, <i><tt class="var">sockfd</tt></i>, 
apenas defina o descritor de arquivo <tt class="const">0</tt> e 
<i><tt class="var">sockfd</tt></i> para o "set"<i><tt class="var">readfds</tt></i>. 
O parâmetro <i><tt class="var">numfds</tt></i> deve ser definido para o valor do mais alto
descritor de arquivo mais um. Neste exemplo, ele deve ser definido para
<i><tt class="var">sockfd+1</tt></i>, uma vez que é seguramente maior que o da entrada padrão (<tt class="const">0</tt>).</p>

<p> Quando <b><tt class="func">select()</tt></b> retorna,
<i><tt class="var">readfds</tt></i> será modificado para refletir quais descritores de arquivo
selecionados por você estão prontos para a leitura. Você pode testá-los
com a macro <b><tt class="func">FD_ISSET()</tt></b>, abaixo.</p>

<p> Antes de avançar muito mais, falarei sobre como manipular
esses conjuntos. Cada set é do tipo <nobr><tt class="type">fd_set</tt></nobr>. As seguintes
macros operam neste tipo:</p>


<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="50%%"><a name="indexId434909-151"></a><b><tt class="func">FD_SET(int fd, fd_set *set);</tt></b></td>

<td valign="top" align="left" width="48%%">Adiciona <i><tt class="var">fd</tt></i> para <i><tt class="var">set</tt></i>.</td>
</tr>


<tr><td valign="top" align="left"><a name="indexId434909-152"></a><b><tt class="func">FD_CLR(int fd, fd_set *set);</tt></b></td>

<td valign="top" align="left">Remove <i><tt class="var">fd</tt></i> de <i><tt class="var">set</tt></i>.</td>
</tr>


<tr><td valign="top" align="left"><a name="indexId434909-153"></a><b><tt class="func">FD_ISSET(int fd, fd_set *set);</tt></b></td>

<td valign="top" align="left">Retorna true se <i><tt class="var">fd</tt></i> estiver em
<i><tt class="var">set</tt></i>.</td>
</tr>


<tr><td valign="top" align="left"><a name="indexId434909-154"></a><b><tt class="func">FD_ZERO(fd_set *set);</tt></b></td>

<td valign="top" align="left">Limpa todas entradas de <i><tt class="var">set</tt></i>.</td>
</tr>

</table></center>

<p> Finalmente, o que é a estranha <a name="indexId434909-155"></a>
<nobr><tt class="type">struct timeval</tt></nobr>?
Bem, às vezes você não quer esperar para sempre até que alguém lhe envie
alguns dados. Talvez a cada 96 segundos você queira imprimir "Ainda em andamento ..."
no terminal, mesmo que nada tenha acontecido. Esta estrutura de tempo
permite que você especifique um período de tempo limite. Se o tempo for excedido e
<b><tt class="func">select()</tt></b> ainda não tiver encontrado nenhum descritor de arquivo pronto, 
ele retornará para que você possa continuar o processamento.</p>

<p> A <nobr><tt class="type">struct timeval</tt></nobr> tem os campos a seguir:</p>

<pre class="code">struct timeval {
    int tv_sec;     // segundos
    int tv_usec;    // microssegundos
}; 
</pre>


<p> Basta definir <i><tt class="var">tv_sec</tt></i> para o número de segundos para
esperar, e definir <i><tt class="var">tv_usec</tt></i> para o número de
microssegundos para esperar. Sim, isso é <i>micro</i>segundos,
não milissegundos. Há 1.000 microssegundos em um milésimo de segundo, e
1.000 milissegundos em um segundo. Assim, existem 1.000.000 microssegundos
em um segundo. Por que "usec"? O "u" é supostamente parecido com a letra grega
μ (Mi) que usamos para "micro". Além disso, quando a função
retorna, <i><tt class="var">timeout</tt></i> <i>poderia</i> ser
atualizado para mostrar o tempo ainda restante. Isso depende de que sabor
de Unix você está executando.</p>

<p> Uau! Temos um temporizador com resolução de microssegundos! Bem, não conte com
isso. Você provavelmente terá que esperar em parte também o tempo padrão do seu Unix
não importando quão mínimo seja o tempo definido para <nobr><tt class="type">struct timeval</tt></nobr>.</p>

<p> Outras coisas de interesse: Se você definir os campos da sua
<nobr><tt class="type">struct timeval</tt></nobr> para <tt class="const">0</tt>,
<b><tt class="func">select()</tt></b> irá expirar imediatamente, efetivamente sondando
todos os descritores de arquivos em seus sets. Se você definir o
parâmetro <i><tt class="var">timeout</tt></i> para NULL, ele nunca terá tempo limite
e aguardará até que o primeiro descritor de arquivo esteja pronto. Finalmente, se você
não se importa em esperar por um determinado conjunto, você pode apenas configurá-lo para NULL
na chamada de <b><tt class="func">select()</tt></b>.</p>

<p> <a href="http://beej.us/guide/bgnet/examples/select.c" target="_blank">O seguinte trecho de código</a> aguarda 2,5 segundos
para que algo apareça na entrada padrão:</p>

<pre class="code">/*
** select.c -- uma demonstração de select()
*/

#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define STDIN 0  // descritor de arquivo para entrada padrão

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&amp;readfds);
    FD_SET(STDIN, &amp;readfds);

    // não me importo com writefds e exceptfds:
    select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);

    if (FD_ISSET(STDIN, &amp;readfds))
        printf("Uma tecla foi pressionada!\n");
    else
        printf("Tempo esgotado.\n");

    return 0;
} 
</pre>

<p> Se você estiver em um terminal de linha bufferizada, a tecla que você pressionar deverá ser sucedida
por RETURN ou o tempo irá expirar de qualquer maneira.</p>

<p> Agora, alguns de vocês podem pensar que esta é uma ótima maneira de esperar por dados
em um socket datagram—e você está certo: <i>pode</i> ser.
Alguns Unix podem usar select desta maneira, e outros não. Você deve
ver o que sua página man local diz sobre o assunto, se você quiser tenta-lo.</p>

<p> Alguns Unix atualizam o tempo em sua <nobr><tt class="type">struct timeval</tt></nobr> para
refletir a quantidade de tempo que resta até um tempo limite. Mas outros
não. Não confie que isso ocorra se você quer portabilidade. (Use
<a name="indexId434909-156"></a><b><tt class="func">gettimeofday()</tt></b> se você precisar
controlar o tempo decorrido. É cansativo, eu sei, mas essa é a maneira de ser feito.)</p>

<p> O que acontece se um socket no set de leitura fecha a conexão?
Bem, nesse caso, <b><tt class="func">select()</tt></b> retorna com o
descritor de socket definido como "pronto para ler". Quando você realmente faz
<b><tt class="func">recv()</tt></b> a partir dele, <b><tt class="func">recv()</tt></b>
retornará <tt class="const">0</tt>. É assim que você sabe que o cliente fechou a conexão.</p>

<p> Mais uma nota de interesse sobre <b><tt class="func">select()</tt></b>: se você tem um
socket executando <a name="indexId434909-157"></a><a name="indexId434909-158"></a> <b><tt class="func">listen()</tt></b>, você pode
verificar se há uma nova conexão colocando o descritor de arquivo do socket no set <i><tt class="var">readfds</tt></i>.</p>

<p> E isso, meus amigos, é uma rápida visão geral da poderosa função <b><tt class="func">select()</tt></b>.</p>

<p> Mas, por demanda popular, aqui está um exemplo em profundidade.
Infelizmente, a diferença entre o exemplo simples, acima, e
este aqui é significativa. Mas dê uma olhada, leia a descrição que o segue.</p>

<p> <a href="http://beej.us/guide/bgnet/examples/selectserver.c" target="_blank">Este programa</a>
funciona como um simples servidor de chat multiusuário. Comece executando-o em uma janela e,
em seguida, conecte-se via <b class="com">telnet</b> a ele ( "<b class="com">telnet hostname 9034</b>") 
a partir de várias outras janelas. Quando você digita algo
em uma sessão <b class="com">telnet</b>, isso deve aparecer em todas as outras.</p>

<pre class="code">/*
** selectserver.c -- um servidor de bate-papo com várias pessoas
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define PORT "9034"   // porta onde estaremos ouvindo

// obtém sockaddr, IPv4 ou IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    fd_set master;    // lista de descritores de arquivos master
    fd_set read_fds;  // lista de descritores de arquivos temporários para select ()
    int fdmax;        // número máximo de descritores de arquivos

    int listener;     // descritor de socket de escuta
    int newfd;        // novos descritores de socket com accept()
    struct sockaddr_storage remoteaddr; // endereço do cliente
    socklen_t addrlen;

    char buf[256];    // buffer para dados do cliente
    int nbytes;

    char remoteIP[INET6_ADDRSTRLEN];

    int yes=1;        // para setsockopt() SO_REUSEADDR, abaixo
    int i, j, rv;

    struct addrinfo hints, *ai, *p;

    FD_ZERO(&amp;master);    // limpa sets master e temporário
    FD_ZERO(&amp;read_fds);

    // nos dá um socket e faz bind nele
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, "selectserver: %s\n", gai_strerror(rv));
        exit(1);
    }
    
    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) { 
            continue;
        }
        
        // evitar a irritante mensagem de erro "endereço já em uso"
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    // se chegou até aqui, significa que não fomos impedidos
    if (p == NULL) {
        fprintf(stderr, "selectserver: falha ao fazer bind\n");
        exit(2);
    }

    freeaddrinfo(ai); // tudo feito com isso

    // listen
    if (listen(listener, 10) == -1) {
        perror("listen");
        exit(3);
    }

    // adicione listener ao set master
    FD_SET(listener, &amp;master);

    // acompanhe o maior descritor de arquivos
    fdmax = listener; // até agora, é esse aqui

    // loop principal
    for(;;) {
        read_fds = master; // copie
        if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(4);
        }

        // percorrer as conexões existentes à procura de dados para ler
        for(i = 0; i &lt;= fdmax; i++) {
            if (FD_ISSET(i, &amp;read_fds)) { // nós temos um!!
                if (i == listener) {
                    // manuseia novas conexões
                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror("accept");
                    } else {
                        FD_SET(newfd, &amp;master); // adiciona ao set master
                        if (newfd &gt; fdmax) {    // acompanhe o máximo
                            fdmax = newfd;
                        }
                        printf("selectserver: nova conexão de %s no "
                            "socket %d\n",
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // manipular dados do cliente
                    if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {
                        // há erro ou conexão fechada pelo cliente
                        if (nbytes == 0) {
                            // conexão fechada
                            printf("selectserver: socket %d desligado\n", i);
                        } else {
                            perror("recv");
                        }
                        close(i); // tchau!
                        FD_CLR(i, &amp;master); // remove do set master
                    } else {
                        // nós temos alguns dados de um cliente
                        for(j = 0; j &lt;= fdmax; j++) {
                            // envia para todos!
                            if (FD_ISSET(j, &amp;master)) {
                                // exceto listener e nós mesmos
                                if (j != listener &amp;&amp; j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror("send");
                                    }
                                }
                            }
                        }
                    }
                } // FIM manipular dados do cliente
            } // FIM receber nova conexão de entrada
        } // FIM do loop através dos descritores de arquivos
    } // FIM para (;;)--e você pensou que nunca terminaria!
    
    return 0;
}</pre>


<p> Observe que eu tenho dois sets (conjuntos) de descritores de arquivos no código:
<i><tt class="var">master</tt></i> e <i><tt class="var">read_fds</tt></i>. O
primeiro, <i><tt class="var">master</tt></i>, detém todos os descritores de socket
que estão atualmente conectados, bem como o descritor de socket que está escutando novas conexões.</p>

<p> O motivo pelo qual eu tenho o set <i><tt class="var">master</tt></i> é que
<b><tt class="func">select()</tt></b> na verdade <i>altera</i> o conjunto que você passa a ela para refletir que sockets estão 
prontos para leitura. Como tenho que acompanhar as conexões sucessivas de uma chamada <b><tt class="func">select()</tt></b>, 
devo armazená-las com segurança em algum lugar. No último minuto, eu copio a
<i><tt class="var">master</tt></i> para <i><tt class="var">read_fds</tt></i> e,
em seguida, chamo <b><tt class="func">select()</tt></b>.</p>

<p> Mas isso não significa que toda vez que recebo uma nova conexão, tenho que adicioná-la ao set 
<i><tt class="var">master</tt></i>? Sim! E cada vez que uma conexão fecha, eu tenho que removê-la do
set <i><tt class="var">master</tt></i>? Sim.</p>

<p> Repare que eu verifico quando o socket <i><tt class="var">listener</tt></i>
está pronto para leitura. Quando isso acontece, significa que tenho uma nova conexão
pendente, e eu a aceito com <b><tt class="func">accept()</tt></b> e adiciono-a ao set
<i><tt class="var">master</tt></i>. Da mesma forma, quando uma conexão de cliente
está pronta para leitura, e <b><tt class="func">recv()</tt></b> retorna
<tt class="const">0</tt>, eu sei que o cliente fechou a conexão, e
devo removê-la do set <i><tt class="var">master</tt></i>.</p>

<p> Se o cliente, em <b><tt class="func">recv()</tt></b>, retorna diferente de zero,
no entanto, eu sei que alguns dados foram recebidos. Então, eu os obtenho, e depois percorrendo 
a lista <i><tt class="var">master</tt></i> envio esses dados para o resto dos clientes conectados.</p>

<p> E isso, meus amigos, é uma visão geral simplificadíssima da
poderosa função <b><tt class="func">select()</tt></b>.</p>

<p> Em adição, aqui está um acréscimo tardio como bônus: existe outra função
chamada <a name="indexId434909-159"></a> <b><tt class="func">poll()</tt></b> que se comporta da mesma maneira
que <b><tt class="func">select()</tt></b>, mas com um sistema diferente para a gestão dos
conjuntos de descritores de arquivos. <a href="#pollman">Confira!</a></p>









<h3 class="sect2title">7.3. <a name="sendall">Manipulando <b><tt class="titlefunc">send()</tt></b>s parcialmente</a></h3>


<p> Lembra-se da seção <a href="#sendrecv">sobre <b><tt class="func">send()</tt></b></a>, acima, quando eu disse que
<b><tt class="func">send()</tt></b> pode não enviar todos os bytes que você pediu? Ou seja, você deseja enviar 512 bytes, 
mas ela retorna 412. O que aconteceu com os 100 bytes restantes?</p>

<p> Bem, eles ainda estão em seu pequeno buffer esperando para serem enviados.
Devido a circunstâncias além do seu controle, o kernel decidiu não enviar
todos os dados em um único pedaço, e agora, meu amigo, cabe a você enviar os dados restantes.</p>

<p> <a name="indexId434909-160"></a> Você poderia escrever uma função como essa para fazer isso também:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int sendall(int s, char *buf, int *len)
{
    int total = 0;        // quantos bytes nós enviamos
    int bytesleft = *len; // quantos temos para enviar
    int n;

    while(total &lt; *len) {
        n = send(s, buf+total, bytesleft, 0);
        if (n == -1) { break; }
        total += n;
        bytesleft -= n;
    }

    *len = total; // retorna número realmente enviado aqui

    return n==-1?-1:0; // retorna -1 em falha, 0 em successo
} 
</pre>


<p> Neste exemplo, <i><tt class="var">s</tt></i> é o socket para o qual você deseja 
enviar os dados, <i><tt class="var">buf</tt></i> é um buffer contendo
os dados, e <i><tt class="var">len</tt></i> é um ponteiro para um
<nobr><tt class="type">int</tt></nobr> contendo o número de bytes do buffer.</p>

<p> A função retorna <tt class="const">-1</tt> em caso de erro (e
<i><tt class="var">errno</tt></i> é definido a partir da chamada a
<b><tt class="func">send()</tt></b>.) Além disso, o número de bytes realmente enviados
é retornado em <i><tt class="var">len</tt></i>. Este será o mesmo número
de bytes que você pediu para enviar, a menos que tenha ocorrido um erro.
<b><tt class="func">sendall()</tt></b> fará o melhor possível, enviando os dados para fora, 
mas se houver um erro ele retornará de volta a você imediatamente.</p>

<p> Para completar, aqui está um exemplo de chamada para a função:</p>

<pre class="code">char buf[10] = "Beej!";
int len;

len = strlen(buf);
if (sendall(s, buf, &amp;len) == -1) {
    perror("sendall");
    printf("Nós só enviamos %d bytes por causa do erro!\n", len);
} 
</pre>


<p> O que acontece ao final da recepção quando chega apenas parte de um pacote?
Se os pacotes são de comprimento variável, como o receptor sabe quando um
pacote termina e outro começa? Sim, cenários do mundo real são bem mais complexos<a name="indexId434909-161"></a>.
Você provavelmente precisará <a name="indexId434909-162"></a> <i>encapsular</i> (lembra-se da <a href="#lowlevel">seção de encapsulamento de dados</a> lá no começo?) Leia-a para mais detalhes!</p>

<p> Nota rápida para todos os fãs do Linux: às vezes, em raras
circunstâncias, a função <b><tt class="func">select()</tt></b> do Linux pode retornar "pronta-para-ler"
e não estar realmente pronta para ler! Isso significa que <b><tt class="func">read()</tt></b> terá a leitura
bloqueada após <b><tt class="func">select()</tt></b> dizer que não teria!—De qualquer forma, a solução alternativa 
é definir a flag <a name="indexId434909-163"></a> <tt class="const">O_NONBLOCK</tt> no socket receptor
e por isso erros virão com <tt class="const">EWOULDBLOCK</tt> (que você pode apenas ignorar com segurança 
se ocorrer). Veja a <a href="#fcntlman">página de referência <b><tt class="func">fcntl()</tt></b></a> 
para mais informações sobre a configuração de um socket para non-blocking.</p>


<h3 class="sect2title">7.4. <a name="serialization">Serialização—Como embalar Dados</a></h3>

<p> <a name="indexId434909-164"></a> É fácil enviar dados em texto através da rede, você está descobrindo, 
mas o que acontece se você quiser enviar alguns dados "binários" como <nobr><tt class="type">int</tt></nobr> ou <nobr><tt class="type">float</tt></nobr>? 
Para isso você tem algumas opções.</p>

<ol>

<li> Converter o número em texto com uma função como <b><tt class="func">sprintf()</tt></b> e o enviar. 
O receptor irá analisar o texto recebido e o converterá em um número usando uma função como <b><tt class="func">strtol()</tt></b>.</li>


<li> Basta enviar os dados em sua forma bruta, passando o ponteiro dos mesmos para <b><tt class="func">send()</tt></b>.</li>


<li> Codifique o número em uma forma binária portátil. O receptor o decodificará.</li>

</ol>


<p> Visualização prévia! Apenas esta noite!</p>

<p> [<i>Cortinas se abrem</i>]</p>

<p> Beej diz: "Eu prefiro o Método três, acima!"</p>

<p> [<i>THE END</i>]</p>

<p> (Antes de começar esta seção a sério, devo dizer-lhe que existem bibliotecas para fazer isso, e criar o seu próprio código e mantê-lo livre de erros é um grande desafio. 
Então, procure e faça sua lição de casa antes de decidir implementar essas coisas você mesmo. 
Eu incluo as informações aqui para aqueles curiosos sobre como coisas como essa funcionam.)</p>

<p> Na verdade todos os métodos, acima, têm suas vantagens e desvantagens,
mas como eu disse, em geral, eu prefiro o terceiro método. Primeiro, porém,
vamos falar sobre algumas das vantagens e desvantagens para os outros dois.</p>

<p> O primeiro método, codificando os números como texto antes de enviar, tem
a vantagem de que você pode facilmente imprimir e ler os dados que estão vindo pelo fio. 
Às vezes, um protocolo legível é excelente para uso numa situação que não requeira muita largura de banda como no <a name="indexId434909-165"></a><a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat" target="_blank">Internet Relay Chat (IRC)</a>.
No entanto, tem a desvantagem de ser lento para converter e os resultados quase sempre ocupam mais espaço do que o número original!</p>

<p> Método dois: enviar os dados brutos. Este é bem fácil (mas perigoso!): basta ter um ponteiro para os dados a serem enviados, e chamar send com ele.</p>

<pre class="code">double d = 3490.15926535;

send(s, &amp;d, sizeof d, 0);  /* PERIGO--não-portátil! */</pre>


<p> O receptor recebe assim:</p>

<pre class="code">double d;

recv(s, &amp;d, sizeof d, 0);  /* PERIGO--não-portátil! */</pre>


<p> Rápido, simples—O que há para não gostar? Bem, acontece que nem
todas as arquiteturas representam um <nobr> <tt class="type">double</tt></nobr> (ou <nobr> <tt class="type">int</tt></nobr>
para esse assunto), com a mesma representação de bit ou mesmo a mesma ordenação de bytes!
O código é definitivamente não portátil. (Ei, talvez você
não precise de portabilidade, e nesse caso isso é bom e rápido.)</p>

<p> Ao empacotar tipos inteiros já vimos como a classe de funções <a name="indexId434909-166"></a> <b> <tt class="func">htons()</tt></b> pode ajudar a manter
as coisas portáteis convertendo os números para <a name="indexId434909-167"></a>
Network Byte Order e como essa é a coisa certa a fazer.
Infelizmente, não há funções semelhantes para tipos <nobr><tt class="type">float</tt></nobr>.
Toda a esperança está perdida?</p>

<p> Não temas! (Você ficou com medo por um segundo? Não? Nem mesmo um
pouco?) Há algo que podemos fazer: podemos embalar (ou "empacotar",
ou "serializar", ou um dos outros milhões de nomes) os dados em
um formato binário conhecido que o receptor possa descompactar no lado remoto.</p>

<p> O que quero dizer com "formato binário conhecido"? Bem, nós já vimos
o exemplo de <b><tt class="func">htons()</tt></b>, certo? Ele altera (ou "codifica", se
você quiser pensar dessa maneira) um número de host em qualquer formato para Network Byte Order. 
Para inverter (unencode) o número, o receptor chama <b><tt class="func">ntohs()</tt></b>.</p>

<p> Mas eu não acabei de dizer que não havia qualquer função
para outros tipos não inteiros? Sim. Eu disse. E uma vez que não há nenhuma
forma padrão em C para fazer isso, é um pouco pickle (um trocadilho gratuito para os fãs de Python).</p>

<p> A única coisa a fazer é empacotar os dados em um formato conhecido e enviá-los pelo fio para a decodificação. Por exemplo, para embalar <nobr> <tt class="type">float</tt></nobr>s,
aqui está <a href="http://beej.us/guide/bgnet/examples/pack.c" target="_blank">algo rápido e sujo com muito espaço para melhorias:</a></p>

<pre class="code">#include &lt;stdint.h&gt;

uint32_t htonf(float f)
{
    uint32_t p;
    uint32_t sign;

    if (f &lt; 0) { sign = 1; f = -f; }
    else { sign = 0; }
        
    p = ((((uint32_t)f)&amp;0x7fff)&lt;&lt;16) | (sign&lt;&lt;31); // parte inteira e sinal
    p |= (uint32_t)(((f - (int)f) * 65536.0f))&amp;0xffff; // fração

    return p;
}

float ntohf(uint32_t p)
{
    float f = ((p&gt;&gt;16)&amp;0x7fff); // parte inteira
    f += (p&amp;0xffff) / 65536.0f; // fração

    if (((p&gt;&gt;31)&amp;0x1) == 0x1) { f = -f; } // conjunto de bits de sinal

    return f;
}</pre>


<p> O código acima é uma espécie de implementação ingênua que armazena um
<nobr><tt class="type">float</tt></nobr> em um número de 32-bit. O bit alto (31) é usado para
armazenar o sinal do número ( "1" significa negativo), e os próximos sete bits (30-16) são usados ​​para armazenar a porção inteira do número
<nobr><tt class="type">float</tt></nobr>. Finalmente, os bits restantes (15-0) são usados ​​para
armazenar a parte fracionária do número.</p>

<p> O uso é bastante simples:</p>

<pre class="code">#include &lt;stdio.h&gt;

int main(void)
{
    float f = 3.1415926, f2;
    uint32_t netf;

    netf = htonf(f);  // converte para formato de "network"
    f2 = ntohf(netf); // converter de volta para teste

    printf("Original: %f\n", f);        // 3.141593
    printf(" Network: 0x%08X\n", netf); // 0x0003243F
    printf("Desembalado: %f\n", f2);       // 3.141586

    return 0;
}</pre>


<p> No lado positivo, é pequeno, simples e rápido. No lado negativo,
não é uma utilização eficiente do espaço e o intervalo é severamente
restrito—tente armazenar um número maior do que 32767 e será muito infeliz! Você também pode ver no exemplo acima que as
últimas duas casas decimais não são corretamente preservadas.</p>

<p> O que podemos fazer em vez disso? Bem, <i>O</i> padrão para armazenar
números de ponto flutuante é conhecido como <a name="indexId434909-168"></a> <a href="http://en.wikipedia.org/wiki/IEEE_754" target="_blank">IEEE-754</a>. A maioria dos computadores usam este formato
internamente para fazer contas com ponto flutuante, por isso, nesses casos, estritamente
falando, a conversão não precisaria ser feita. Mas se você quiser que o seu
código fonte seja portátil essa é uma suposição que você não pode necessariamente
fazer. (Por outro lado, se você quer que as coisas sejam rápidas, você deve
otimizá-lo em plataformas que não precisam fazê-lo! Isso é o que
<b><tt class="func">htons()</tt></b> e sua turma fazem.)</p>

<p> <a href="http://beej.us/guide/bgnet/examples/ieee754.c" target="_blank">Aqui está um código que codifica 
floats e doubles no formato IEEE 754</a>. (Principalmente—isso
não codifica NaN ou infinito, mas poderia ser modificado para fazer isso.)</p>

<pre class="code">#define pack754_32(f) (pack754((f), 32, 8))
#define pack754_64(f) (pack754((f), 64, 11))
#define unpack754_32(i) (unpack754((i), 32, 8))
#define unpack754_64(i) (unpack754((i), 64, 11))

uint64_t pack754(long double f, unsigned bits, unsigned expbits)
{
    long double fnorm;
    int shift;
    long long sign, exp, significand;
    unsigned significandbits = bits - expbits - 1; // -1 para sign bit

    if (f == 0.0) return 0; // tirar este caso especial do caminho

    // verifique o sinal e inicie a normalização
    if (f &lt; 0) { sign = 1; fnorm = -f; }
    else { sign = 0; fnorm = f; }

    // obtenha a forma normalizada de f e acompanhe o expoente
    shift = 0;
    while(fnorm &gt;= 2.0) { fnorm /= 2.0; shift++; }
    while(fnorm &lt; 1.0) { fnorm *= 2.0; shift--; }
    fnorm = fnorm - 1.0;

    // calcular a forma binária (não-float) dos dados de significand
    significand = fnorm * ((1LL&lt;&lt;significandbits) + 0.5f);

    // obter o expoente parcial
    exp = shift + ((1&lt;&lt;(expbits-1)) - 1); // shift + bias

    // retornar a resposta final
    return (sign&lt;&lt;(bits-1)) | (exp&lt;&lt;(bits-expbits-1)) | significand;
}

long double unpack754(uint64_t i, unsigned bits, unsigned expbits)
{
    long double result;
    long long shift;
    unsigned bias;
    unsigned significandbits = bits - expbits - 1; // -1 para sign bit

    if (i == 0) return 0.0;

    // puxe o significand
    result = (i&amp;((1LL&lt;&lt;significandbits)-1)); // mascarar
    result /= (1LL&lt;&lt;significandbits); // converter de volta para float
    result += 1.0f; // adiciona 1 de volta em

    // lidar com o expoente
    bias = (1&lt;&lt;(expbits-1)) - 1;
    shift = ((i&gt;&gt;significandbits)&amp;((1LL&lt;&lt;expbits)-1)) - bias;
    while(shift &gt; 0) { result *= 2.0; shift--; }
    while(shift &lt; 0) { result /= 2.0; shift++; }

    // converte para sign
    result *= (i&gt;&gt;(bits-1))&amp;1? -1.0: 1.0;

    return result;
}</pre>


<p> Eu coloquei alguns macros úteis lá em cima no topo para embalar e desembalar números
32 bits (provavelmente um <nobr> <tt class="type">float</tt></nobr>) e 64 bits (provavelmente um
<nobr> <tt class="type">double</tt></nobr>), mas a função <b><tt class="func">pack754()</tt></b>
poderia ser chamada diretamente e informada para codificar <i><tt class="var">bits</tt></i> de
dados (<i><tt class="var">expbits</tt></i> dos quais estão reservados para o expoente do número normalizado.)</p>

<p> Aqui está um exemplo de uso:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt; // define tipos uintN_t
#include &lt;inttypes.h&gt; // define macros PRIx

int main(void)
{
    float f = 3.1415926, f2;
    double d = 3.14159265358979323, d2;
    uint32_t fi;
    uint64_t di;

    fi = pack754_32(f);
    f2 = unpack754_32(fi);

    di = pack754_64(d);
    d2 = unpack754_64(di);

    printf("float antes : %.7f\n", f);
    printf("float codificado: 0x%08" PRIx32 "\n", fi);
    printf("float depois  : %.7f\n\n", f2);

    printf("double antes : %.20lf\n", d);
    printf("double codificado: 0x%016" PRIx64 "\n", di);
    printf("double depois  : %.20lf\n", d2);

    return 0;
}</pre>


<p> O código acima produz esta saída:</p>

<pre class="screen">float antes : 3.1415925
float codificado: 0x40490FDA
float depois  : 3.1415925

double antes : 3.14159265358979311600
double codificado: 0x400921FB54442D18
double depois  : 3.14159265358979311600</pre>


<p> Outra questão que você pode ter é: como embalar
<nobr><tt class="type">struct</tt></nobr>s? Infelizmente para você, o compilador é livre para
colocar padding em todos os lugares em uma <nobr><tt class="type">struct</tt></nobr>, e isso significa
que você não pode tornar partátil e enviar a coisa toda pelo fio em um pedaço.
(Você não está ficando cansado de ouvir "não pode fazer isso", "não pode fazer isso"?
Desculpe! Para citar um amigo: "Sempre que algo dá errado, eu sempre culpo a
Microsoft". Esta pode não ser uma culpa da Microsoft, admito, mas a
afirmação do meu amigo é completamente verdadeira.)</p>

<p> Voltando ao assunto: a melhor maneira para enviar uma <nobr> <tt class="type">struct</tt></nobr> através do
fio é embalar cada campo, independentemente, e, em seguida, desempacotá-los para a
<nobr><tt class="type">struct</tt></nobr> quando chegarem ao outro lado.</p>

<p> Isso é muito trabalhoso, é o que você está pensando. Sim. Uma
coisa que você pode fazer é escrever uma função auxiliar para ajudar a embalar os dados para
você. Vai ser divertido! Realmente!</p>

<p> No livro "<a href="http://cm.bell-labs.com/cm/cs/tpop/" target="_blank">The Practice of Programming</a>" de Kernighan e Pike, eles implementam
<b><tt class="func">printf()</tt></b>-como funções chamadas <b><tt class="func">pack()</tt></b> e
<b><tt class="func">unpack()</tt></b> que fazem exatamente isso. Eu teria um link para elas mas,
aparentemente, essas funções não estão online com o resto dos fontes do livro.</p>

<p> (The Practice of Programming é uma excelente leitura. Zeus salva um
gatinho cada vez que eu a recomendo.)</p>

<p> Neste ponto, irei chamar sua atenção para a BSD-licenciada <a href="http://tpl.sourceforge.net/" target="_blank">Typed Parameter Language C API</a> que eu nunca
usei, mas parece completamente respeitável. Programadores Python e Perl
podem verificar as funções <b> <tt class="func">pack()</tt></b> e
<b> <tt class="func">unpack()</tt></b> para realizarem a mesma coisa. E o
Java tem uma interface serializável que pode ser usada de forma semelhante.</p>

<p> Mas se você quiser escrever seu próprio utilitário de empacotamento em C, o truque de K&amp;P é usar listas de argumentos variáveis ​​para criar funções como
<b><tt class="func">printf()</tt></b> para construir os pacotes. <a href="http://beej.us/guide/bgnet/examples/pack2.c" target="_blank">Aqui está a versão que eu criei</a> sozinho com base naquilo que espero ser suficiente para lhe dar uma idéia de como isso pode funcionar.</p>

<p> (Este código faz referência às funções <b><tt class="func">pack754()</tt></b> acima.
As funções <b><tt class="func">packi*()</tt></b> operam de forma similar as da família
<b><tt class="func">htons()</tt></b>, exceto por elas embalarem array de <nobr> <tt class="type">char</tt></nobr> em vez de outro inteiro.)</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;

/*
** packi16() -- armazena um int de 16-bit em um buffer de char (como htons())
*/ 
void packi16(unsigned char *buf, unsigned int i)
{
    *buf++ = i&gt;&gt;8; *buf++ = i;
}

/*
** packi32() -- armazena um int de 32-bit em um buffer de char (como htonl())
*/ 
void packi32(unsigned char *buf, unsigned long int i)
{
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** packi64() -- armazena um int de 64-bit em um buffer de char (como htonl())
*/ 
void packi64(unsigned char *buf, unsigned long long int i)
{
    *buf++ = i&gt;&gt;56; *buf++ = i&gt;&gt;48;
    *buf++ = i&gt;&gt;40; *buf++ = i&gt;&gt;32;
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** unpacki16() -- descompacta de um buffer de char um int de 16-bit (como ntohs())
*/ 
int unpacki16(unsigned char *buf)
{
    unsigned int i2 = ((unsigned int)buf[0]&lt;&lt;8) | buf[1];
    int i;

    // modifica números unsigned para signed
    if (i2 &lt;= 0x7fffu) { i = i2; }
    else { i = -1 - (unsigned int)(0xffffu - i2); }

    return i;
}

/*
** unpacku16() -- descompacta de um buffer de char um int de 16-bit unsigned (como ntohs())
*/ 
unsigned int unpacku16(unsigned char *buf)
{
    return ((unsigned int)buf[0]&lt;&lt;8) | buf[1];
}

/*
** unpacki32() -- descompacta de um buffer de char um int de 32-bit (como ntohl())
*/ 
long int unpacki32(unsigned char *buf)
{
    unsigned long int i2 = ((unsigned long int)buf[0]&lt;&lt;24) |
                           ((unsigned long int)buf[1]&lt;&lt;16) |
                           ((unsigned long int)buf[2]&lt;&lt;8)  |
                           buf[3];
    long int i;

    // modifica números unsigned para signed
    if (i2 &lt;= 0x7fffffffu) { i = i2; }
    else { i = -1 - (long int)(0xffffffffu - i2); }

    return i;
}

/*
** unpacku32() -- descompacta de um buffer de char 32-bit unsigned (como ntohl())
*/ 
unsigned long int unpacku32(unsigned char *buf)
{
    return ((unsigned long int)buf[0]&lt;&lt;24) |
           ((unsigned long int)buf[1]&lt;&lt;16) |
           ((unsigned long int)buf[2]&lt;&lt;8)  |
           buf[3];
}

/*
** unpacki64() -- descompacta de um buffer de char um int de 64-bit (como ntohl())
*/ 
long long int unpacki64(unsigned char *buf)
{
    unsigned long long int i2 = ((unsigned long long int)buf[0]&lt;&lt;56) |
                                ((unsigned long long int)buf[1]&lt;&lt;48) |
                                ((unsigned long long int)buf[2]&lt;&lt;40) |
                                ((unsigned long long int)buf[3]&lt;&lt;32) |
                                ((unsigned long long int)buf[4]&lt;&lt;24) |
                                ((unsigned long long int)buf[5]&lt;&lt;16) |
                                ((unsigned long long int)buf[6]&lt;&lt;8)  |
                                buf[7];
    long long int i;

    // modifica números unsigned para signed
    if (i2 &lt;= 0x7fffffffffffffffu) { i = i2; }
    else { i = -1 -(long long int)(0xffffffffffffffffu - i2); }

    return i;
}

/*
** unpacku64() -- descompacta de um buffer de char um int de 64-bit unsigned (como ntohl())
*/ 
unsigned long long int unpacku64(unsigned char *buf)
{
    return ((unsigned long long int)buf[0]&lt;&lt;56) |
           ((unsigned long long int)buf[1]&lt;&lt;48) |
           ((unsigned long long int)buf[2]&lt;&lt;40) |
           ((unsigned long long int)buf[3]&lt;&lt;32) |
           ((unsigned long long int)buf[4]&lt;&lt;24) |
           ((unsigned long long int)buf[5]&lt;&lt;16) |
           ((unsigned long long int)buf[6]&lt;&lt;8)  |
           buf[7];
}

/*
** pack() -- armazenar dados definidos no formato string no buffer
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C         
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (tamanhos de 16-bit unsigned é automaticamente anexado às strings)
*/ 

unsigned int pack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    signed char c;              // 8-bit
    unsigned char C;

    int h;                      // 16-bit
    unsigned int H;

    long int l;                 // 32-bit
    unsigned long int L;

    long long int q;            // 64-bit
    unsigned long long int Q;

    float f;                    // floats
    double d;
    long double g;
    unsigned long long int fhold;

    char *s;                    // strings
    unsigned int len;

    unsigned int size = 0;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'c': // 8-bit
            size += 1;
            c = (signed char)va_arg(ap, int); // promovido
            *buf++ = c;
            break;

        case 'C': // 8-bit unsigned
            size += 1;
            C = (unsigned char)va_arg(ap, unsigned int); // promovido
            *buf++ = C;
            break;

        case 'h': // 16-bit
            size += 2;
            h = va_arg(ap, int);
            packi16(buf, h);
            buf += 2;
            break;

        case 'H': // 16-bit unsigned
            size += 2;
            H = va_arg(ap, unsigned int);
            packi16(buf, H);
            buf += 2;
            break;

        case 'l': // 32-bit
            size += 4;
            l = va_arg(ap, long int);
            packi32(buf, l);
            buf += 4;
            break;

        case 'L': // 32-bit unsigned
            size += 4;
            L = va_arg(ap, unsigned long int);
            packi32(buf, L);
            buf += 4;
            break;

        case 'q': // 64-bit
            size += 8;
            q = va_arg(ap, long long int);
            packi64(buf, q);
            buf += 8;
            break;

        case 'Q': // 64-bit unsigned
            size += 8;
            Q = va_arg(ap, unsigned long long int);
            packi64(buf, Q);
            buf += 8;
            break;

        case 'f': // float-16
            size += 2;
            f = (float)va_arg(ap, double); // promovido
            fhold = pack754_16(f); // converte para IEEE 754
            packi16(buf, fhold);
            buf += 2;
            break;

        case 'd': // float-32
            size += 4;
            d = va_arg(ap, double);
            fhold = pack754_32(d); // converte para IEEE 754
            packi32(buf, fhold);
            buf += 4;
            break;

        case 'g': // float-64
            size += 8;
            g = va_arg(ap, long double);
            fhold = pack754_64(g); // converte para IEEE 754
            packi64(buf, fhold);
            buf += 8;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = strlen(s);
            size += len + 2;
            packi16(buf, len);
            buf += 2;
            memcpy(buf, s, len);
            buf += len;
            break;
        }
    }

    va_end(ap);

    return size;
}

/*
** unpack() -- descompactar do buffer dados definidos no formato string
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C         
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (string é extraida baseada no seu tamanho armazenado, mas 's' pode ser prefixado com um tamanho máximo)
**
*/
void unpack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    signed char *c;              // 8-bit
    unsigned char *C;

    int *h;                      // 16-bit
    unsigned int *H;

    long int *l;                 // 32-bit
    unsigned long int *L;

    long long int *q;            // 64-bit
    unsigned long long int *Q;

    float *f;                    // floats
    double *d;
    long double *g;
    unsigned long long int fhold;

    char *s;
    unsigned int len, maxstrlen=0, count;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'c': // 8-bit
            c = va_arg(ap, signed char*);
            if (*buf &lt;= 0x7f) { *c = *buf;} // re-sign
            else { *c = -1 - (unsigned char)(0xffu - *buf); }
            buf++;
            break;

        case 'C': // 8-bit unsigned
            C = va_arg(ap, unsigned char*);
            *C = *buf++;
            break;

        case 'h': // 16-bit
            h = va_arg(ap, int*);
            *h = unpacki16(buf);
            buf += 2;
            break;

        case 'H': // 16-bit unsigned
            H = va_arg(ap, unsigned int*);
            *H = unpacku16(buf);
            buf += 2;
            break;

        case 'l': // 32-bit
            l = va_arg(ap, long int*);
            *l = unpacki32(buf);
            buf += 4;
            break;

        case 'L': // 32-bit unsigned
            L = va_arg(ap, unsigned long int*);
            *L = unpacku32(buf);
            buf += 4;
            break;

        case 'q': // 64-bit
            q = va_arg(ap, long long int*);
            *q = unpacki64(buf);
            buf += 8;
            break;

        case 'Q': // 64-bit unsigned
            Q = va_arg(ap, unsigned long long int*);
            *Q = unpacku64(buf);
            buf += 8;
            break;

        case 'f': // float
            f = va_arg(ap, float*);
            fhold = unpacku16(buf);
            *f = unpack754_16(fhold);
            buf += 2;
            break;

        case 'd': // float-32
            d = va_arg(ap, double*);
            fhold = unpacku32(buf);
            *d = unpack754_32(fhold);
            buf += 4;
            break;

        case 'g': // float-64
            g = va_arg(ap, long double*);
            fhold = unpacku64(buf);
            *g = unpack754_64(fhold);
            buf += 8;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = unpacku16(buf);
            buf += 2;
            if (maxstrlen &gt; 0 &amp;&amp; len &gt; maxstrlen) count = maxstrlen - 1;
            else count = len;
            memcpy(s, buf, count);
            s[count] = '\0';
            buf += len;
            break;

        default:
            if (isdigit(*format)) { // segue max str len
                maxstrlen = maxstrlen * 10 + (*format-'0');
            }
        }

        if (!isdigit(*format)) maxstrlen = 0;
    }

    va_end(ap);
}</pre>


<p> E <a href="http://beej.us/guide/bgnet/examples/pack2.c" target="_blank">aqui está um programa de demonstração</a> do código acima que embala alguns dados em
<i><tt class="var">buf</tt></i> e, em seguida, os descompacta em variáveis. Note que quando
chamamos <b><tt class="func">unpack()</tt></b> com um argumento em string (especificador de formato
"<tt class="const">s</tt>"), é aconselhável colocar uma contagem de comprimento máximo na frente
para evitar uma saturação de buffer, por exemplo, "<tt class="const">96s</tt>". Seja cauteloso ao descompactar
dados recebidos pela rede—um usuário malicioso
pode enviar pacotes mal construídas em um esforço para atacar seu sistema!</p>

<pre class="code">#include &lt;stdio.h&gt;

// vários bits para tipos de ponto flutuante--
// varia para diferentes arquiteturas
typedef float float32_t;
typedef double float64_t;

int main(void)
{
    unsigned char buf[1024];
    int8_t magic;
    int16_t monkeycount;
    int32_t altitude;
    float32_t absurdityfactor;
    char *s = "Grande Zmit unmitigated! Você encontrou o Runestaff!";
    char s2[96];
    int16_t packetsize, ps2;

    packetsize = pack(buf, "chhlsf", (int8_t)'B', (int16_t)0, (int16_t)37, 
            (int32_t)-5, s, (float32_t)-3490.6677);
    packi16(buf+1, packetsize); // armazenar tamanho do pacote no pacote para chutes

    printf("pacote é %" PRId32 " bytes\n", packetsize);

    unpack(buf, "chhl96sf", &amp;magic, &amp;ps2, &amp;monkeycount, &amp;altitude, s2,
        &amp;absurdityfactor);

    printf("'%c' %" PRId32" %" PRId16 " %" PRId32
            " \"%s\" %f\n", magic, ps2, monkeycount,
            altitude, s2, absurdityfactor);

    return 0;
}</pre>


<p> Se você trabalha com seu próprio código ou usa o de outra pessoa, é uma boa
idéia ter um conjunto geral de rotinas de embalagem de dados para manter os bugs sob controle, ao invés de embalar cada bit manualmente a cada vez.</p>

<p> Ao embalar os dados, qual é o melhor formato a ser usado? Excelente
questão. Felizmente, <a name="indexId434909-169"></a> <a href="http://tools.ietf.org/html/rfc4506" target="_blank">no RFC 4506</a>, o Padrão de Representação de Dados
Externos, já define formatos binários para diferentes tipos, como tipos float, tipos int, arrays, raw data, etc.
Eu sugiro que se conforme com isso, se você estiver trabalhando com os dados sozinho. Mas você não é obrigado a isso. A Polícia de Pacotes não estará mesmo à sua porta. 
Pelo menos, eu não <i>acredito</i> que estará.</p>

<p> Em qualquer caso, codificar os dados de uma forma ou de outra antes de enviá-los
é a maneira certa de fazer as coisas!</p>




<h3 class="sect2title">7.5. <a name="sonofdataencap">Bases do encapsulamento de dados</a></h3>


<p> O que realmente significa encapsular dados, de qualquer maneira? No
caso mais simples, significa que você colocará um cabeçalho lá com algumas
informações de identificação ou o comprimento do pacote, ou ambos.</p>

<p> Como deve ser seu cabeçalho? Bem, são apenas alguns dados binários que representam o que você acha necessário para concluir seu projeto.</p>

<p> Uau. Isso é vago.</p>

<p> Ok. Por exemplo, digamos que você tenha um programa de chat multi-usuário
que use <tt class="const">SOCK_STREAM</tt>. Quando um usuário digita ("diz")
algo, dois pedaços de informação precisam ser transmitidos ao servidor: o que foi dito e quem disse.</p>

<p> Até aí tudo bem? "Qual é o problema?" você está perguntando.</p>

<p> O problema é que as mensagens podem ter comprimentos variados. Uma
pessoa chamada "tom" pode dizer: "Olá", e outra pessoa chamada "Benjamin" pode dizer: "Ei, pessoal, o que aconteceu?"</p>

<p> Então você envia com <b><tt class="func">send()</tt></b> todas essas coisas para os clientes quando chegarem a você. Seu fluxo de dados de saída se parece com isso:</p>

<pre class="screen">t o m O l á B e n j a m i n E i , p e s s o a l , o q u e a c o n t e c e u ?</pre>

<p> E assim por diante. Como o cliente sabe quando uma mensagem termina e
outra começa? Você poderia, se quisesse, fazer com que todas as mensagens tivessem o mesmo
comprimento e apenas chamar <a name="indexId434909-170"></a> <b> <tt class="func">sendall()</tt></b> que
implementamos, <a href="#sendall">acima</a>. Mas isso desperdiça largura de banda! Nós não queremos executar <b> <tt class="func">send()</tt></b> com 1024 bytes apenas para que
"Tom" possa dizer "Olá".</p>

<p> Por isso, <i>encapsulamos</i> os dados em uma pequena estrutura de cabeçalho e corpo. Tanto o cliente quanto o servidor sabem como compactar e
descompactar (por vezes referido como "marshal" e "unmarshal") esses dados.
Não olhe agora, mas estamos começando a definir um <i>protocolo</i> que descreve como um cliente e servidor comunicam-se!</p>

<p> Neste caso, vamos supor que o nome de usuário tenha um comprimento fixo de 8
caracteres, terminados com <tt class="const">'\0'</tt>. E então vamos supor que os dados tenham comprimento variável, até um máximo de 128
caracteres. Vamos dar uma olhada em uma estrutura de pacote num exemplo que poderíamos
usar nesta situação:</p>

<ol>


<li><tt class="tt">len</tt> (1 byte, sem sinal)—O comprimento total do
pacote, contendo 8 bytes do user name e chat data.</li>


<li><tt class="tt">name</tt> (8 bytes)—O nome do usuário, NUL-preenchido se
necessário.</li>


<li><tt class="tt">chatdata</tt>
(<i>n</i>-bytes)—Os dados em si, não mais do que 128 bytes.
O comprimento do pacote deve ser calculado como o comprimento dos dados
mais 8 (o comprimento do campo do nome, acima).</li>


</ol>


<p> Por que escolhi os limites de 8 bytes e 128 bytes para os campos? Eu os puxei
para fora pelo fio, assumindo que seriam longos o suficiente. Talvez,
porém, 8 bytes sejam muito restritivos para as suas necessidades, e você pode ter um campo
de nome com 30 bytes, ou quantos queira que sejam. A escolha é sua.</p>

<p> Usando a definição de pacotes acima, o primeiro pacote consistiria
nas seguintes informações (em hexadecimal e ASCII):</p>

<pre class="screen">  0A     74 6F 6D 00 00 00 00 00      48 69
(length)  T  o  m    (padding)         H  i
</pre>


<p> E o segundo é semelhante:</p>

<pre class="screen">  18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
(length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...
</pre>


<p> (O comprimento é armazenado em Network Byte Order, é claro. Neste
caso, é apenas um byte, por isso não importa, mas em geral
você desejará que todos os seus inteiros binários sejam armazenados em Network Byte Order
em seus pacotes.)</p>

<p> Quando você está enviando esses dados, você deve estar seguro e usar um
comando semelhante a <a href="#sendall"><b><tt class="func">sendall()</tt></b></a>, acima, para que você
saiba que todos os dados são enviados, mesmo que sejam necessárias várias chamadas a
<b> <tt class="func">send()</tt></b> para colocar tudo para fora.</p>

<p> Da mesma forma, quando você está recebendo esses dados, precisa fazer um pouco mais de trabalho. Para estar seguro, você deve assumir que pode receber um  pacote parcial
(como talvez recebamos "<tt class="tt">18 42 65
6E 6A</tt>" de Benjamin, acima, mas isso é tudo o que recebemos nesta
chamada a <b> <tt class="func">recv()</tt></b>). Precisamos chamar
<b> <tt class="func">recv()</tt></b> repetidamente até que o pacote seja
completamente recebido.</p>

<p> Mas como? Bem, nós sabemos o número de bytes que precisamos receber no total para que o pacote esteja completo, uma vez que o número é inserido na
frente do pacote. Sabemos também que o tamanho máximo do pacote é 1+8+128,
ou 137 bytes (porque é assim que definimos o pacote.)</p>

<p> Na verdade, existem algumas coisas que você pode fazer aqui. Como você sabe que
cada pacote começa com um comprimento, você pode chamar <b> <tt class="func">recv()</tt></b>
apenas para obter o tamanho do pacote. Então uma vez que você tenha isso, você pode chamá-la
novamente especificando exatamente o comprimento restante do pacote (possivelmente
repetidamente para obter todos os dados) até que você tenha o pacote completo.
A vantagem deste método é que você só precisa de um buffer grande
suficiente para um pacote, enquanto a desvantagem é que você precisa chamar
<b> <tt class="func">recv()</tt></b> pelo menos duas vezes para obter todos os dados.</p>

<p> Outra opção é apenas chamar <b><tt class="func">recv()</tt></b> e dizer que o valor que você está
disposto a receber é o número máximo de bytes em um pacote.
Então, o que quer que você receba, coloque-o na parte de trás de um buffer, e, finalmente,
verifique se o pacote está completo. Claro, você pode pegar um pouco
do próximo pacote, então você precisa ter espaço para isso.</p>

<p> O que você pode fazer é declarar uma matriz grande o suficiente para dois pacotes.
Este é o seu array de trabalho onde você irá reconstruir os pacotes conforme eles chegam.</p>

<p> Cada vez que você receber dados com <b> <tt class="func">recv()</tt></b>, você os anexará
ao buffer de trabalho e verificará se o pacote está completo. Ou seja, o número de bytes no buffer é maior ou igual ao
comprimento especificado no cabeçalho (+1, porque o comprimento no cabeçalho
não inclui o byte para o próprio comprimento). Se o número de bytes
no buffer for menor que 1, o pacote não está completo, obviamente.
Você tem que fazer um case especial para isso, porém, desde que o primeiro byte
é lixo e você não pode contar com ele para o comprimento correto do pacote.</p>

<p> Quando o pacote estiver completo, você poderá fazer com ele o que quiser. Use-o e remova-o do seu buffer de trabalho.</p>

<p> Ufa! Você ainda está fazendo malabarismos com isso na sua cabeça? Bem, aqui está mais 
complexidade: você pode ter lido e passado do fim de um
pacote e lido parte do próximo em uma única chamada <b> <tt class="func">recv()</tt></b>.
Ou seja, você tem um buffer de trabalho com um pacote completo e uma
parte incompleta do próximo pacote! Maldito. (Mas foi por isso que você
fez o seu buffer de trabalho suficientemente grande para conter <i>dois</i>
pacotes—caso isso acontecesse!)</p>

<p> Uma vez que você saiba o tamanho do primeiro pacote do cabeçalho, e
você está mantendo o controle do número de bytes no buffer de trabalho, você
pode subtrair e calcular quantos dos bytes no buffer de trabalho
pertencem ao segundo pacote (incompleto). Quando você já lidou com o primeiro, você pode removê-lo do buffer de trabalho e mover o segundo pacote parcial
para frente no buffer para que ele esteja pronto para o próximo <b> <tt class="func">recv()</tt></b>.</p>

<p> (Alguns de vocês leitores notarão que mover o segundo pacote parcial
para o início do buffer de trabalho leva tempo, e o
programa pode ser codificado para não exigir isso usando um buffer circular.
Infelizmente para o resto de vocês, uma discussão sobre buffers circulares está
além do escopo deste artigo. Se você ainda está curioso, pegue um livro sobre estruturas de dados e siga a partir daí.)</p>

<p> Eu nunca disse que era fácil. Ok, eu disse que era fácil. E isso é:
você só precisa praticar e muito em breve se tornará natural. Juro por
<a name="indexId434909-171"></a>Excalibur!</p>



<h3 class="sect2title">7.6. <a name="broadcast">Pacotes Broadcast—Olá, mundo!</a></h3>


<p> Até agora, este guia falou sobre o envio de dados de um host para um
outro host. Mas é possível, insisto, que você possa, com a devida autoridade, enviar dados para vários hosts <i>ao mesmo tempo</i>!</p>

<p> Com <a name="indexId434909-172"></a> UDP (somente UDP, não TCP) e IPv4 padrão, isso
é feito através de um mecanismo chamado <a name="indexId434909-173"></a> <i>broadcasting</i>. Com o IPv6, broadcasting não é
suportado e você precisa recorrer à técnica frequentemente superior de
<i>multicasting</i>, que, infelizmente, eu não estarei discutindo neste
momento. Mas o suficiente para espiarmos o futuro—estamos presos no presente
de 32 bits.</p>

<p> Mas espere! Você não pode simplesmente sair daqui e começar seu broadcasting de forma precipitada;
Você precisa <a name="indexId434909-174"></a> definir a opção de socket <a name="indexId434909-175"></a> <tt class="const">SO_BROADCAST</tt> antes de pode enviar um
pacote broadcast para a rede. É como uma daqueles pequenas
tampas de plástico que eles colocaram sobre o interruptor de lançamento do míssil! Isso é o quanto
de poder você tem suas mãos!</p>

<p> Mas, falando sério, existe o perigo de usar pacotes broadcast,
ou seja: todo sistema que recebe um pacote broadcast deve desfazer todas
as camadas de encapsulamento de dados até que descobra-se a que porta os dados são destinados. E então entrega os dados ou os descarta.
Em ambos os casos, é muito trabalhoso para cada máquina que recebe
o pacote broadcast, e como trafegam todos na rede local pode haver muitas máquinas fazendo trabalho desnecessário. Quando
o jogo Doom apareceu pela primeira vez, isso era uma reclamação sobre seu código de rede.</p>

<p> Agora, há mais de uma maneira de esfolar um gato ... espere um minuto. Existe
realmente mais do que uma maneira de esfolar um gato? Que tipo de expressão
é essa? E, da mesma forma, há mais de uma maneira de enviar um
pacote broadcast. Então, para chegar à carne e às batatas da coisa
toda: como você especifica o endereço de destino para uma mensagem de
broadcast? Existem duas formas comuns:</p>

<ol>

<li> Envie os dados para o endereço de broadcast de uma sub-rede específica. Esse é o
número de rede da sub-rede com todas os bits um definidos para a parte de host
do endereço. Por exemplo, em casa minha rede é 192.168.1.0, a minha
máscara de rede é 255.255.255.0, então o último byte do endereço é meu número de host
(porque os três primeiros bytes, de acordo com a máscara de rede, são o
número da rede). Então, meu endereço de broadcast é 192.168.1.255. No Unix,
o comando <b class="com">ifconfig</b> irá fornecer todos esses dados.
(Se você está curioso, a lógica bitwise para obter o seu endereço de broadcast é
<i><tt class="var">network_number</tt></i> OR (NOT <i><tt class="var">netmask</tt></i>).) Você pode enviar
este tipo de pacote broadcast para redes remotas, bem como para a sua rede local,
mas você corre o risco de o pacote ser descartado pelo
roteador de destino. (Se eles não o descartassem, algum smurf aleatório
poderia começar a inundar a sua LAN com tráfego de broadcast.)</li>

<br/>
<li> Envie os dados para o endereço de broadcast "global". Isso é <a name="indexId434909-176"></a>255.255.255.255, também conhecido como
<a name="indexId434909-177"></a> <tt class="const">INADDR_BROADCAST</tt>. Muitas
máquinas realizam operações bitwise AND com o seu número de rede para
o converter em um endereço de broadcast, mas algumas não. Varia.
Roteadores não encaminham este tipo de pacote broadcast para fora da sua rede local, ironicamente.</li>


</ol>


<p> Então, o que acontece se você tentar enviar dados para o endereço de broadcast
sem antes definir a opção <tt class="const">SO_BROADCAST</tt> no socket?
Bem, vamos até o bom e velho <a href="#datagram"><b class="com">talker</b> e
<b class="com">listener</b></a> ver o que acontece.</p>

<pre class="screen">$ talker 192.168.1.2 foo
enviados 3 bytes para 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</pre>


<p> Sim, nem tudo funcionou... porque não definimos a opção
<tt class="const">SO_BROADCAST</tt> para o socket. Faça isso, e então você poderá
executar <b> <tt class="func">sendto()</tt></b> em qualquer lugar!</p>

<p> Na verdade, essa é a única <i>diferença</i> entre um aplicativo UDP
que pode transmitir e outro que não pode. Então, vamos pegar o
antigo programa <b class="com">talker</b> e adicionar uma seção que defina a opção
<tt class="const">SO_BROADCAST</tt> para o socket. Vamos chamar este programa
<a target="_blank" href="http://beej.us/guide/bgnet/examples/broadcaster.c">
<i><tt class="var">broadcaster.c</tt></i></a>:</p>


<pre class="code">/*
** broadcaster.c -- um "cliente" datagram como talker.c, exceto
**                  por esse enviar pacotes broadcast
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // a porta onde se conectar

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // informações de endereço de quem conecta
    struct hostent *he;
    int numbytes;
    int broadcast = 1;
    //char broadcast = '1'; // se isso não funcionar, tente isso

    if (argc != 3) {
        fprintf(stderr,"use: broadcaster hostname mensagem\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // obter as informações do host
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    // esta chamada é o que permite que os pacotes de broadcast sejam enviados:
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,
        sizeof broadcast) == -1) {
        perror("setsockopt (SO_BROADCAST)");
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(SERVERPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(their_addr.sin_zero, '\0', sizeof their_addr.sin_zero);

    if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof their_addr)) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("enviados %d bytes para %s\n", numbytes,
        inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</pre>



<p> O que há de diferente entre esta e uma situação de cliente/servidor UDP "normal"? Nada! (Com a exceção do cliente ter permissão
para enviar pacotes broadcast nesse caso.) Dessa forma, vá em frente e execute o velho
programa UDP <a href="#datagram"><b class="com">listener</b></a> em uma
janela e o <b class="com">broadcaster</b> em outra. Você deve agora ser
capaz de fazer todos aqueles envios que falharam acima.</p>


<pre class="screen">$ broadcaster 192.168.1.2 foo
enviados 3 bytes para 192.168.1.2
$ broadcaster 192.168.1.255 foo
enviados 3 bytes para 192.168.1.255
$ broadcaster 255.255.255.255 foo
enviados 3 bytes para 255.255.255.255
</pre>

<p> E você deve ver <b class="com">listener</b> respondendo que recebeu os
pacotes. (Se <b class="com">listener</b> não responder, pode ser porque
ele está vinculado a um endereço IPv6. Tente alterar
<tt class="const">AF_UNSPEC</tt> em <i><tt class="var">listener.c</tt></i> para
<tt class="const">AF_INET</tt> para forçar IPv4).</p>

<p> Bem, isso é excitante. Mas agora ative o <b class="com">listener</b> em
outra máquina próxima a você na mesma rede para que você tenha duas
cópias, uma em cada máquina, e execute <b class="com">broadcaster</b> novamente
com o seu endereço de broadcast... Ei! Ambos <b class="com">listener</b> recebem o
pacote embora você só tenha feito uma chamada a <b> <tt class="func">sendto()</tt></b>!
Legal!</p>

<p> Se <b class="com">listener</b> receber os dados enviados diretamente a ele, mas não
os dados enviados ao endereço de broadcast, pode ser que você tenha um <a name="indexId434909-178"></a> firewall em sua máquina local que esteja bloqueando os
pacotes. (Sim, <a name="indexId434909-179"></a> Pat e <a name="indexId434909-180"></a> Bapper, obrigado
por perceber antes de mim, era por isso que o meu código de exemplo não estava
funcionando. Eu lhe disse que o mencionaria no guia, e você está aqui. Então <i>obrigado</i>.)</p>


<p> Mais uma vez, tenha cuidado com pacotes broadcast. Uma vez que cada máquina na
LAN será forçada a lidar com o pacote quer ela receba com
<b><tt class="func">recvfrom()</tt></b> ou não, ele pode apresentar uma grande carga para o
toda a rede de computação. Definitivamente eles devem ser usados com moderação e
de forma adequada.</p>


<hr class="mainsectbreak"/> <h2 class="sect1title">8. <a name="faq">Dúvidas Frequentes</a></h2> <hr class="mainsecthr"/>


<dt> <b> Onde posso obter os arquivos de cabeçalho?</b></dt>


<dd> <p> <a name="indexId434909-181"></a> Se você não os tiver em seu sistema, provavelmente não precisará deles. Verifique o manual da sua
plataforma específica. Se você está construindo para <a name="indexId434909-182"></a> do Windows,
você só precisa de <tt class="tt">#include &lt;winsock.h&gt;.</tt></p></dd>


<dt> <b> O que eu faço quando <b> <tt class="func">bind()</tt></b> relata
<a name="indexId434909-183"></a> "Endereço já em uso"?</b></dt>


<dd> <p> Você tem que usar <a name="indexId434909-184"></a> <b> <tt class="func">setsockopt()</tt></b>
com a opção <a name="indexId434909-185"></a> <tt class="const">SO_REUSEADDR</tt>
no socket de escuta. Confira a <a href="#bind">seção</a> de <a name="indexId434909-186"></a> <b> <tt class="func">bind()</tt></b> e a <a href="#select">seção</a> de <a name="indexId434909-187"></a> <b> <tt class="func">select()</tt></b> para exemplos.</p></dd>



<dt> <b> Como faço para obter uma lista de sockets abertos no
sistema?</b></dt>


<dd><p> Use o <a name="indexId434909-188"></a><b class="com">netstat</b>. Verifique o
<b class="com">man</b> para mais detalhes, mas você deve obter uma boa
saída apenas digitando:</p>

<pre class="screen">$ netstat</pre>


<p> O único truque é determinar qual socket está associado a
qual programa. <tt>:-)</tt></p></dd>


<dt> <b> Como posso visualizar a tabela de roteamento?</b></dt>


<dd> <p> Execute o comando <a name="indexId434909-189"></a> <b class="com">route</b> (em
<i><tt class="var">/sbin</tt></i> na maioria dos Linuxes) ou o comando
<a name="indexId434909-190"></a> <b class="com">netstat -r</b>.</p></dd>


<dt> <b> Como posso executar os programas cliente e servidor se eu tiver apenas
um computador? Não preciso de uma rede para escrever programas de rede?</b></dt>


<dd> <p> Felizmente para você, praticamente todas as máquinas implementam um <a name="indexId434909-191"></a> "dispositivo" de rede de loopback que fica no kernel
e finge ser uma placa de rede. (Esta é a interface listada como
"<tt class="tt">lo</tt>" na tabela de roteamento.)</p>

<p> Finja que você está conectado a uma máquina chamada
<a name="indexId434909-192"></a> "<tt class="tt">cabra</tt>". Execute o cliente em uma janela
e o servidor em outra. Ou inicie o servidor em segundo plano
("<b class="com">server &amp;</b>") e execute o cliente na mesma
janela. A conclusão do dispositivo de loopback é que você pode executar
<b class="com">cliente cabra</b> ou <a name="indexId434909-193"></a> <b class="com">cliente localhost</b>
(Uma vez que "<tt class="tt">localhost</tt>" está provavelmente definido no
seu arquivo <i><tt class="var">/etc/hosts</tt></i>) e você terá o cliente
conversando com o servidor sem uma rede!</p>

<p> Em suma, nenhuma alteração é necessária para qualquer código para o fazê-lo
funcionar em uma única máquina que não esteja em rede! Uhull!</p></dd>


<dt> <b> Como posso saber se o lado remoto fechou
a conexão?</b></dt>


<dd> <p> Você pode saber verificando se <b> <tt class="func">recv()</tt></b>
retornou <tt class="const">0</tt>.</p></dd>



<dt> <b> Como faço para implementar um utilitário <a name="indexId434909-194"></a> "ping"? O que é <a name="indexId434909-195"></a> ICMP? Onde posso encontrar mais informações sobre <a name="indexId434909-196"></a> raw sockets e <tt class="const">SOCK_RAW</tt>?</b></dt>


<dd> <p> Todas as suas questões sobre raw sockets serão respondidas nos <a href="#books">W. Richard Stevens' UNIX Network Programming books</a>.
Além disso, procure no subdiretório <i><tt class="var">ping/</tt></i> no Stevens' UNIX Network Programming source code, <a href="http://www.unpbook.com/src.html" target="_blank">disponível
</a>online.</p></dd>


<dt> <b> Como posso alterar ou encurtar o tempo de espera em uma chamada à
<b><tt class="func">connect()</tt></b>?</b></dt>


<dd> <p> Em vez de dar-lhe exatamente a mesma resposta que W. Richard
Stevens lhe daria, eu apenas indicarei <a href="http://www.unpbook.com/src.html" target="_blank"><i><tt class="var">lib/connect_nonb.c</tt></i> no 
UNIX Network Programming source code.</a>.</p>

<p> A essência disso é que você cria um descritor de socket com
<b><tt class="func">socket()</tt></b>, <a href="#blocking">o configura para
non-blocking</a>, chama <b><tt class="func">connect()</tt></b>, e se tudo correr bem
<b><tt class="func">connect()</tt></b> retornará <tt class="const">-1</tt> imediatamente e
<i><tt class="var">errno</tt></i> será definido para <tt class="const">EINPROGRESS</tt>. Em seguida você
chama <a href="#select"><b><tt class="func">select()</tt></b></a> com o timeout que
desejar, passando o descritor do socket nos sets de leitura e
gravação. Se não expirar, significa que a chamada a <b> <tt class="func">connect()</tt></b>
foi concluída. Neste ponto, você terá que usar
<b> <tt class="func">getsockopt()</tt></b> com a opção <tt class="const">SO_ERROR</tt> para obter
o valor de retorno a partir da chamada <b> <tt class="func">connect()</tt></b>, que deve ser
zero se não houver erro.</p>

<p> Finalmente, você provavelmente vai querer definir o socket de volta para blocking
antes de iniciar a transferência de dados sobre ele.</p>

<p> Observe que isso tem a vantagem adicional de permitir que seu programa faça
outra coisa enquanto está se conectando, também. Você poderia, por exemplo, definir
o tempo limite para algo baixo, como 500 ms, e atualizar um indicador
na tela a cada timeout, em seguida, chamar <b> <tt class="func">select()</tt></b> novamente. Quando
você tiver chamado <b><tt class="func">select()</tt></b> e excedido, digamos, 20 vezes, você saberá
que é hora de desistir da conexão.</p>

<p> Como eu disse, confira a fonte de Stevens para um exemplo perfeitamente excelente.</p>



<dt> <b> Como posso construir para Windows?</b></dt>


<dd> <p> Primeiro, apague o Windows e instale um Linux ou um BSD.
<tt>};-)</tt>. Não, na verdade, apenas consulte a <a href="#windows">seção construindo
no Windows</a> na introdução.</p></dd>





<dt> <b> Como faço para construir para Solaris/SunOS? Eu continuo recebendo erros de linker 
quando tento compilar!</b></dt>

<dd> <p> Os erros de linker acontecem porque ambientes Sun não
compilam automaticamente com bibliotecas de socket. Consulte a seção <a href="#solaris">construção para Solaris/SunOS</a> na
introdução para um exemplo de como fazer isso.</p></dd>







<dt> <b> Por que <b> <tt class="func">select()</tt></b> segue caindo
em um sinal?</b></dt>

<dd> <p> Os sinais tendem a fazer com que as chamadas do sistema bloqueadas retornem
<tt class="const">-1</tt> com <i><tt class="var">errno</tt></i> definido como <tt class="const">EINTR</tt>.
Quando você configura um manipulador de sinal com <a name="indexId434909-197"></a> <b> <tt class="func">sigaction()</tt></b>, você pode definir o sinalizador <a name="indexId434909-198"></a> <tt class="const">SA_RESTART</tt>, que deve
reiniciar a chamada de sistema depois que ela for interrompida.</p>

<p> Naturalmente, isso nem sempre funciona.</p>

<p> A minha solução favorita para isso envolve uma estrutura
<a name="indexId434909-199"></a> <tt class="tt">goto</tt>. Você sabe que isso
irrita seus professores infinitamente, então vá em frente!</p>

<pre class="code">select_restart:
if ((err = select(fdmax+1, &amp;readfds, NULL, NULL, NULL)) == -1) {
    if (errno == EINTR) {
        // algum sinal acabou de nos interromper, então reinicie
        goto select_restart;
    }
    // lide com o erro real aqui:
    perror("select");
} 
</pre>

<p> Claro, você não <i>necessita</i> usar <tt class="tt">goto</tt>, neste caso; Você pode usar outras
estruturas para controle. Mas acho que <tt class="tt">goto</tt> é realmente mais limpa.</p></dd>


<dt> <b> Como posso implementar um <a name="indexId434909-200"></a> timeout em uma chamada a
<b> <tt class="func">recv()</tt></b>?</b></dt>


<dd> <p> <a name="indexId434909-201"></a> Use <a href="#select"><b> <tt class="func">select()</tt></b></a>! Ela permite que você especifique um
parâmetro de tempo limite para os descritores de socket que você deseja ler. Ou, você poderia envolver toda a funcionalidade em uma única função,
assim:</p>

<pre class="code">#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int recvtimeout(int s, char *buf, int len, int timeout)
{
    fd_set fds;
    int n;
    struct timeval tv;

    // configura o set de descritores de arquivos
    FD_ZERO(&amp;fds);
    FD_SET(s, &amp;fds);

    // configura a struct timeval para timeout
    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    // aguarde até timeout ou receber os dados
    n = select(s+1, &amp;fds, NULL, NULL, &amp;tv);
    if (n == 0) return -2; // timeout!
    if (n == -1) return -1; // error

    // os dados devem estar aqui, então faça um recv() normal
    return recv(s, buf, len, 0);
}
.
.
.
// Chamada de amostra para recvtimeout():
n = recvtimeout(s, buf, sizeof buf, 10); // 10 second timeout

if (n == -1) {
    // ocorreu um erro
    perror("recvtimeout");
}
else if (n == -2) {
    // ocorreu timeout
} else {
    // tenho alguns dados em buf
}
.
.
. 
</pre>


<p> Observe que <a name="indexId434909-202"></a> <b> <tt class="func">recvtimeout()</tt></b>
retorna <tt class="const">-2</tt> no caso de um timeout. Por que não retorna
<tt class="const">0</tt>? Bem, se você se lembra, um valor de retorno
<tt class="const">0</tt> em uma chamada a <b> <tt class="func">recv()</tt></b> significa que o lado remoto
fechou a conexão. Então esse valor de retorno já é usado, e <tt class="const">-1</tt> significa "erro", então eu escolhi <tt class="const">-2</tt> como o meu
indicador de timeout.</p>

</dd>


<dt> <b> Como posso <a name="indexId434909-203"></a> criptografar ou comprimir os dados antes de
enviá-los através do socket?</b></dt>


<dd>

<p> Uma maneira fácil de fazer criptografia é usar <a name="indexId434909-204"></a> SSL (Secure
sockets layer), mas isso está além do escopo deste guia. (<a name="indexId434909-205"></a> Confira o <a href="http://www.openssl.org/" target="_blank">projeto OpenSSL</a> para mais informações.)</p>

<p> Mas supondo que você deseja conectar ou implementar seu próprio <a name="indexId434909-206"></a> compressor
ou sistema de criptografia, é apenas uma questão de pensar em seus dados como
uma sequência de etapas entre as duas extremidades. Cada etapa altera os dados de alguma forma.</p>

<ol>

<li> servidor lê dados do arquivo (ou de qualquer lugar)</li>

<li> servidor criptografa/comprime os dados (você adiciona esta parte)</li>

<li> servidor envia os dados criptografados com <b> <tt class="func">send()</tt></b></li>

</ol>


<p> Agora o contrário:</p>

<ol>

<li> cliente recebe os dados criptografados com <b><tt class="func">recv()</tt></b></li>

<li> cliente decifra/descomprime os dados (você adiciona esta parte)</li>

<li> cliente grava os dados em arquivo (ou em qualquer lugar)</li>

</ol>

<p>Se você for compactar e criptografar, lembre-se de compactar primeiro.<tt>:-)</tt></p>

<p> Contando que o cliente desfaça corretamente o que o servidor faz,
os dados ficarão bem no final, independentemente de quantos passos intermediários
você adicione.</p>

<p> Então, tudo que você precisa fazer para usar meu código é encontrar o local entre
onde os dados são lidos e onde são enviados (usando
<b> <tt class="func">send()</tt></b>) através da rede, e colocar lá algum código que faça a criptografia.</p>

</dd>



<dt> <b> <a name="indexId434909-207"></a> <a name="indexId434909-208"></a> O que é esse
"<tt class="const">PF_INET</tt>" que continuo vendo? Está relacionado com
<tt class="const">AF_INET</tt>?</b></dt>


<dd>
<p> Sim, sim é isso. Consulte a <a href="#socket">seção sobre
<b> <tt class="func">socket()</tt></b></a> para mais detalhes.</p>
</dd>



<dt> <b> Como eu posso escrever um servidor que aceita comandos shell
de um cliente e os executa?</b></dt>


<dd>

<p> Para simplificar, vamos dizer que o cliente execute <b><tt class="func">connect()</tt></b>, <b><tt class="func">send()</tt></b>, e
<b><tt class="func">close()</tt></b> na conexão (ou seja, não haverá
chamadas de sistema subseqüentes sem que o cliente se conecte novamente.)</p>

<p> O processo que o cliente segue é o seguinte:</p>

<ol>

<li> <b> <tt class="func">connect()</tt></b> conecta ao servidor</li>

<li> <b> <tt class="func">send("/sbin/ls &gt; /tmp/client.out")</tt></b></li>

<li> <b> <tt class="func">close()</tt></b> termina a conexão</li>

</ol>


<p> Enquanto isso, o servidor está manipulando os dados e os executando:</p>

<ol>

<li> <b> <tt class="func">accept()</tt></b> aceita a conexão do cliente</li>

<li> <b> <tt class="func">recv(str)</tt></b> recebe a string de comandos</li>

<li> <b> <tt class="func">close()</tt></b> termina a conexão</li>

<li> <b> <tt class="func">system(str)</tt></b> para executar o comando</li>

</ol>


<p> <a name="indexId434909-209"></a> <i>Atenção!</i> Ter o servidor executando
o que o cliente diz é como dar acesso a um shell remoto e as pessoas podem
fazer coisas na sua conta quando se conectam ao servidor. Por
exemplo, no exemplo acima, e se o cliente envia "<b class="com">rm -rf ~</b>"? Ele excluiria tudo na sua conta, isso é um absurdo!</p>

<p> Então seja prudente, e evite que o cliente use qualquer comando com exceção
de um par de utilitários que você sabe que são seguros, como o utilitário <b class="com">foobar</b>:</p>

<pre class="code">if (!strncmp(str, "foobar", 6)) {
    sprintf(sysstr, "%s &gt; /tmp/server.out", str);
    system(sysstr);
} 
</pre>


<p> Mas você ainda está inseguro, infelizmente: o que acontece se o cliente entra com
"<b class="com">foobar; rm -rf ~</b>"? A coisa mais segura a fazer é
escrever uma pequena rotina que coloca um caractere de escape ( "<tt class=" const ">\</tt>")
na frente de todos os caracteres não alfanuméricos (incluindo espaços, se for o caso) nos argumentos para o comando.</p>

<p> Como você pode ver, a segurança é um grande problema quando o servidor
começa a executar o que o cliente envia.</p>

</dd>




<dt> <b> Estou enviando uma enorme quantidade de dados, mas quando eu
executo <b><tt class="func">recv()</tt></b> ele recebe apenas 536 bytes ou 1460 bytes de
cada vez. Mas se eu executo em minha máquina local, ele recebe todos os dados
ao mesmo tempo. O que está acontecendo?</b></dt>

<dd>

<p> Você está atingindo o <a name="indexId434909-210"></a> MTU—o tamanho máximo que o meio
físico pode manipular. Na máquina local, você está usando o
dispositivo de loopback que pode lidar até com 8K ou mais sem nenhum problema. Mas em
Ethernet, que pode manipular apenas 1500 bytes com um cabeçalho, você atinge esse
limite. Através de um modem, com 576 MTU (novamente, com cabeçalho), você atinge o
limite ainda mais rapidamente.</p>

<p> Você precisa garantir que todos os dados estão sendo enviados, em primeiro lugar.
(Veja a implementação da função <a href="#sendall"><b> <tt class="func">sendall()</tt></b></a>
para detalhes.) Uma vez que você tenha certeza disso, então você
precisa chamar <b> <tt class="func">recv()</tt></b> em um loop até que todos os seus dados
sejam lidos.</p>

<p> Leia a seção <a href="#sonofdataencap">Bases do encapsulamento de dados
</a> para obter detalhes sobre o recebimento de pacotes completos de dados
usando várias chamadas <b><tt class="func">recv()</tt></b>.</p>

</dd>



<dt> <b> Eu estou em um ambiente Windows e eu não tenho a chamada de sistema
<b><tt class="func">fork()</tt></b> ou qualquer tipo de <nobr><tt class="type">struct
sigaction</tt></nobr>. O que fazer?</b></dt>


<dd>
<p> <a name="indexId434909-211"></a> Elas podem estar em qualquer lugar, elas estarão em bibliotecas POSIX
que podem ter sido fornecidas com o compilador. Como eu não tenho um ambiente Windows, 
eu realmente não posso dizer-lhe a resposta, mas eu me lembro que a
Microsoft tem uma camada de compatibilidade POSIX e é aí
onde estaria <b><tt class="func">fork()</tt></b>. (E talvez até mesmo
<nobr><tt class="type">sigaction</tt></nobr>.)</p>

<p> Procure no help que veio com o VC++ por "fork" ou "POSIX" e veja se ele
fornece alguma pista.</p>

<p> Se isso não funcionar, esqueça <b> <tt class="func">fork()</tt></b>/<nobr><tt class="type">sigaction</tt></nobr> e use em substituiçao o equivalente
em Win32: <a name="indexId434909-212"></a> <b> <tt class="func">CreateProcess()</tt></b>. Eu não sei como
usar <b> <tt class="func">CreateProcess()</tt></b>—é preciso milhões de
argumentos, mas isso deve ser coberto na documentação que veio com VC++.</p>

</dd>


<dt> <b> <a name="indexId434909-213"></a>Estou atrás de um firewall—como faço para que as pessoas
de fora do firewall saibam o meu endereço IP para que elas possam se conectarem à minha máquina?</b></dt>


<dd> <p> Infelizmente, o objetivo de um firewall é impedir
que pessoas fora do firewall se conectem a máquinas dentro do
firewall, portanto, permitir que isso ocorra é basicamente considerado uma violação de segurança.</p>

<p> Isto não quer dizer que tudo está perdido. Por um lado, você ainda pode
usar <b><tt class="func">connect()</tt></b> através do firewall, se ele estiver fazendo
algum tipo de mascaramento ou NAT ou algo parecido. Basta projetar seus programas para que 
você seja sempre o único a iniciar a conexão, e tudo ocorrerá bem.</p>

<p> <a name="indexId434909-214"></a> Se isso não for satisfatório, você
pode pedir a seus administradores para fazerem um buraco no firewall para que as pessoas possam se
conectar a você. O firewall pode encaminhar para você através do software NAT, 
ou através de um proxy ou algo parecido.</p>

<p> Esteja ciente de que um buraco no firewall não deve ser visto de forma leviana.
Você precisa garantir que não concederá às pessoas más acesso à
rede interna; se você é um novato, é muito mais difícil fazer
software seguro do que você possa imaginar.</p>

<p> Não faça seu sysadmin ter raiva de mim.<tt>;-)</tt></p></dd>



<dt> <b> <a name="indexId434909-215"></a> <a name="indexId434909-216"></a> Como faço para escrever
um packet sniffer? Como faço para colocar minha interface Ethernet em modo promíscuo?</b></dt>


<dd> <p> Para aqueles que não sabem, quando uma placa de rede está em "modo promíscuo", ela irá encaminhar TODOS os pacotes para o sistema operacional, e não apenas
aqueles que foram endereçados a esta máquina específica. (Estamos falando
de endereços da camada Ethernet aqui, não endereços IP--mas como ethernet é
de camada inferior a camada IP, todos os endereços IP são efetivamente encaminhados.
Consulte a seção <a href="#lowlevel">Baixo nível nonsense e Teoria de Rede</a> para mais informações.)</p>

<p> Esta é a base para o funcionamento de um packet sniffer. Ela coloca a
interface em modo promíscuo e, em seguida, o sistema operacional obtém cada pacote
que passa pelo fio. Você terá um socket de algum tipo do qual você poderá ler esses dados.</p>

<p> Infelizmente, a resposta para a pergunta varia de acordo com a
plataforma, mas se você busca no Google por, por exemplo, "windows promiscuous <a name="indexId434909-217"></a> ioctl" você provavelmente chegará a algum lugar. Também há o que parece ser
<a href="http://interactive.linuxjournal.com/article/4659" target="_blank">um writeup decente no Linux Journal</a>.</p></dd>



<dt> <b> Como posso definir <a name="indexId434909-218"></a> um valor de timeout personalizado para
um socket TCP ou UDP?</b></dt>

<dd> <p> Depende de seu sistema. Você pode pesquisar na net por <a name="indexId434909-219"></a> <tt class="const">SO_RCVTIMEO</tt> e <a name="indexId434909-220"></a> <tt class="const">SO_SNDTIMEO</tt> (para uso com <a name="indexId434909-221"></a> <b> <tt class="func">setsockopt()</tt></b>) para ver se o seu sistema
suporta essa funcionalidade.</p>

<p> As páginas man Linux sugerem o uso de <b> <tt class="func">alarm()</tt></b> ou
<b> <tt class="func">setitimer()</tt></b> como um substituto.</p>

</dd>



<dt> <b> Como posso saber quais portas estão disponíveis para uso? Existe uma lista de
números "oficiais" de portas?</b></dt>


<dd> <p> Normalmente, isso não é um problema. Se você está escrevendo, digamos, um servidor web, então é uma boa idéia usar a bem conhecida porta 80 para o seu
Programa. Se você estiver escrevendo apenas o seu próprio servidor especializado,
escolha uma porta aleatoriamente (mas maior que 1023) e experimente.</p>

<p> Se a porta já estiver em uso, você receberá um erro "Endereço já em uso"
ao tentar <b> <tt class="func">bind()</tt></b>. Escolha outra porta. (É
uma boa ideia permitir que o usuário do seu software especifique uma
porta alternativa com um arquivo de configuração ou uma opção de linha de comando.)</p>

<p> Há uma <a href="http://www.iana.org/assignments/port-numbers" target="_blank">lista de números de portas oficiais</a>
mantida pelo Internet Assigned Numbers Authority
(IANA). Só porque algo (acima de 1023) está nessa lista, não significa
que você não possa usar a porta. Por exemplo, o DOOM da Id Software usa a mesma
porta que "mdqs", de qualquer forma. Tudo o que importa é que ninguém mais
<i>na mesma máquina</i> esteja usando essa porta quando você quiser usá-la.</p>

</dd>




<hr class="mainsectbreak" /> <h2 class="sect1title">9. <a name="man">Páginas de Manual</a></h2> <hr class="mainsecthr"/>


<p> <a name="indexId434909-222"></a> No mundo Unix, há uma série de manuais.
Eles têm pequenas seções que descrevem funções individuais que você
tem à sua disposição.</p>

<p> Claro, <b class="com">manual</b> seria muito texto para digitar. Quero
dizer, ninguém no mundo Unix, inclusive eu, gosta de digitar
muito. Na verdade, eu poderia continuar e continuar longamente escrevendo sobre o quanto eu
prefiro ser conciso, mas em vez disso, serei breve e não o aborrecerei com
textos despropositados sobre quão incrivelmente breve eu prefiro ser
em quase todas as circunstâncias em sua totalidade.</p>

<p> <i>[Aplausos]</i></p>

<p> Obrigado. O que estou querendo dizer é que estas páginas são chamadas de "man pages" no mundo Unix, e eu incluí minha própria variante pessoal truncada
aqui para o seu prazer de leitura. A coisa é, muitas destas
funções são de uso muito mais geral do que estou mostrando, mas eu só apresentarei
os usos relevantes para Internet Sockets Programming.</p>

<p> Mas espere! Isso não é tudo o que há de errado com minhas man pages:</p>

<ul>

<li> Elas estão incompletas e mostram apenas os conceitos básicos do guia.</li>

<li> Existem muito mais páginas do que estas no mundo real.</li>

<li> Elas são diferentes das que estão em seu sistema.</li>

<li> Os arquivos de cabeçalho podem ser diferente para determinadas funções no seu
sistema.</li>

<li> Os parâmetros das funções podem ser diferentes para determinadas funções no seu
sistema.</li>

</ul>


<p> Se você quiser a informação real, verifique suas man pages Unix locais
digitando <b class="com">man qualquer</b>, onde "qualquer" é algo que
você está incrivelmente interessado, como "<tt class="tt">accept</tt>". (Tenho certeza que o
Microsoft Visual Studio tem algo semelhante em sua seção de ajuda.
Mas o "man" é melhor porque é um byte mais conciso do que "help".
Unix ganha novamente!)</p>

<p> Então, se elas são tão falhas, porque mesmo incluí-las no
Guia? Bem, há algumas razões, mas as melhores são que (a) estas
versões são voltadas especificamente para a programação de rede e são
mais fáceis de digerir que as reais, e (b) estas versões contêm exemplos!</p>

<p> Oh! E falando dos exemplos, eu não costumo colocar toda a
verificação de erros, porque realmente aumenta o comprimento do código. Mas
você deve absolutamente fazer a verificação de erros praticamente sempre que fizer
qualquer chamada de sistema, a menos que você esteja totalmente 100% certo de que não irá
falhar, e você provavelmente deveria fazê-lo mesmo assim!</p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.1. <a name="acceptman"><b> <tt class="titlefunc">accept()</tt></b></a></h2>

<p> Aceita uma conexão de entrada em um socket de escuta</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int <i><tt class="var em1">s</tt></i>, struct sockaddr *<i><tt class="var em1">addr</tt></i>, socklen_t *<i><tt class="var em1">addrlen</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-223"></a> Uma vez que você tenha passado pela dificuldade de conseguir um
<a name="indexId434909-224"></a> socket <tt class="const">SOCK_STREAM</tt> e defini-lo
para conexões de entrada com <b> <tt class="func">listen()</tt></b>, então você chama
<b> <tt class="func">accept()</tt></b> para obter-se, na verdade, um novo descritor de socket
para utilizar para comunicação posterior com o cliente recém-conectado.</p>

<p> O velho socket que você está usando para ouvir ainda está lá, e
será usado para as chamadas <b> <tt class="func">accept()</tt></b> mais recentes.</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="20%%"><i><tt class="var">s</tt></i></td>

<td valign="top" align="left" width="78%%">O descritor de socket de <b> <tt class="func">listen()</tt></b>.</td>
</tr>


<tr> <td valign="top" align="left"><i><tt class="var">addr</tt></i></td>

<td valign="top" align="left">Isso é preenchido com o endereço de quem se conecta a você.</td>
</tr>


<tr> <td valign="top" align="left"><i><tt class="var">addrlen</tt></i></td>

<td valign="top" align="left">Isso é preenchido com <b> <tt class="func">sizeof()</tt></b>
da estrutura retornada no parâmetro <i><tt class="var">addr</tt></i>. Você pode com segurança
ignorá-lo se você assumir que você está recebendo uma <a name="indexId434909-225"></a>
<nobr> <tt class="type">struct sockaddr_in</tt></nobr> de volta, você sabe o que é, porque esse é o tipo
que você passou para <i><tt class="var">add</tt></i>.</td>
</tr>

</table></center>


<p><b><tt class="func">accept()</tt></b> normalmente bloqueará, e você pode usar
<b><tt class="func">select()</tt></b> para dar uma onlhada no descritor de socket de escuta antes
do tempo para ver se ele está "pronto para ler". Se sim, então há uma nova
conexão esperando para ser aceita com <b><tt class="func">accept()</tt></b>, Sim! Alternativamente,
você pode definir a flag <a name="indexId434909-226"></a> <tt class="const">O_NONBLOCK</tt> 
no socket de escuta usando <a name="indexId434909-227"></a> <b> <tt class="func">fcntl()</tt></b>,
e, em seguida, ele nunca será bloqueado, preferindo retornar
<tt class="const">-1</tt> com <i><tt class="var">errno</tt></i> definido para <a name="indexId434909-228"></a> <tt class="const">EWOULDBLOCK</tt>.</p>

<p> O descritor de socket retornado por <b> <tt class="func">accept()</tt></b> é funcional, aberto e conectado ao host remoto. Você tem que o fechar com 
<b> <tt class="func">close()</tt></b> ao terminar.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> <b> <tt class="func">accept()</tt></b> retorna o descritor de socket recém-conectado,
ou <tt class="const">-1</tt> em caso de erro, com <i><tt class="var">errno</tt></i> definido apropriadamente.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">struct sockaddr_storage their_addr;
socklen_t addr_size;
struct addrinfo hints, *res;
int sockfd, new_fd;

// primeiro, carregar estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 ou IPv6, o que for
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // preencha meu IP para mim

getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

// crie um socket, faça bind com, e listen:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
listen(sockfd, BACKLOG);

// agora aceita uma conexão de entrada:

addr_size = sizeof their_addr;
new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

// pronto para se comunicar no descritor de socket new_fd!</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#socketman"><b> <tt class="func">socket()</tt></b></a>,
<a href="#getaddrinfoman"><b> <tt class="func">getaddrinfo()</tt></b></a>,
<a href="#listenman"><b> <tt class="func">listen()</tt></b></a>,
<a href="#sockaddr_inman"><nobr> <tt class="type">struct sockaddr_in</tt></nobr></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.2. <a name="bindman"><b> <tt class="titlefunc">bind()</tt></b></a></h2>

<p> Associa um socket com um endereço IP e um número de porta</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int <i><tt class="var em1">sockfd</tt></i>, struct sockaddr *<i><tt class="var em1">my_addr</tt></i>, socklen_t <i><tt class="var em1">addrlen</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-229"></a>Quando uma máquina remota deseja se conectar ao seu
programa servidor, ela precisa de duas informações: o
<a name="indexId434909-230"></a> endereço IP e o número da porta<a name="indexId434909-231"></a>.
A chamada <b><tt class="func">bind()</tt></b> permite que você faça exatamente isso.</p>

<p>Primeiro, você chama <b><tt class="func">getaddrinfo()</tt></b> para carregar uma <b><tt class="func">struct
sockaddr</tt></b> com o endereço de destino e informações de porta. Então
você chama <b><tt class="func">socket()</tt></b> para obter um descritor de socket, e então você
passa o socket e o endereço IP a <b><tt class="func">bind()</tt></b>, e o endereço IP
e a porta são magicamente (usando magia real) ligados ao socket!</p>

<p> Se você não sabe o seu endereço IP, ou sabe que só possui um endereço IP
na máquina, ou não se importa com qual dos endereços IP da máquina se utiliza, você pode simplesmente passar a flag <tt class="const">AI_PASSIVE</tt>
no parâmetro <i><tt class="var">hints</tt></i> para
<b><tt class="func">getaddrinfo()</tt></b>. O que isto faz é preencher parte do endereço IP
de <b><tt class="func">struct sockaddr</tt></b> com um valor especial que diz
a <b><tt class="func">bind()</tt></b> que deve preencher automaticamente o endereço IP.</p>

<p> O quê? Que valor especial é carregado no endereço IP da <b><tt class="func">struct
sockaddr</tt></b> para fazer com que ela preencha automaticamente com o endereço do host atual? 
Eu lhe direi, mas lembre-se que isto é apenas se
você estiver preenchendo a <nobr><tt class="type">struct sockaddr</tt></nobr> manualmente; se não, use
os resultados de <b><tt class="func">getaddrinfo()</tt></b>, conforme acima. Em IPv4, o campo
<i><tt class="var">sin_addr.s_addr</tt></i> da estrutura <nobr><tt class="type">struct
sockaddr_in</tt></nobr> está definido para <tt class="const">INADDR_ANY</tt>. Em
IPv6, o campo <i><tt class="var">sin6_addr</tt></i> da estrutura <nobr><tt class="type">struct
sockaddr_in6</tt></nobr> é atribuído a partir da variável global
<i><tt class="var">in6addr_any</tt></i>. Ou, se você está declarando uma nova <nobr><tt class="type">struct
in6_addr</tt></nobr>, você pode inicializá-la para
<tt class="const">IN6ADDR_ANY_INIT</tt>.</p>

<p> Por fim, o parâmetro <i><tt class="var">addrlen</tt></i> deve ser definido como
<tt class="tt">sizeof my_addr</tt>.</p>

<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> irá ser definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// maneira moderna de fazer as coisas com getaddrinfo()

struct addrinfo hints, *res;
int sockfd;

// primeiro, carregar estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 ou IPv6, o que for
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // preencha meu IP para mim

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// cria um socket:
// (você deve, na verdade, percorrer a lista vinculada "res" e verificar por erros!)

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind para a porta que passamos para getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<pre class="code">// exemplo empacotamento de uma estrutura manualmente, IPv4

struct sockaddr_in myaddr;
int s;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490);

// você pode especificar um endereço IP:
inet_pton(AF_INET, "63.161.169.137", &amp;(myaddr.sin_addr));

// ou você pode deixar selecionar automaticamente um:
myaddr.sin_addr.s_addr = INADDR_ANY;

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;myaddr, sizeof myaddr);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a>,
<a href="#socketman"><b><tt class="func">socket()</tt></b></a>,
<a href="#sockaddr_inman"><nobr><tt class="type">struct sockaddr_in</tt></nobr></a>,
<a href="#sockaddr_inman"><nobr><tt class="type">struct in_addr</tt></nobr></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.3. <a name="connectman"><b><tt class="titlefunc">connect()</tt></b></a></h2>

<p> Conecta um soquete a um servidor</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int <i><tt class="var em1">sockfd</tt></i>, const struct sockaddr *<i><tt class="var em1">serv_addr</tt></i>,
            socklen_t <i><tt class="var em1">addrlen</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-232"></a> Uma vez que você construiu um descritor de socket com a chamada
<b><tt class="func">socket()</tt></b>, pode-se conectar esse socket a um servidor remoto usando a já bem nomeada chamada de sistema <b><tt class="func">connect()</tt></b>. 
Tudo o que você precisa fazer é passar o descritor de socket e o
endereço do servidor que você está interessado em conhecer melhor. (Ah,
e o comprimento do endereço, que é normalmente passado para funções
como esta.)</p>

<p> Normalmente, esta informação vem como resultado de uma chamada a
<b><tt class="func">getaddrinfo()</tt></b>, mas você pode preencher sua própria <nobr><tt class="type">struct
sockaddr</tt></nobr> se você quiser.</p>

<p> Se você ainda não chamou <b><tt class="func">bind()</tt></b> no descritor de socket
, ele é automaticamente ligado ao seu endereço IP e a uma porta local aleatória. Isso geralmente é bom para você, se você não for um servidor,
já que realmente não se importará com a porta local; você só se importará com a porta remota, então você pode colocá-la no parâmetro <i><tt class="var">serv_addr</tt></i>.
Você <i>pode</i> chamar <b><tt class="func">bind()</tt></b> se você realmente
quiser que seu socket cliente esteja em um endereço IP e porta específicos, mas
isso é muito raro.</p>

<p>Uma vez que o socket é conectado com <b><tt class="func">connect()</tt></b>, você está livre para
usar <b><tt class="func">send()</tt></b> e <b><tt class="func">recv()</tt></b> e trafegar dados sobre ele como manda seu coração.</p>

<p><a name="indexId434909-233"></a> Nota especial: se você se conecta com
<b><tt class="func">connect()</tt></b> a um socket <tt class="const">SOCK_DGRAM</tt> UDP em um
host remoto, você pode usar <b><tt class="func">send()</tt></b> e <b><tt class="func">recv()</tt></b>
bem como <b><tt class="func">sendto()</tt></b> e <b><tt class="func">recvfrom()</tt></b>. Se você quiser.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> irá ser definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// conecte-se à www.example.com, porta 80 (http)

struct addrinfo hints, *res;
int sockfd;

// primeiro, carregar estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 ou IPv6, o que for
hints.ai_socktype = SOCK_STREAM;

// poderíamos colocar "80" em vez de "http" na próxima linha:
getaddrinfo("www.example.com", "http", &amp;hints, &amp;res);

// cria o socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// conectá-lo ao endereço e porta que passamos a getaddrinfo():

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<h3 class="sect2title">Consulte também</h3>

<p> <a href="#socketman"><b> <tt class="func">socket()</tt></b></a>,
<a href="#bindman"><b><tt class="func">bind()</tt></b></a></p>


<hr class="mainsectbreak"/>
<h2 class="sect1title">9.4. <a name="closeman"><b> <tt class="titlefunc">close()</tt></b></a></h2>

<p> Fecha um descritor de socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;unistd.h&gt;

int close(int <i><tt class="var em1">s</tt></i>);</pre>



<h3 class="sect2title">Descrição</h3>

<p><a name="indexId434909-234"></a> Depois que você terminar de usar o socket para
qualquer esquema demente que você tenha inventado e você não quiser
mais usar <b><tt class="func">send()</tt></b> ou <b><tt class="func">recv()</tt></b> ou, na verdade, fazer <i>qualquer coisa
</i> com o socket, você pode o fechar com <b><tt class="func">close()</tt></b>, e
ele será liberado, para nunca mais ser usado novamente.</p>

<p> O lado remoto pode saber que isso aconteceu de duas maneiras. Um: se o
lado remoto chamadar <b><tt class="func">recv()</tt></b>, ele irá retornar <tt class="const">0</tt>.
Dois: se o lado remoto chamar <b><tt class="func">send()</tt></b>, receberá um
sinal <a name="indexId434909-235"></a> <tt class="const">SIGPIPE</tt> e send() retornará
<tt class="const">-1</tt> e <i><tt class="var">errno</tt></i> será definido para <a name="indexId434909-236"></a> <tt class="const">EPIPE</tt>.</p>

<p> <a name="indexId434909-237"></a> <b>Usuários de Windows</b>: a função que você precisa usar
chama-se <a name="indexId434909-238"></a> <b><tt class="func">closesocket()</tt></b>, não
<b><tt class="func">close()</tt></b>. Se você tentar usar <b><tt class="func">close()</tt></b> em um
descritor de socket, é possível que o Windows fique irritado... E você
não gostaria dele irritado.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> irá ser definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">s = socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// um monte de coisas...*BRRRONNNN!*
.
.
.
close(s);  // Não se parece muito com isso, realmente.</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#socketman"><b><tt class="func">socket()</tt></b></a>,
<a href="#shutdownman"><b><tt class="func">shutdown()</tt></b></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.5. <a name="getaddrinfoman"><b><tt class="titlefunc">getaddrinfo()</tt></b>, <b><tt class="titlefunc">freeaddrinfo()</tt></b>,
<b><tt class="titlefunc">gai_strerror()</tt></b></a></h2>

<p> Obtém informações sobre um nome de host e/ou serviço e carrega uma
<nobr><tt class="type">struct sockaddr</tt></nobr> com o resultado.</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *nodename, const char *servname,
                const struct addrinfo *hints, struct addrinfo **res);

void freeaddrinfo(struct addrinfo *ai);

const char *gai_strerror(int ecode);

struct addrinfo {
  int     ai_flags;          // AI_PASSIVE, AI_CANONNAME, ...
  int     ai_family;         // AF_xxx
  int     ai_socktype;       // SOCK_xxx
  int     ai_protocol;       // 0 (auto) ou IPPROTO_TCP, IPPROTO_UDP 

  socklen_t  ai_addrlen;     // tamanho de ai_addr
  char   *ai_canonname;      // nome canônico para nodename
  struct sockaddr  *ai_addr; // endereço binário
  struct addrinfo  *ai_next; // próxima estrutura na lista vinculada
};</pre>

<h3 class="sect2title">Descrição</h3>

<p> <b> <tt class="func">getaddrinfo()</tt></b> é uma excelente função que irá retornar
informações sobre um nome de host específico (como o seu endereço IP) e carregar
uma <nobr> <tt class="type">struct sockaddr</tt></nobr> para você, cuidando dos detalhes
importantes (como se é IPv4 ou IPv6). Ela substitui as antigas funções
<b><tt class="func">gethostbyname()</tt></b> e <b><tt class="func">getservbyname()</tt></b>. A
descrição, abaixo, contém uma grande quantidade de informação que pode ser um pouco
assustadora, mas o uso é bastante simples. Pode valer a pena
conferir os exemplos primeiro.</p>

<p> O nome do host em que você estiver interessado vai no parâmetro
<i><tt class="var">nodename</tt></i>. O endereço pode ser um nome de
host, como "www.example.com", ou um endereço IPv4 ou IPv6 (passado como
string). Este parâmetro também pode ser <tt class="const">NULL</tt> se você estiver usando
a flag <tt class="const">AI_PASSIVE</tt> (veja abaixo).</p>

<p> O parâmetro <i><tt class="var">servname</tt></i> é basicamente o número da porta.
Ele pode ser um número de porta (passada como string, como "80"), ou pode ser um
nome de serviço, como "http" ou "tftp" ou "smtp" ou "pop", etc. Nomes de serviço bem conhecidos
podem ser encontrados no <a href="http://www.iana.org/assignments/port-numbers" target="_blank">IANA Port
List</a> ou em seu arquivo <i><tt class="var">/etc/services</tt></i>.</p>

<p> Por fim, para parâmetros de entrada, temos <i><tt class="var">sugestões</tt></i>. Isto é
realmente onde você começa a definir o que a função <b><tt class="func">getaddrinfo()</tt></b>
irá fazer. Zere toda a estrutura antes da utilização com
<b><tt class="func">memset()</tt></b>. Vamos dar uma olhada nos campos que você precisa configurar
antes do uso.</p>

<p> O <i><tt class="var">ai_flags</tt></i> pode ser configurado para uma variedade de coisas, mas
aqui estão algumas das mais importantes. (Se podem especificar múltiplas flags por
bitwise-ORing juntamente com o operador <tt class="operador">|</tt>.)
Verifique a sua página man para a lista completa de flags.</p>

<p> <tt class="const">AI_CANONNAME</tt> causa que <i><tt class="var">ai_canonname</tt></i>
do resultado se complete com o nome canônico (real) do host.
<tt class="const">AI_PASSIVE</tt> faz com que o endereço IP do resultado se complete
com <tt class="const">INADDR_ANY</tt> (IPv4) ou
<i><tt class="var">in6addr_any</tt></i> (IPv6); isso faz com que uma chamada subsequente a
<b><tt class="func">bind()</tt></b> preencha automaticamente o endereço IP da <nobr><tt class="type">struct
sockaddr</tt></nobr> com o endereço do host atual. Isso é excelente
para configurar um servidor quando você não deseja codificar o endereço.</p>

<p> Se você não usar a flag <tt class="const">AI_PASSIVE</tt>, então você pode passar
<tt class="const">NULL</tt> no <i><tt class="var">nodename</tt></i> (já que
<b><tt class="func">bind()</tt></b> irá preenchê-lo para você mais tarde.)</p>

<p> Continuando com os parâmetros de entrada, você provavelmente vai querer definir
<i><tt class="var">ai_family</tt></i> para <tt class="const">AF_UNSPEC</tt> que diz a
<b><tt class="func">getaddrinfo()</tt></b> para operar com ambos os endereços, IPv4 e IPv6.
Você também pode restringir a um ou a outro com
<tt class="const">AF_INET</tt> ou <tt class="const">AF_INET6</tt>.</p>

<p> Em seguida, o campo <i><tt class="var">socktype</tt></i> deve ser definido como
<tt class="const">SOCK_STREAM</tt> ou <tt class="const">SOCK_DGRAM</tt>, dependendo
de qual tipo de socket se deseja.</p>

<p> Finalmente, apenas deixe <i><tt class="var">ai_protocol</tt></i> definido em <tt class="const">0</tt> para
escolher automaticamente o seu tipo de protocolo.</p>

<p> Agora, depois meter todas essas coisas lá dentro, você pode
<i>finalmente</i> fazer a chamada a <b><tt class="func">getaddrinfo()</tt></b>!</p>

<p> É claro, este é o lugar onde a diversão começa. A <i><tt class="var">res</tt></i> agora
apontará para uma lista vinculada de <nobr><tt class="type">struct addrinfo</tt></nobr>s, e você pode
percorrer esta lista para obter todos os endereços que correspondam ao que você passou com hints.</p>

<p> Agora, é possível obter alguns endereços que não funcionam por uma
razão ou outra, de modo que o que a Linux man page faz é em loops percorrer a
lista fazendo uma chamada a <b><tt class="func">socket()</tt></b> e <b><tt class="func">connect()</tt></b>
(Ou <b><tt class="func">bind()</tt></b> se você estiver configurando um servidor com a flag
<tt class="const">AI_PASSIVE</tt>) até obter êxito.</p>

<p> Finalmente, quando você terminar com a lista vinculada, você precisa chamar
<b><tt class="func">freeaddrinfo()</tt></b> para liberar memória (ou ela vazará,
e algumas pessoas ficarão chateadas.)</p>

<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou diferente de zero em caso de erro. Se ela retornar diferente de zero,
você pode usar a função <b><tt class="func">gai_strerror()</tt></b> para obter versão de impressão do código de erro no valor de retorno.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// código para um cliente se conectar a um servidor
// ou seja, um soquete stream para www.example.com na porta 80 (http)
// seja IPv4 ou IPv6

int sockfd;  
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // use AF_INET6 para forçar IPv6
hints.ai_socktype = SOCK_STREAM;

if ((rv = getaddrinfo("www.example.com", "http", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    exit(1);
}

// percorrer todos os resultados e conectar-se ao primeiro que pudermos
for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
    if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
            p-&gt;ai_protocol)) == -1) {
        perror("socket");
        continue;
    }

    if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        perror("connect");
        close(sockfd);
        continue;
    }

    break; // se chegamos aqui, devemos ter conectado com sucesso
}

if (p == NULL) {
    // encerrado no final da lista sem conexão
    fprintf(stderr, "failed to connect\n");
    exit(2);
}

freeaddrinfo(servinfo); // tudo feito com essa estrutura</pre>


<pre class="code">// código para um servidor aguardar conexões
// ou seja, um socket stream na porta 3490, no IP deste host
// seja IPv4 ou IPv6.

int sockfd;  
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // use AF_INET6 para forçar IPv6
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE; // use meu endereço IP

if ((rv = getaddrinfo(NULL, "3490", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    exit(1);
}

// loop através de todos os resultados e vincular ao primeiro que pudermos
for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
    if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
            p-&gt;ai_protocol)) == -1) {
        perror("socket");
        continue;
    }

    if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        close(sockfd);
        perror("bind");
        continue;
    }

    break; // se chegamos aqui, devemos ter conectado com sucesso
}

if (p == NULL) {
    // percorreu até o fim da lista sem sucesso ao fazer bind
    fprintf(stderr, "falha ao fazer bind para o socket\n");
    exit(2);
}

freeaddrinfo(servinfo); // tudo feito com essa estrutura</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b></a>,
<a href="#getnameinfoman"><b><tt class="func">getnameinfo()</tt></b></a></p>


<hr class="mainsectbreak"/>
<h2 class="sect1title">9.6. <a name="gethostnameman"><b> <tt class="titlefunc">gethostname()</tt></b></a></h2>

<p> Retorna o nome do sistema</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/unistd.h&gt;

int gethostname(char *<i><tt class="var em1">name</tt></i>, size_t <i><tt class="var em1">len</tt></i>);</pre>

<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-239"></a> Seu sistema tem um nome. Tudo eles têm. Essa
é uma coisa um pouco mais de UNIXy do que o resto das coisas sobre redes das quais temos
falado, mas ela ainda tem seus usos.</p>

<p> Por exemplo, você pode obter o seu nome de host, e depois chamar <a name="indexId434909-240"></a> <b> <tt class="func">gethostbyname()</tt></b> para descobrir o seu
<a name="indexId434909-241"></a> endereço IP.</p>

<p> O parâmetro <i><tt class="var">name</tt></i> deve apontar para um buffer que conterá
o nome de host, e <i><tt class="var">len</tt></i> é o tamanho desse buffer em bytes.
<b><tt class="func">gethostname()</tt></b> não sobrescreve o final do buffer (pode retornar um erro, ou pode simplesmente parar de escrever), e terminará com
<tt class="const">NULL</tt> char a string, se houver espaço para isso no buffer.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">char hostname[128];

gethostname(hostname, sizeof hostname);
printf("Meu hostname: %s\n", hostname);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b></a></p>




<hr class="mainsectbreak"/>
<h2 class="sect1title">9.7. <a name="gethostbynameman"><b> <tt class="titlefunc">gethostbyname()</tt></b>, <b><tt class="titlefunc">gethostbyaddr()</tt></b></a></h2>

<p> Obtém um endereço IP de um nome de host ou vice-versa</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

struct hostent *gethostbyname(const char *<i><tt class="var em1">name</tt></i>); // DESCONTINUADA!
struct hostent *gethostbyaddr(const char *<i><tt class="var em1">addr</tt></i>, int <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">type</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-242"></a> <a name="indexId434909-243"></a> <i>POR FAVOR
NOTE: estas duas funções são substituídas por <b><tt class="func">getaddrinfo()</tt></b>
e <b><tt class="func">getnameinfo()</tt></b>!</i> Em particular,
<b><tt class="func">gethostbyname()</tt></b> não funciona bem com o IPv6.</p>

<p> Essas funções são mapeadas entre os nomes de host e os endereços IP.
Por exemplo, se você tem "www.example.com", você pode usar
<b><tt class="func">gethostbyname()</tt></b> para obter seu endereço IP e armazená-lo em uma
<nobr><tt class="type">struct in_addr</tt></nobr>.</p>

<p> Por outro lado, se você tem uma <nobr><tt class="type">struct in_addr</tt></nobr> ou uma
<nobr><tt class="type">struct in6_addr</tt></nobr>, você pode usar <b><tt class="func">gethostbyaddr()</tt></b>
para recuperar o nome de host. <b><tt class="func">gethostbyaddr()</tt></b><i> é </i>
compatível com IPv6, mas você deve usar o mais novo e brilhante
<b><tt class="func">getnameinfo()</tt></b> em seu lugar.</p>

<p> (Se você tem uma string contendo um endereço IP no formato pontos-e-números
da qual você deseja procurar o nome do host, seria melhor usar
<b><tt class="func">getaddrinfo()</tt></b> com a flag <tt class="const">AI_CANONNAME</tt>.)</p>

<p> <b><tt class="func">gethostbyname()</tt></b> recebe uma string como "www.yahoo.com", e
retorna uma <nobr><tt class="type">struct hostent</tt></nobr>, que contém toneladas de
informações, incluindo o <a name="indexId434909-244"></a> endereço IP. (Outras
informações são o nome oficial do host, uma lista de aliases, o tipo de endereço,
o comprimento dos endereços e a lista de endereços—é
uma estrutura de uso geral que é muito fácil de usar para o nossos propósitos específicos,
uma vez que você vê como fazer.)</p>

<p> <b><tt class="func">gethostbyaddr()</tt></b> leva uma <nobr><tt class="type">struct in_addr</tt></nobr> ou uma
<nobr><tt class="type">struct in6_addr</tt></nobr> e traz para você um nome de host correspondente
(se houver), por isso é uma espécie de <b><tt class="func">gethostbyname()</tt></b> reversa. Quanto aos parâmetros, embora
<i><tt class="var">addr</tt></i> seja um <nobr><tt class="type">char *</tt></nobr>, você realmente deseja passar um
ponteiro para uma <nobr><tt class="type">struct in_addr</tt></nobr>. <i><tt class="var">len</tt></i> deve ser
<tt class="tt">sizeof (struct in_addr)</tt> e <i><tt class="var">type</tt></i> deve ser <tt class="const">AF_INET</tt>.</p>

<p> Então, o que é esta <a name="indexId434909-245"></a> <nobr><tt class="type">struct hostent</tt></nobr>
que é retornada? Ela possui uma série de campos que contém informações
sobre o host em questão.</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="30%%"><i><tt class="var">char *h_name</tt></i></td>

<td valign="top" align="left" width="68%%">O nome real canônico do host.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">char **h_aliases</tt></i></td>

<td valign="top" align="left">Uma lista de aliases que podem ser acessados com
arrays—o último elemento é <tt class="const">NULL</tt></td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">int h_addrtype</tt></i></td>

<td valign="top" align="left">O tipo de endereço do resultado, que realmente deveria ser
<tt class="const">AF_INET</tt> para nossos propósitos.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">int length</tt></i></td>

<td valign="top" align="left">O comprimento dos endereços em bytes, que é 4 para
Endereços IP (versão 4).</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">char **h_addr_list</tt></i></td>

<td valign="top" align="left">Uma lista de endereços IP para este host. Embora isso
seja um <nobr><tt class="type">char**</tt></nobr>, é realmente um array de <nobr><tt class="type">struct
in_addr*</tt></nobr>s disfarçado. O último elemento do array é
<tt class="const">NULL</tt>.</td>
</tr>


<tr><td valign="top" align="left"><i><tt class="var">h_addr</tt></i></td>

<td valign="top" align="left">Um alias comumente definido para
<i><tt class="var">h_addr_list[0]</tt></i>.  Se você quer apenas um endereço IP antigo para esse
host (sim, eles podem ter mais de um) apenas use este campo.</td>
</tr>


</table></center>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna um ponteiro para uma <nobr><tt class="type">struct hostent</tt></nobr> resultante em caso de
sucesso, ou <tt class="const">NULL</tt> em caso de erro.</p>

<p> Em vez do <b><tt class="func">perror()</tt></b> normal e todas essas coisas que você
normalmente usaria para o relatório de erros, essas funções têm resultados paralelos
na variável <i><tt class="var">h_errno</tt></i>, que podem ser impressos usando-se as
funções <a name="indexId434909-246"></a> <b> <tt class="func">herror()</tt></b> ou <a name="indexId434909-247"></a> <b> <tt class="func">hstrerror()</tt></b>. Elas funcionam como as
clássicas funções <i><tt class="var">errno</tt></i>, <b><tt class="func">perror()</tt></b>, e
<b><tt class="func">strerror()</tt></b> com as quais você está acostumado.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// ESTE É UM MÉTODO NÃO INDICADO OBTER NOMES DE HOST
// use getaddrinfo() em vez disso!

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char *argv[])
{
    int i;
    struct hostent *he;
    struct in_addr **addr_list;

    if (argc != 2) {
        fprintf(stderr,"use: ghbn hostname\n");
        return 1;
    }

    if ((he = gethostbyname(argv[1])) == NULL) {  // obtém as informações do host
        herror("gethostbyname");
        return 2;
    }

    // imprimir informações sobre este host:
    printf("Nome oficial é: %s\n", he-&gt;h_name);
    printf("    Endereços IP: ");
    addr_list = (struct in_addr **)he-&gt;h_addr_list;
    for(i = 0; addr_list[i] != NULL; i++) {
        printf("%s ", inet_ntoa(*addr_list[i]));
    }
    printf("\n");

    return 0;
}</pre>


<pre class="code">// ISSO FOI SUPERADO
// use getnameinfo() em vez disso!

struct hostent *he;
struct in_addr ipv4addr;
struct in6_addr ipv6addr;

inet_pton(AF_INET, "192.0.2.34", &amp;ipv4addr);
he = gethostbyaddr(&amp;ipv4addr, sizeof ipv4addr, AF_INET);
printf("Host name: %s\n", he-&gt;h_name);

inet_pton(AF_INET6, "2001:db8:63b3:1::beef", &amp;ipv6addr);
he = gethostbyaddr(&amp;ipv6addr, sizeof ipv6addr, AF_INET6);
printf("Host name: %s\n", he-&gt;h_name);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#getaddrinfoman"><b> <tt class="func">getaddrinfo()</tt></b></a>,
<a href="#getnameinfoman"><b> <tt class="func">getnameinfo()</tt></b></a>,
<a href="#gethostnameman"><b> <tt class="func">gethostname()</tt></b></a>,
<a href="#errnoman"><i><tt class="var">errno</tt></i></a>,
<a href="#perrorman"><b> <tt class="func">perror()</tt></b></a>,
<a href="#perrorman"><b> <tt class="func">strerror()</tt></b></a>,
<a href="#sockaddr_inman"><nobr> <tt class="type">struct in_addr</tt></nobr></a></p>




<hr class="mainsectbreak" />
<h2 class="sect1title">9.8. <a name="getnameinfoman"><b> <tt class="titlefunc">getnameinfo()</tt></b></a></h2>

<p> Procura informações do nome do host e do nome do serviço nome para uma determinada
<nobr><tt class="type">struct sockaddr</tt></nobr>.</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getnameinfo(const struct sockaddr *sa, socklen_t salen,
                char *host, size_t hostlen,
                char *serv, size_t servlen, int flags);</pre>



<h3 class="sect2title">Descrição</h3>

<p> Esta função é o oposto de <b><tt class="func">getaddrinfo()</tt></b>, isto é,
esta função pega uma já carregada <nobr><tt class="type">struct sockaddr</tt></nobr> e
faz uma pesquisa de nome e nome de serviço nela. Ela substitui as antigas
funções <b><tt class="func">gethostbyaddr()</tt></b> e <b><tt class="func">getservbyport()</tt></b>.</p>

<p> Você deve passar um ponteiro para uma <nobr><tt class="type">struct sockaddr</tt></nobr>
(que na realidade é provavelmente uma <nobr><tt class="type">struct sockaddr_in</tt></nobr> ou
<nobr><tt class="type">struct sockaddr_in6</tt></nobr> que você tenha convertido) no parâmetro
<i><tt class="var">sa</tt></i>, e o comprimento dessa <nobr><tt class="type">struct</tt></nobr>
em <i><tt class="var">salen</tt></i>.</p>

<p> O nome do host e nome do serviço resultantes serão escrito na área
apontado pelos parâmetros <i><tt class="var">host</tt></i> e <i><tt class="var">serv</tt></i>.
Obviamente, você precisa especificar os comprimentos máximos desses
buffers em <i><tt class="var">hostlen</tt></i> e <i><tt class="var">servlen</tt></i>.</p>

<p> Finalmente, existem várias flags você pode passar, mas aqui estão algumas
boas. <tt class="const">NI_NOFQDN</tt> fará com que <i><tt class="var">host</tt></i>
contenha apenas o nome do host, e não o nome completo do domínio.
<tt class="const">NI_NAMEREQD</tt> fará com que a função falhe se o nome
não puder ser encontrado com uma pesquisa de DNS (se você não especificar esta flag e
o nome não puder ser encontrado, <b><tt class="func">getnameinfo()</tt></b> colocará uma versão de string
do endereço IP em <i><tt class="var">host</tt></i> no seu lugar.)</p>

<p> Como sempre, verifique as suas man pages locais para informações completas.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou diferente de zero em caso de erro. Se o valor de retorno
é diferente de zero, pode ser passado para <b><tt class="func">gai_strerror()</tt></b> para se obter uma
string legível por humanos. Veja <b><tt class="func">getaddrinfo</tt></b> para mais informações.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">struct sockaddr_in6 sa; // poderia ser IPv4 se você quiser
char host[1024];
char service[20];

// sa está cheio de boas informações sobre o host e porta ...

getnameinfo(&amp;sa, sizeof sa, host, sizeof host, service, sizeof service, 0);

printf("   host: %s\n", host);    // ex. "www.example.com"
printf("service: %s\n", service); // ex. "http"
</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#getaddrinfoman"><b> <tt class="func">getaddrinfo()</tt></b></a>,
<a href="#gethostbynameman"><b> <tt class="func">gethostbyaddr()</tt></b></a></p>




<hr class="mainsectbreak"/>
<h2 class="sect1title">9.9. <a name="getpeernameman"><b> <tt class="titlefunc">getpeername()</tt></b></a></h2>

<p> Retorna informação de endereço sobre o lado remoto da conexão</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/socket.h&gt;

int getpeername(int <i><tt class="var em1">s</tt></i>, struct sockaddr *<i><tt class="var em1">addr</tt></i>, socklen_t *<i><tt class="var em1">len</tt></i>);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-248"></a> Uma vez que você tenha aceitado com <b><tt class="func">accept()</tt></b>
uma conexão remota, ou conectado com <b><tt class="func">connect()</tt></b> a um servidor, você agora
tem o que é conhecido como um <i>par</i>. Seu par é simplesmente o
computador ao qual você está conectado, identificado por um <a name="indexId434909-249"></a>
endereço IP e uma porta. <a name="indexId434909-250"></a>
Então ...</p>

<p> <b><tt class="func">getpeername()</tt></b> simplesmente devolve uma <nobr><tt class="type">struct
sockaddr_in</tt></nobr> preenchida com informações sobre a máquina a qual você está conectado.</p>

<p> Por que é chamado um "name"? Bem, há um monte de diferentes tipos
de sockets, não apenas Internet Sockets, como estamos usando neste guia,
e então "name" é um bom termo genérico que cobre todos os casos. No nosso
caso, porém, "name" do par é o seu endereço IP e porta.</p>

<p> Embora a função retorne o tamanho do endereço resultante em
<i><tt class="var">len</tt></i>, é necessário pré-carregar <i><tt class="var">len</tt></i> com o tamanho de
<i><tt class="var">addr</tt></i>.</p>



<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> irá ser definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// suponha que s é um soquete conectado

socklen_t len;
struct sockaddr_storage addr;
char ipstr[INET6_ADDRSTRLEN];
int port;

len = sizeof addr;
getpeername(s, (struct sockaddr*)&amp;addr, &amp;len);

// deal with both IPv4 and IPv6:
if (addr.ss_family == AF_INET) {
    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;
    port = ntohs(s-&gt;sin_port);
    inet_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, sizeof ipstr);
} else { // AF_INET6
    struct sockaddr_in6 *s = (struct sockaddr_in6 *)&amp;addr;
    port = ntohs(s-&gt;sin6_port);
    inet_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, sizeof ipstr);
}

printf(Endereço IP do par: %s\n", ipstr);
printf("Porta do par      : %d\n", port);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#gethostnameman"><b> <tt class="func">gethostname()</tt></b></a>,
<a href="#gethostbynameman"><b> <tt class="func">gethostbyname()</tt></b></a>,
<a href="#gethostbynameman"><b> <tt class="func">gethostbyaddr()</tt></b></a></p>




<hr class="mainsectbreak" />
<h2 class="sect1title">9.10. <a name="errnoman"><i><tt class="titlevar">errno</tt></i></a></h2>

<p> Contém o código de erro da última chamada do sistema</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;errno.h&gt;

int <i><tt class="var em1">errno</tt></i>;</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-251"></a> Essa é a variável que contém informações de erro
para muitas de chamadas de sistema. Se você se lembrar, coisas como
<b><tt class="func">socket()</tt></b> e <b><tt class="func">listen()</tt></b> retornam <tt class="const">-1</tt>
em caso de erro, e elas definem o valor exato de <i><tt class="var">errno</tt></i> para que saiba
especificamente qual erro ocorreu.</p>

<p> O arquivo de cabeçalho <i><tt class="var">errno.h</tt></i> lista um monte de nomes
simbólicos constantes para erros, como <tt class="const">EADDRINUSE</tt>,
<tt class="const">EPIPE</tt>, <tt class="const">ECONNREFUSED</tt>, etc. Suas man pages locais
lhe dirão quais códigos podem ser retornados como um erro, e você pode
usá-los em tempo de execução para lidar com diferentes erros de diferentes maneiras.</p>

<p> Ou, mais comumente, você pode chamar <a name="indexId434909-252"></a> <b> <tt class="func">perror()</tt></b> ou <a name = "indexId434909-253"></a> <b> <tt class="func">strerror()</tt></b> para obter uma versão legível
do erro.</p>

<p> Uma coisa a notar, para você estusiasta do multithreading, é que na
maioria dos sistemas <i><tt class="var">errno</tt></i> é definido de forma thread-safe. (Ou seja,
não é realmente uma variável global, mas se comporta exatamente como uma
variável global faria em um ambiente single-threaded).</p>



<h3 class="sect2title">Valor de retorno</h3>

<p> O valor da variável é o do erro mais recente a ter acontecido, que
pode ser o código para o "sucesso" se a última ação for bem sucedida.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">s = socket(PF_INET, SOCK_STREAM, 0);
if (s == -1) {
    perror("socket"); // ou use strerror()
}

tryagain:
if (select(n, &amp;readfds, NULL, NULL) == -1) {
    // ocorreu um erro!!

    // se fôssemos apenas interrompidos, bastaria reiniciar a chamada select ():
    if (errno == EINTR) goto tryagain;  // AAAA!  goto!!!

    // caso contrário, é um erro mais sério:
    perror("select");
    exit(1);
}</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#perrorman"><b> <tt class="func">perror()</tt></b></a>,
<a href="#perrorman"><b> <tt class="func">strerror()</tt></b></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.11. <a name="fcntlman"><b> <tt class="titlefunc">fnctl()</tt></b></a></h2>

<p> Controla descritores de socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/unistd.h&gt;
#include &lt;sys/fcntl.h&gt;

int fcntl(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">cmd</tt></i>, long <i><tt class="var em1">arg</tt></i>);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-254"></a> Esta função é normalmente usada para realizar bloqueio de arquivos
e outras coisas relacionadas, mas também possui algumas habilidades relacionadas a sockets que você pode ver ou usar de tempos em tempos.</p>

<p> O parâmetro <i><tt class="var">s</tt></i> é o descritor de socket no qual você deseja operar, 
o <i><tt class="var">cmd</tt></i> deve ser definido como <a name="indexId434909-255"></a> <tt class="const">F_SETFL</tt> e <i><tt class="var">arg</tt></i> pode ser um dos
seguintes comandos. (Como eu disse, há mais sobre
<b> <tt class="func">fcntl()</tt></b> do que eu estou deixando aqui, mas eu estou tentando me manter
voltado a sockets.)</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="20%%"><a name="indexId434909-256"></a> <tt class="const">O_NONBLOCK</tt></td>

<td valign="top" align="left" width="73%%">Configura o socket para non-blocking. Veja a seção sobre
<a href="#blocking">blocking</a> para mais detalhes.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-257"></a> <tt class="const">O_ASYNC</tt></td>

<td valign="top" align="left">Configura o socket para fazer E/S assíncrona. Quando os dados são
prontos para serem recebidos com <b><tt class="func">recv()</tt></b> no socket, o sinal <a name="indexId434909-258"></a> <tt class="const">SIGIO</tt> será gerado. Isso é raro de se ver,
e além do escopo do guia. E acho que ele só está disponível em
determinados sistemas.</td>
</tr>


</table></center>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b> <tt class="func">errno</tt></b> será definido em conformidade.)</p>

<p> Diferentes usos da chamada de sistema <b><tt class="func">fcntl()</tt></b> na verdade possuem
valores de retorno diferentes, mas eu não os cobrirei aqui porque eles não
são relacionados a sockets. Consulte a sua página man local de <b><tt class="func">fcntl()</tt></b> para mais informações.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int s = socket(PF_INET, SOCK_STREAM, 0);

fcntl(s, F_SETFL, O_NONBLOCK);  // configura para non-blocking
fcntl(s, F_SETFL, O_ASYNC);     // configura E/S assíncrona</pre>


<h3 class="sect2title">Consulte também</h3>

<p> <a href="#blocking">Blocking</a>,
<a href="#sendman"><b> <tt class="func">send()</tt></b></a></p>




<hr class="mainsectbreak"/>
<h2 class="sect1title">9.12. <a name="htonsman"><b><tt class="titlefunc">htons()</tt></b>, <b> <tt class="titlefunc">htonl()</tt></b>,
<b> <tt class="titlefunc">ntohs()</tt></b>, <b> <tt class="titlefunc">ntohl()</tt></b></a></h2>


<p> Converte tipos inteiros multi-byte de host byte order para network byte order.</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;netinet/in.h&gt;

uint32_t htonl(uint32_t <i><tt class="var em1">hostlong</tt></i>);
uint16_t htons(uint16_t <i><tt class="var em1">hostshort</tt></i>);
uint32_t ntohl(uint32_t <i><tt class="var em1">netlong</tt></i>);
uint16_t ntohs(uint16_t <i><tt class="var em1">netshort</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-259"></a> <a name="indexId434909-260"></a> <a name="indexId434909-261"></a> <a name ="indexId434909-262"></a> Apenas para fazer você realmente infeliz, computadores diferentes usam
diferentes ordenações de bytes internamente para seus inteiros multi-byte (ou seja,
qualquer número inteiro que seja maior que um <nobr> <tt class="type">char</tt></nobr>.) O resultado disso
é que se você envia um <nobr><tt class="type">short int</tt></nobr> de dois bytes com <b> <tt class="func">send()</tt></b>
a partir de um ambiente Intel para um Mac (antes de ambos se tornarem ambientes Intel,
também, quero dizer), o que um computador pensa é que o número é <tt class="const">1</tt>,
o outro pensará que é o número <tt class="const">256</tt>, e
vice-versa.</p>

<p> <a name="indexId434909-263"></a> A maneira de contornar este problema é que
todos deixam de lado suas diferenças e concordam que a Motorola e a IBM
tinham razão, e a Intel fez isso da maneira estranha, e assim todos nós convertemos nossas
ordenações de bytes para "big-endian" antes de enviá-los. Como a Intel usa
máquinas "little-endian", é bem mais politicamente correto chamar nossa
ordenação de bytes preferida de "Network Byte Order". Portanto, essas funções
convertem de sua ordem de bytes nativa para ordem de bytes de rede e de volta.</p>

<p> (Isto significa que em Intel essas funções trocam todos os bytes, e
em PowerPC elas não fazem nada porque os bytes já estão em Network Byte Order. 
Mas você deve sempre usá-las em seus códigos de qualquer maneira, uma vez que
alguém possa querer construí-los em uma máquina Intel e ainda terá as coisas a
funcionarem adequadamente.)</p>

<p> Note que os tipos envolvidos são de 32 bits (4 bytes, provavelmente
<nobr> <tt class="type">int</tt></nobr>) e de 16 bits (dois bytes, muito provavelmente <nobr> <tt class="type">short</tt></nobr>). 
Máquinas de 64 bits podem ter um <b> <tt class="func">htonll()</tt></b>
<nobr> <tt class="type">int</tt></nobr>s de 64bits, mas eu desconheço. Você só terá que escrever o seu
próprio.</p>

<p> De qualquer forma, a maneira como essas funções trabalham é que primeiro você decide se
está convertendo <i>de</i> host byte order (da sua máquina) ou
de network byte order. Se "host", a primeira letra da
função que você vai chamar é "h". Caso contrário, é "n" para "network".
O meio do nome da função é sempre "to" porque você está convertendo
de um "para" o outro, e a penúltima letra mostra o que você está convertendo
<i>to</i>. A última letra é o tamanho dos dados, "s" para short,
ou "l" para long. Assim:</p>


<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="20%%"><a name="indexId434909-264"></a> <b> <tt class="func" > htons()</tt></b></td>
<td valign="top" align="left" width="78%%"><b> <tt class="func">h</tt></b>ost<b> <tt class="func">to</tt></b> <b> <tt class="func">n</tt></b>etwork<b> <tt class="func">s</tt></b>hort</td>
</tr>

<tr> <td valign="top" align="left"><a name="indexId434909-265"></a> <b> <tt class="func">htonl()</tt></b></td>
<td valign="top" align="left"><b> <tt class="func">h</tt></b>ost<b> <tt class="func">to</tt></b> <b> <tt class="func">n</tt></b>etwork<b> <tt class="func">l</tt></b>ong</td>
</tr>

<tr> <td valign="top" align="left"><a name="indexId434909-266"></a> <b> <tt class="func">ntohs()</tt></b></td>
<td valign="top" align="left"><b> <tt class="func">n</tt></b>etwork<b> <tt class="func">to</tt></b> <b> <tt class="func">h</tt></b>ost<b> <tt class="func">s</tt></b>hort</td>
</tr>

<tr> <td valign="top" align="left"><a name="indexId434909-267"></a> <b> <tt class="func">ntohl()</tt></b></td>
<td valign="top" align="left"><b> <tt class="func">n</tt></b>etwork<b> <tt class="func">to</tt></b> <b> <tt class="func">h</tt></b>ost<b> <tt class="func">l</tt></b>ong</td>
</tr>

</table></center>



<h3 class="sect2title">Valor de retorno</h3>

<p> Cada função retorna o valor convertido.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">uint32_t some_long = 10;
uint16_t some_short = 20;

uint32_t network_byte_order;

// converter e enviar
network_byte_order = htonl(some_long);
send(s, &amp;network_byte_order, sizeof(uint32_t), 0);

some_short == ntohs(htons(some_short)); // esta expressão é verdadeira</pre>




<hr class="mainsectbreak"/>
<h2 class="sect1title">9.13. <a name="inet_ntoaman"><b> <tt class="titlefunc">inet_ntoa()</tt></b>, <b> <tt class="titlefunc">inet_aton()</tt></b>,
<b> <tt class="titlefunc">inet_addr</tt></b></a></h2>

<p> Converte endereços IP a partir de uma sequência de pontos-e-números em uma
<nobr><tt class="type">struct in_addr</tt></nobr> e de voltar</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

// TODOS ESTAS SÃO DESACONSELHADAS! Use inet_pton() ou inet_ntop() no lugar de!!

char *inet_ntoa(struct in_addr <i><tt class="var em1">in</tt></i>);
int inet_aton(const char *<i><tt class="var em1">cp</tt></i>, struct in_addr *<i><tt class="var em1">inp</tt></i>);
in_addr_t inet_addr(const char *<i><tt class="var em1">cp</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <i>Estas funções são obsoletas porque não lidam com IPv6!
Use <b> <tt class="func">inet_ntop()</tt></b> ou <b> <tt class="func">inet_pton()</tt></b> em vez disso! Elas
estão incluídas aqui porque ainda podem ser encontradas na natureza.</i></p>

<p> <a name="indexId434909-268"></a> <a name="indexId434909-269"></a> <a name="indexId434909-270"></a>
Todas essas funções convertem de uma <nobr> <tt class="type">struct in_addr</tt></nobr> (parte
de sua <nobr> <tt class="type">struct sockaddr_in</tt></nobr>, o mais provável) para uma string no
formato de pontos-e-números (por exemplo, "192.168.5.10") e vice-versa. Se você
tem um endereço IP passado na linha de comando ou algo assim, esta é a
maneira mais fácil de obter uma <nobr> <tt class="type">struct in_addr</tt></nobr> para
<b> <tt class="func">connect()</tt></b>, ou qualquer outra coisa. Se você precisar de mais energia, tente
algumas das funções do DNS, como <b> <tt class="func">gethostbyname()</tt></b> ou tente um
<i>golpe de estado</i> em seu país local.</p>

<p> A função <b><tt class="func">inet_ntoa()</tt></b> converte um endereço de rede numa
<nobr> <tt class="type">struct in_addr</tt></nobr> para uma sequencia de formato pontos-e-números. O
"n" em "ntoa" significa network, e o "a" significa ASCII por
razões históricas (então isso é "Network To ASCII"—o sufixo "toa"
tem um amigo análogo na biblioteca C chamada <b> <tt class="func">atoi()</tt></b>
que converte uma cadeia de caracteres ASCII em um número inteiro.)</p>

<p> A função <b><tt class="func">inet_aton()</tt></b> é o oposto, convertendo
de uma string de pontos-e-números em uma <nobr> <tt class="type">in_addr_t</tt></nobr> (que é
o tipo do campo <nobr> <tt class="type">s_addr</tt></nobr> na <nobr><tt class="type">struct
in_addr</tt></nobr>.)</p>

<p> Finalmente, a função <b><tt class="func">inet_addr()</tt></b> é uma função antiga
que faz basicamente a mesma coisa que <b> <tt class="func">inet_aton()</tt></b>. Está
teoricamente obsoleta, mas você a verá muito e a polícia não virá buscá-lo se você a usar.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> <b> <tt class="func">inet_aton()</tt></b> retorna diferente de zero se o endereço for válido, e retorna zero se o endereço for inválido.</p>

<p> <b> <tt class="func">inet_ntoa()</tt></b> retorna a sequencia de pontos-e-números em um
buffer estático que é sobrescrito a cada chamada para a função.</p>

<p> <b> <tt class="func">inet_addr()</tt></b> retorna o endereço como um
<nobr> <tt class="type">in_addr_t</tt>,</nobr> ou <tt class="const">-1</tt> se houver um erro. (Que
é o mesmo resultado como se você tentasse converter a sequencia <a name="indexId434909-271"></a> "255.255.255.255", que é um endereço IP válido.
É por isso que <b> <tt class="func">inet_aton()</tt></b> é melhor.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">struct sockaddr_in antelope;
char *some_addr;

inet_aton("10.0.0.1", &amp;antelope.sin_addr); // armazenar IP em antelope

some_addr = inet_ntoa(antelope.sin_addr); // retorna o IP
printf("%s\n", some_addr); // prints "10.0.0.1"

// e esta chamada é a mesma que a chamada inet_aton(), acima:
antelope.sin_addr.s_addr = inet_addr("10.0.0.1");</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#inet_ntopman"><b> <tt class="func">inet_ntop()</tt></b></a>,
<a href="#inet_ntopman"><b> <tt class="func">inet_pton()</tt></b></a>,
<a href="#gethostbynameman"><b> <tt class="func">gethostbyname()</tt></b></a>,
<a href="#gethostbynameman"><b> <tt class="func">gethostbyaddr()</tt></b></a></p>


<hr class="mainsectbreak"/>
<h2 class="sect1title">9.14. <a name="inet_ntopman"><b> <tt class="titlefunc">inet_ntop()</tt></b>, <b><tt class="titlefunc">inet_pton()</tt></b></a></h2>

<p> Converter endereços IP para forma humana legível e de volta.</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;arpa/inet.h&gt;

const char *inet_ntop(int af, const void *src,
                      char *dst, socklen_t size);

int inet_pton(int af, const char *src, void *dst);</pre>


<h3 class="sect2title">Descrição</h3>

<p> Essas funções são para lidar com endereços IP legíveis
convertendo-os em sua representação binária para uso com várias
funções e chamadas de sistema. O "n" significa "network" e "p" para
"presentation". Ou "text presentation". Mas você pode pensar nisso como
"impressão". "ntop" é "rede para impressão". Vê?</p>

<p> Às vezes você não quer olhar para uma pilha de números binários ao
olhar para um endereço IP. Você quer isso em uma boa forma para impressão, como
<tt class="tt">192.0.2.180</tt> ou <tt class="tt">2001:db8:8714:3a90::12</tt>. Nesse caso,
<b> <tt class="func">inet_ntop()</tt></b> é para você.</p>

<p> <b> <tt class="func">inet_ntop()</tt></b> usa a família de endereços no parâmetro
<i><tt class="var">af</tt></i> (ou <tt class="const">AF_INET</tt> ou
<tt class="const">AF_INET6</tt>). O parâmetro <i><tt class="var">src</tt></i> deve ser um
ponteiro para uma <nobr> <tt class="type">struct in_addr</tt></nobr> ou <nobr> <tt class="type">struct
in6_addr</tt></nobr> contendo o endereço que você deseja converter para uma string.
Finalmente <i><tt class="var">dst</tt></i> e <i><tt class="var">size</tt></i> são o ponteiro para
a string destino e o comprimento máximo dessa string.</p>

<p> Qual deve ser o comprimento máximo da string <i><tt class="var">dst</tt></i>?
Qual é o comprimento máximo para endereços IPv4 e IPv6? Felizmente
há um par de macros para ajudá-lo. Os comprimentos máximos são:
<tt class="const">INET_ADDRSTRLEN</tt> e <tt class="const">INET6_ADDRSTRLEN</tt>.</p>

<p> Outras vezes, você pode ter uma string contendo um endereço IP em
formato legível, e você quer embalá-lo em uma <nobr> <tt class="type">struct
sockaddr_in</tt></nobr> ou <nobr> <tt class="type">struct sockaddr_in6</tt></nobr>. Nesse caso,
a função oposta <b> <tt class="func">inet_pton()</tt></b> é o que você está procurando.</p>

<p> <b> <tt class="func">inet_pton()</tt></b> também usa uma família de endereços (ou
<tt class="const">AF_INET</tt> ou <tt class="const">AF_INET6</tt>) no parâmetro
<i><tt class="var">af</tt></i>. O parâmetro <i><tt class="var">src</tt></i> é um
ponteiro para uma string contendo o endereço IP no formato imprimível. Por fim
o parâmetro <i><tt class="var">dst</tt></i> aponta para onde o resultado deve ser
armazenado, que é provavelmente uma <nobr> <tt class="type">struct in_addr</tt></nobr> ou <nobr> <tt class="type">struct
in6_addr</tt></nobr>.</p>

<p> Estas funções não fazem pesquisas de DNS—você
precisará da função <b> <tt class="func">getaddrinfo()</tt></b> para isso.</p>



<h3 class="sect2title">Valor de retorno</h3>

<p> <b> <tt class="func">inet_ntop()</tt></b> retorna o parâmetro <i><tt class="var">dst</tt></i> em
sucesso, ou <tt class="const">NULL</tt> em caso de falha (e <i><tt class="var">errno</tt></i> é
definido).</p>

<p> <b> <tt class="func">inet_pton()</tt></b> retorna <tt class="const">1</tt> em caso de sucesso. Isto
retorna <tt class="const">-1</tt> se houver erro (<i><tt class="var">errno</tt></i> é
definido), ou <tt class="const">0</tt> se a entrada não é um endereço IP válido.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// demonstração IPv4 de inet_ntop() e inet_pton()

struct sockaddr_in sa;
char str[INET_ADDRSTRLEN];

// armazena esse endereço IP em sa:
inet_pton(AF_INET, "192.0.2.33", &amp;(sa.sin_addr));

// agora recupere e imprima
inet_ntop(AF_INET, &amp;(sa.sin_addr), str, INET_ADDRSTRLEN);

printf("%s\n", str); // imprime "192.0.2.33"</pre>

<pre class="code">// demonstração IPv6 de inet_ntop() e inet_pton()
// (basicamente o mesmo, exceto por ter um monte de 6s ao redor)

struct sockaddr_in6 sa;
char str[INET6_ADDRSTRLEN];

// armazena esse endereço IP em sa:
inet_pton(AF_INET6, "2001:db8:8714:3a90::12", &amp;(sa.sin6_addr));

// agora recupere e imprima
inet_ntop(AF_INET6, &amp;(sa.sin6_addr), str, INET6_ADDRSTRLEN);

printf("%s\n", str); // imprima "2001:db8:8714:3a90::12"</pre>



<pre class="code">// Função de ajuda que você pode usar:

//Converte um endereço de uma struct sockaddr para uma string, IPv4 e IPv6:

char *get_ip_str(const struct sockaddr *sa, char *s, size_t maxlen)
{
    switch(sa-&gt;sa_family) {
        case AF_INET:
            inet_ntop(AF_INET, &amp;(((struct sockaddr_in *)sa)-&gt;sin_addr),
                    s, maxlen);
            break;

        case AF_INET6:
            inet_ntop(AF_INET6, &amp;(((struct sockaddr_in6 *)sa)-&gt;sin6_addr),
                    s, maxlen);
            break;

        default:
            strncpy(s, "Unknown AF", maxlen);
            return NULL;
    }

    return s;
}</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#getaddrinfoman"><b> <tt class="func">getaddrinfo()</tt></b></a></p>




<hr class="mainsectbreak"/>
<h2 class="sect1title">9.15. <a name="listenman"><b> <tt class="titlefunc">listen()</tt></b></a></h2>

<p> Informar um socket para ouvir conexões de entrada</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/socket.h&gt;

int listen(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">backlog</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-272"></a> Você pode obter o seu descritor de socket (feito com
a chamada de sistema <b> <tt class="func">socket()</tt></b>) e dizer-lhe para ouvir
conexões de entrada. Isto é o que diferencia os servidores dos clientes, pessoal.</p>

<p> O parâmetro <i><tt class="var">backlog</tt></i> pode significar algumas coisas diferentes
dependendo do sistema em que você está, mas vagamente é quantas conexões pendentes
você pode ter antes que o kernel comece a rejeitar as novas.
Assim quem as novas conexões entram, você deve ser rápido para
aceitá-las com <b> <tt class="func">accept()</tt></b> para que backlog não seja alcançado. Experimente
o definir com 10 ou mais, e seus clientes começarão a receber "Connection
refused" sob carga pesada, configure-o maior.</p>

<p> Antes de chamar <b> <tt class="func">listen()</tt></b>, o servidor deve chamar
<b> <tt class="func">bind()</tt></b> para se conectar a um número de porta específico. Esse número de
porta (no endereço IP do servidor) será aquele ao qual os clientes se conectam.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p> retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b> <tt class="func">errno</tt></b> será definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// Primeiro, carregue as estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 ou IPv6, o que for
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // preencha meu IP para mim

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// crie o socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind  na porta em que passamos a getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

listen(sockfd, 10); // configura s para ser um socket do servidor (que escuta)

// então tem um loop accept() aqui em algum lugar</pre>


<h3 class="sect2title">Consulte também</h3>

<p> <a href="#acceptman"><b> <tt class="func">accept()</tt></b></a>,
<a href="#bindman"><b> <tt class="func">bind()</tt></b></a>,
<a href="#socketman"><b> <tt class="func">socket()</tt></b></a></p>


<hr class="mainsectbreak"/>
<h2 class="sect1title">9.16. <a name="perrorman"><b> <tt class="titlefunc">perror()</tt></b>, <b><tt class="titlefunc">strerror()</tt></b></a></h2>

<p> Imprimir um erro como uma string legível por humanos</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;   // for strerror()

void perror(const char *<i><tt class="var em1">s</tt></i>);
char *strerror(int <i><tt class="var em1">errnum</tt></i>);</pre>


<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-273"></a> <a name="indexId434909-274"></a> Uma vez que tantas funções
retornam <tt class="const">-1</tt> em caso de erro e definem o valor da variável <a name="indexId434909-275"></a> <i><tt class="var">errno</tt></i> como algum número, certamente seria bom
se você pudesse facilmente imprimir isso em um formato que fizesse sentido para você.</p>

<p> Felizmente, <b><tt class="func">perror()</tt></b> faz isso. Se você quiser que mais
descrições sejam impressas antes do erro, você pode apontar o parâmetro
<i><tt class="var">s</tt></i> para ela (ou você pode deixar <i><tt class="var">s</tt></i> como <tt class="const">NULL</tt>
e nada adicional será impresso.)</p>

<p> Em poucas palavras, esta função toma valores de <i><tt class="var">errno</tt></i>, como
<tt class="const">ECONNRESET</tt>, e os imprime bem, como "Connection reset by peer."</p>

<p> A função <b> <tt class="func">strerror()</tt></b> é muito semelhante a
<b> <tt class="func">perror()</tt></b>, exceto que retorna um ponteiro para a string da mensagem de erro
para um determinado valor (você geralmente passa na variável <i><tt class="var">errno</tt></i>.)</p>



<h3 class="sect2title">Valor de retorno</h3>

<p> <b> <tt class="func">strerror()</tt></b> retorna um ponteiro para a string da mensagem de erro.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int s;

s = socket(PF_INET, SOCK_STREAM, 0);

if (s == -1) { // algum erro ocorreu
    // imprime "erro de socket:" + a mensagem de erro:
    perror("socket error");
}

// similarmente:
if (listen(s, 10) == -1) {
    // isto imprime "um erro:" + a mensagem de erro do errno:
    printf("an error: %s\n", strerror(errno));
}</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#errnoman"><i><tt class="var">errno</tt></i></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.17. <a name="pollman"><b> <tt class="titlefunc">poll()</tt></b></a></h2>

<p>Teste para eventos em múltiplos sockets simultaneamente</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/poll.h&gt;

int poll(struct pollfd *<i><tt class="var em1">ufds</tt></i>, unsigned int <i><tt class="var em1">nfds</tt></i>, int <i><tt class="var em1">timeout</tt></i>);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-276"></a> Esta função é muito semelhante a
<b> <tt class="func">select()</tt></b> porque ambas monitoram eventos em conjuntos de descritores de arquivos, 
tais como dados de entrada prontos para <b> <tt class="func">recv()</tt></b>, sockets
prontos para enviar dados com <b> <tt class="func">send()</tt></b>, dados out-of-band prontos para
<b> <tt class="func">recv()</tt></b>, erros, etc.</p>

<p> A idéia básica é que você passe um array de <i><tt class="var">nfds</tt></i>
<nobr> <tt class="type">struct pollfd</tt></nobr>s em <i><tt class="var">ufds</tt></i>, juntamente com um tempo limite em
milissegundos (1000 milissegundos por segundo.) O <i><tt class="var">timeout</tt></i>
pode ser negativo se você quiser esperar para sempre. Se nenhum evento acontece em qualquer
dos descritores de socket pelo até timeout, <b> <tt class="func">poll()</tt></b>
retornará.</p>

<p> Cada elemento no array de <nobr><tt class="type">struct pollfd</tt></nobr> representa
um descritor de socket e contém os seguintes campos:</p>

<pre class="code"><a name="indexId434909-277"></a>struct pollfd {
    int fd;         // o descritor de socket
    short events;   // bitmap de eventos nos quais estamos interessados
    short revents;  // Quando poll() retorna, bitmap de eventos que ocorreram
};</pre>


<p> Antes de chamar <b><tt class="func">poll()</tt></b>, carregue <i><tt class="var">fd</tt></i> com o
descritor de socket (se você definir <i><tt class="var">fd</tt></i> para um número negativo, esta
<nobr><tt class="type">struct pollfd</tt></nobr> será ignorada e seu campo <i><tt class="var">revents</tt></i>
será definido para zero) e, em seguida, constroi-se o campo <i><tt class="var">events</tt></i> por
bitwise-ORing nas seguintes macros:</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="25%%"><tt class="const">POLLIN</tt></td>

<td valign="top" align="left" width = "73%%">Avise-me quando os dados estiverem prontos para
<b> <tt class="func">recv()</tt></b> neste socket.</td>
</tr>


<tr> <td valign="top" align="left"><tt class="const">POLLOUT</tt></td>

<td valign="top" align="left">Avise-me quando eu puder enviar dados com <b> <tt class="func">send()</tt></b> para este socket sem blocking.</td>
</tr>


<tr> <td valign="top" align="left"><tt class="const">POLLPRI</tt></td>

<td valign="top" align="left">Avise-me quando os dados out-of-band estiverem prontos para
<b> <tt class="func">recv()</tt></b> neste socket.</td>
</tr>

</table></center>
 
<p> Uma vez que a chamada <b><tt class="func">poll()</tt></b> retorna, o campo <i><tt class="var">revents</tt></i>
será construído como bitwise-OR nos campos acima, dizendo
a você em quais descritores realmente o evento ocorreu. Além disso,
esses outros campos podem estar presentes:</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="25%%"><tt class="const">POLLERR</tt></td>

<td valign="top" align="left" width = "73%%">Ocorreu um erro neste socket.</td>
</tr>


<tr> <td valign="top" align="left"><tt class="const">POLLHUP</tt></td>

<td valign="top" align="left">O lado remoto da conexão foi desligado.</td>
</tr>


<tr> <td valign="top" align="left"><tt class="const">POLLNVAL</tt></td>

<td valign="top" align="left">Algo estava errado com o descritor de socket
<i><tt class="var">fd</tt></i>—Talvez não esteja inicializado?</td>
</tr>

</table></center>

<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna o número de elementos em que ocorreram eventos no array <i><tt class="var">ufds</tt></i>; isso pode ser zero se timeout foi alcançado. Além disso
retorna <tt class="const">-1</tt> em caso de erro (e <b> <tt class="func">errno</tt></b> será definido
em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int s1, s2;
int rv;
char buf1[256], buf2[256];
struct pollfd ufds[2];

s1 = socket(PF_INET, SOCK_STREAM, 0);
s2 = socket(PF_INET, SOCK_STREAM, 0);

// fingir que nós conectamos ambos a um servidor neste momento
//connect(s1, ...)...
//connect(s2, ...)...

// configurar o array de descritores de arquivos.
//
// neste exemplo, queremos saber quando há normal ou out-of-band
// dados prontos para recv()...

ufds[0].fd = s1;
ufds[0].events = POLLIN | POLLPRI; // checar por normal ou out-of-band

ufds[1].fd = s2;
ufds[1].events = POLLIN; // verifique apenas os dados normais

// espera por eventos nos sockets, tempo limite de 3,5 segundos
rv = poll(ufds, 2, 3500);

if (rv == -1) {
    perror("poll"); // ocorreu erro em poll()
} else if (rv == 0) {
    printf("Timeout ocorreu!  Nenhum dado após 3.5 segundos.\n");
} else {
    // checar por eventos em s1:
    if (ufds[0].revents &amp; POLLIN) {
        recv(s1, buf1, sizeof buf1, 0); // recebe dados normais
    }
    if (ufds[0].revents &amp; POLLPRI) {
        recv(s1, buf1, sizeof buf1, MSG_OOB); // dados out-of-band
    }

    // checar por eventos s2:
    if (ufds[1].revents &amp; POLLIN) {
        recv(s1, buf2, sizeof buf2, 0);
    }
}</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#selectman"><b> <tt class="func">select()</tt></b></a></p>

<hr class="mainsectbreak"/>
<h2 class="sect1title">9.18. <a name="recvman"><b> <tt class="titlefunc">recv()</tt></b>, <b><tt class="titlefunc">recvfrom()</tt></b></a></h2>

<p> Recebe dados em um socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t recv(int s, void *<i><tt class="var em1">buf</tt></i>, size_t <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">flags</tt></i>);
ssize_t recvfrom(int <i><tt class="var em1">s</tt></i>, void *<i><tt class="var em1">buf</tt></i>, size_t <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">flags</tt></i>,
                 struct sockaddr *<i><tt class="var em1">from</tt></i>, socklen_t *<i><tt class="var em1">fromlen</tt></i>);</pre>

<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-278"></a> <a name="indexId434909-279"></a> Uma vez que você tenha um socket ativo e
conectado, poderá ler dados de entrada vindos do lado remoto usando a
<b><tt class="func">recv()</tt></b> (para sockets TCP <a name="indexId434909-280"></a> <tt class="const">SOCK_STREAM</tt>) e
<b><tt class="func">recvfrom()</tt></b> (para sockets UDP <a name="indexId434909-281"></a> <tt class="const">SOCK_DGRAM</tt>).</p>

<p> Ambas as funções usam o descritor de socket <i><tt class="var">s</tt></i>, um ponteiro para o 
buffer <i><tt class="var">buf</tt></i>, o tamanho (em bytes) do buffer
<i><tt class="var">len</tt></i>, e um conjunto de <i><tt class="var">flags</tt></i> que controlam como as
funções funcionam.</p>

<p> Além disso, a <b><tt class="func">recvfrom()</tt></b> recebe uma
<a name="indexId434909-282"></a> <nobr> <tt class="type">struct sockaddr *</tt></nobr>,
<i><tt class="var">from</tt></i> que lhe dirá de onde os dados vieram, e preencherá
<i><tt class="var">fromlen</tt></i> com o tamanho da <nobr><tt class="type">struct
sockaddr</tt></nobr>. (Você também deve inicializar <i><tt class="var">fromlen</tt></i> para ser
do tamanho de <i><tt class="var">from</tt></i> ou <nobr> <tt class="type">struct sockaddr</tt></nobr>.)</p>

<p> Então, que flags maravilhosas você pode passar para essa função? Aqui estão
algumas delas, mas você deve verificar suas páginas man locais para obter mais
informação sobre o que é realmente suportado em seu sistema. Você pode fazer operações
bitwise-or com elas, ou apenas definir <i><tt class="var">flags</tt></i> para
<tt class="const">0</tt> se você quer que ela seja uma
<b><tt class="func">recv()</tt></b> regular.</p>

<center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr><td valign="top" align="left" width="30%%"><a name="indexId434909-283"></a><tt class="const">MSG_OOB</tt></td>

<td valign="top" align="left" width="68%%"><a name="indexId434909-284"></a>Recebe dados Out of Band.
Esta é a forma como obter dados que foram enviados para você com a flag
<tt class="const">MSG_OOB</tt> em <b><tt class="func">send()</tt></b>. Como receptor, 
você terá o sinal <a name="indexId434909-285"></a><tt class="const">SIGURG</tt>
levantado informando que há dados urgentes. No seu manipulador para esse
sinal, você poderia chamar <b><tt class="func">recv()</tt></b> com essa flag
<tt class="const">MSG_OOB</tt>.</td>
</tr>


<tr><td valign="top" align="left"><a name="indexId434909-286"></a><tt class="const">MSG_PEEK</tt></td>

<td valign="top" align="left">Se você quiser chamar <b><tt class="func">recv()</tt></b> "apenas para fingir", 
você pode chamá-la com esta flag. Isso lhe dirá o que estará lhe esperando no buffer quando você chamar <b><tt class="func">recv()</tt></b> "realmente"
(ou seja <i>sem</i> a flag <tt class="const">MSG_PEEK</tt>. É como uma
pré-visualização para a próxima chamada <b><tt class="func">recv()</tt></b>.</td>
</tr>


<tr><td valign="top" align="left"><a name="indexId434909-287"></a><tt class="const">MSG_WAITALL</tt></td>

<td valign="top" align="left">Diga a <b><tt class="func">recv()</tt></b> para não retornar até que todos os dados especificados no parâmetro
<i><tt class="var">len</tt></i>. Ele irá ignorar seus
desejos em circunstâncias extremas, no entanto, como se um sinal interrompesse
a chamada ou se algum erro ocorresse ou se o lado remoto fechasse a
conexão, etc. Não fique bravo com isso.</td>
</tr>


</table></center>

<p> Quando você chama <b> <tt class="func">recv()</tt></b>, ele irá bloquear até que haja alguns
dados para ler. Se você quiser para não blocking, defina o socket para non-blocking
ou verifique com <b> <tt class="func">select()</tt></b> ou <b><tt class="func">poll()</tt></b> para ver se
há dados de entrada antes de chamar <b> <tt class="func">recv()</tt></b> ou
<b><tt class="func">recvfrom()</tt></b>.</p>



<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna o número de bytes realmente recebidos (que pode ser menos
do que você solicitou no parâmetro <i><tt class="var">len</tt></i>), ou <tt class="const">-1</tt>
em caso de erro (e <b><tt class="func">errno</tt></b> definido em conformidade.)</p>

<p> Se o lado remoto fechar a conexão, <b><tt class="func">recv()</tt></b>
retornará <tt class="const">0</tt>. Este é o método normal para a determinar
se o lado remoto fechou a conexão. A normalidade é boa,
rebelde!</p>



<h3 class="sect2title">Exemplo</h3>

<pre class="code">// stream sockets e recv()

struct addrinfo hints, *res;
int sockfd;
char buf[512];
int byte_count;

// obter informações do host, criar o socket e conectá-lo
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 ou IPv6, o que for
hints.ai_socktype = SOCK_STREAM;
getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

// Tudo certo! agora que estamos conectados, podemos receber alguns dados!
byte_count = recv(sockfd, buf, sizeof buf, 0);
printf("recv()'d %d bytes of data in buf\n", byte_count);
</pre>

<pre class="code">// datagram sockets e recvfrom()

struct addrinfo hints, *res;
int sockfd;
int byte_count;
socklen_t fromlen;
struct sockaddr_storage addr;
char buf[512];
char ipstr[INET6_ADDRSTRLEN];

// obter informações do host, criar socket, bind para a porta 4950
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 ou IPv6, o que for
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
getaddrinfo(NULL, "4950", &amp;hints, &amp;res);
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

// não precisa de accept(), apenas recvfrom():

fromlen = sizeof addr;
byte_count = recvfrom(sockfd, buf, sizeof buf, 0, &amp;addr, &amp;fromlen);

printf("recv()'d %d bytes of data in buf\n", byte_count);
printf("from IP address %s\n",
    inet_ntop(addr.ss_family,
        addr.ss_family == AF_INET?
            ((struct sockaddr_in *)&amp;addr)-&gt;sin_addr:
            ((struct sockaddr_in6 *)&amp;addr)-&gt;sin6_addr,
        ipstr, sizeof ipstr);

</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#sendman"><b> <tt class="func">send()</tt></b></a>,
<a href="#sendman"><b> <tt class="func">sendto()</tt></b></a>,
<a href="#selectman"><b> <tt class="func">select()</tt></b></a>,
<a href="#pollman"><b> <tt class="func">poll()</tt></b></a>,
<a href="#blocking">Blocking</a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.19. <a name="selectman"><b> <tt class="titlefunc">select()</tt></b></a></h2>

<p> Verifica se os descritores de sockets estão prontos para leitura/escrita</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/select.h&gt;

int select(int <i><tt class="var em1">n</tt></i>, fd_set *<i><tt class="var em1">readfds</tt></i>, fd_set *<i><tt class="var em1">writefds</tt></i>, fd_set *<i><tt class="var em1">exceptfds</tt></i>,
           struct timeval *<i><tt class="var em1">timeout</tt></i>);

FD_SET(int <i><tt class="var em1">fd</tt></i>, fd_set *<i><tt class="var em1">set</tt></i>);
FD_CLR(int <i><tt class="var em1">fd</tt></i>, fd_set *<i><tt class="var em1">set</tt></i>);
FD_ISSET(int <i><tt class="var em1">fd</tt></i>, fd_set *<i><tt class="var em1">set</tt></i>);
FD_ZERO(fd_set *<i><tt class="var em1">set</tt></i>);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-288"></a> A função <b> <tt class="func">select()</tt></b> fornece a você uma
maneira de verificar simultaneamente vários sockets para ver se eles têm dados
esperando para serem lidos com <b> <tt class="func">recv()</tt></b>, ou se você pode enviar com <b><tt class="func">send()</tt></b>
dados a eles sem blocking, ou se alguma exceção ocorreu.</p>

<p> Você preenche seus sets de descritores de sockets usando as macros, como
<b> <tt class="func">FD_SET()</tt></b>, acima. Uma vez que você tenha o set, você passa-o para
a função como um dos seguintes parâmetros: <i><tt class="var">readfds</tt></i> se
você quiser saber quando qualquer um dos sockets no set está pronto para receber dados com
<b> <tt class="func">recv()</tt></b>, <i><tt class="var">writefds</tt></i> se qualquer um dos sockets estiver
pronto para enviar dados com <b><tt class="func">send()</tt></b>, e/ou <i><tt class="var">exceptfds</tt></i> se você
precisa saber quando uma exceção (erro) ocorre em qualquer um dos sockets.
Qualquer um ou todos estes parâmetros podem ser <tt class="const">NULL</tt> se você não estiver
interessado nesses tipos de eventos. Após o retorno de <b> <tt class="func">select()</tt></b>,
os valores nos sets serão alterados para mostrar quais estão prontos
para leitura ou escrita, e quais possuem exceções.</p>

<p> O primeiro parâmetro, <i><tt class="var">n</tt></i> é o descritor de socket com a numeração mais alta
(eles são apenas <nobr><tt class="type">int</tt></nobr>s, lembra?) mais um.</p>

<p> Por fim, a <a name="indexId434909-289"></a> <nobr> <tt class="type">struct timeval</tt></nobr>,
<i><tt class="var">timeout</tt></i>, no final—isso permite que você informe a
<b> <tt class="func">select()</tt></b> por quanto tempo verificar esses sets. Ela retornará após o timeout
ou quando um evento ocorrer, o que ocorrer primeiro. A estrutura <nobr><tt class="type">struct timeval</tt></nobr> possui dois campos: <i><tt class="var">tv_sec</tt></i> é o
número de segundos, ao qual é adicionado <i><tt class="var">tv_usec</tt></i>, o número de
microssegundos (1.000.000 microssegundos em um segundo.)</p>

<p> As macros auxiliares fazem o seguinte:</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="50%%"><a name="indexId434909-290"></a> <b> <tt class="func" > FD_SET(int fd, fd_set *set);</tt></b></td>

<td valign="top" align="left" width = "48%%">Adicionar <i><tt class="var">fd</tt></i> ao <i><tt class="var">set</tt></i>.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-291"></a> <b> <tt class="func">FD_CLR(int fd, fd_set *set);</tt></b></td>

<td valign="top" align="left">Remover <i><tt class="var">fd</tt></i> do <i><tt class="var">set</tt></i>.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-292"></a> <b> <tt class="func">FD_ISSET(int fd, fd_set *set);</tt></b></td>

<td valign="top" align="left">Retorna true se <i><tt class="var">fd</tt></i> está no
<i><tt class="var">set</tt></i>.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-293"></a> <b> <tt class="func">FD_ZERO (fd_set * conjunto) ;</tt></b></td>

<td valign="top" align="left">Limpar todas as entradas do <i><tt class="var">set</tt></i>.</td>
</tr>

</table></center>

<p> Nota para usuários do Linux: O <b><tt class="func">select()</tt></b> do Linux pode retornar
"pronto-para-ler" e, em seguida, na verdade não estar pronto para ler, fazendo com que a
chamada subsequente a <b><tt class="func">read()</tt></b> gere blocking. Você pode contornar este
problema definindo <a name="indexId434909-294"></a> a flag <tt class="const">O_NONBLOCK</tt> no
socket receptor para que ele gere um erro com <tt class="const">EWOULDBLOCK</tt>, em seguida,
ignore-o se este erro ocorrer. Veja a man page <a href="#fcntlman"><b> <tt class="func">fcntl()</tt></b></a> para mais informações
sobre como configurar um socket para non-blocking.</p>



<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna o número de descritores no set em caso de sucesso,
<tt class="const">0</tt> se o tempo limite foi atingido, ou <tt class="const">-1</tt> em caso
de erro (e <b> <tt class="func">errno</tt></b> será definido em conformidade.) Além disso, os sets
são modificados para mostrar quais sockets estão prontos.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int s1, s2, n;
fd_set readfds;
struct timeval tv;
char buf1[256], buf2[256];

// fingir que nós conectamos ambos a um servidor neste momento
//s1 = socket(...);
//s2 = socket(...);
//connect(s1, ...)...
//connect(s2, ...)...

// limpar o set antes do tempo
FD_ZERO(&amp;readfds);

// adicione nossos descritores ao set
FD_SET(s1, &amp;readfds);
FD_SET(s2, &amp;readfds);

// desde que temos s2 segundos, é o "maior", então usamos isso para
// o parâmetro n em select()
n = s2 + 1;

// espere até que qualquer socket tenha dados prontos para recv() (timeout 10.5 secs)
tv.tv_sec = 10;
tv.tv_usec = 500000;
rv = select(n, &amp;readfds, NULL, NULL, &amp;tv);

if (rv == -1) {
    perror("select"); // erro ocorreu em select()
} else if (rv == 0) {
    printf("Timeout ocorreu! Sem dados após 10.5 segundos.\n");
} else {
    // um ou ambos os descritores têm dados
    if (FD_ISSET(s1, &amp;readfds)) {
        recv(s1, buf1, sizeof buf1, 0);
    }
    if (FD_ISSET(s2, &amp;readfds)) {
        recv(s2, buf2, sizeof buf2, 0);
    }
}</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#pollman"><b> <tt class="func">poll()</tt></b></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.20. <a name="setsockoptman"><b><tt class="titlefunc">setsockopt()</tt></b>, <b><tt class="titlefunc">getsockopt()</tt></b></a></h2>

<p>Ajusta várias opções para um socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int getsockopt(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">level</tt></i>, int <i><tt class="var em1">optname</tt></i>, void *<i><tt class="var em1">optval</tt></i>,
               socklen_t *<i><tt class="var em1">optlen</tt></i>);
int setsockopt(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">level</tt></i>, int <i><tt class="var em1">optname</tt></i>, const void *<i><tt class="var em1">optval</tt></i>,
               socklen_t <i><tt class="var em1">optlen</tt></i>);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-295"></a> <a name="indexId434909-296"></a> Sockets são completamente
configuráveis. Na verdade, eles são tão configuráveis que nem mesmo
cobrirei tudo aqui. Provavelmente é dependente do sistema, de qualquer maneira. Mas
vou falar sobre o básico.</p>

<p> Obviamente, essas funções obtêm e definem determinadas opções em um socket.
Em um ambiente Linux, todas as informações sobre sockets estão na página man de socket
na seção 7. (Digite: "<b class="com">man 7 socket</b>" para obter todas estas guloseimas.)</p>

<p> Quanto aos parâmetros, <i><tt class="var">s</tt></i> é o socket em questão,
level deve ser definido como <a name="indexId434909-297"></a><tt class="const">SOL_SOCKET</tt>.
Em seguida, defina <i><tt class="var">optname</tt></i> para o nome que você está interessado.
Novamente, veja sua página man para todas as opções, mas aqui estão algumas das mais divertidas:</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="30%%"><a name="indexId434909-298"></a><tt class="const">SO_BINDTODEVICE</tt></td>

<td valign="top" align="left" width="68%%">Vincula este socket a um nome de dispositivo simbólico como
<tt class="tt">eth0</tt> em vez de usar <b><tt class="func">bind()</tt></b> para vinculá-lo a um endereço IP.
Digite o comando <b class="com">ifconfig</b> em Unix para ver o nomes dos dispositivos.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-299"></a> <tt class="const">SO_REUSEADDR</tt></td>

<td valign="top" align="left">Permite que outros sockets façam <b><tt class="func">bind()</tt></b> contra esta porta, a menos
que haja um socket de escuta ativo já ligado à porta. Isso
permite que você contorne as mensagens de erro "Endereço já em uso" ao tentar reiniciar o servidor após uma falha.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-300"></a> <tt class="const">SO_BROADCAST</tt></td>

<td valign="top" align="left">Permite que sockets UDP datagram (<a name="indexId434909-301"></a> <tt class="const">SOCK_DGRAM</tt>) enviem e recebam pacotes para e do
endereço de broadcast. Não faz nada—<i>NADA!!</i>—para sockets TCP stream! Hahaha!</td>
</tr>
</table></center>

<p> Quanto ao parâmetro <i><tt class="var">optval</tt></i>, geralmente é um ponteiro para um
<nobr><tt class="type">int</tt></nobr> indicando o valor em questão. Para booleanos, zero
é falso, e diferente de zero é verdade. E isso é um fato absoluto, a menos
que seja diferente em seu sistema. Se não houver um parâmetro a ser passado,
<i><tt class="var">optval</tt></i> pode ser <tt class="const">NULL</tt>.</p>

<p> O parâmetro final, <i><tt class="var">optlen</tt></i>, deve ser definido para o comprimento
de <i><tt class="var">optval</tt></i>, provavelmente <tt class="tt">sizeof (int)</tt>, mas varia
dependendo da opção. Observe que, no caso de <b><tt class="func">getsockopt()</tt></b>, esse é um ponteiro para um
<nobr><tt class="type">socklen_t</tt></nobr>, e especifica o objeto de tamanho máximo que
será armazenado em <i><tt class="var">optval</tt></i> (para evitar buffer overflows). E
<b><tt class="func">getsockopt()</tt></b> irá modificar o valor de <i><tt class="var">optlen</tt></i> para
refletir o número de bytes realmente definidos.</p>

<p> <b>Aviso</b>: em alguns sistemas (nomeadamente <a name="indexId434909-302"></a> <a name="indexId434909-303"></a> Sun e <a name="indexId434909-304"></a> Windows), a option
pode ser um <nobr> <tt class="type">char</tt></nobr> em vez de um <nobr><tt class="type">int</tt></nobr>, e é definida
como, por exemplo, um valor de caractere <tt class="tt">'1'</tt> em vez de um valor
<nobr><tt class="type">int</tt></nobr> <tt class="const">1</tt>. Mais uma vez, verifique as suas próprias man
pages para obter mais informações como: "<b class="com">man setsockopt</b>" e "<b class="com">man 7 socket</b>"!</p>

<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> será definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int optval;
int optlen;
char *optval2;

// define SO_REUSEADDR em um socket para true (1):
optval = 1;
setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof optval);

// ligar um socket a um nome de dispositivo (pode não funcionar em todos os sistemas):
optval2 = "eth1"; // 4 bytes de comprimento, então 4, abaixo:
setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, 4);

// veja se a flag SO_BROADCAST está definida:
getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);
if (optval != 0) {
    print("SO_BROADCAST ativado em s3!\n");
}</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#fcntlman"><b> <tt class="func">fcntl()</tt></b></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.21. <a name="sendman"><b> <tt class="titlefunc">send()</tt></b>, <b><tt class="titlefunc">sendto()</tt></b></a></h2>

<p> Envia dados através de um socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int s, const void *buf, size_t len, int flags);
ssize_t sendto(int s, const void *buf, size_t len,
               int flags, const struct sockaddr *to,
               socklen_t tolen);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-305"></a> <a name="indexId434909-306"></a> Estas funções enviam dados para um
socket. De um modo geral, <b><tt class="func">send()</tt></b> é usada para sockets TCP <a name="indexId434909-307"></a> <tt class="const">SOCK_STREAM</tt> conectados, e
<b><tt class="func">sendto()</tt></b> é utilizada para sockets datagram UDP <a name="indexId434909-308"></a> <tt class="const">SOCK_DGRAM</tt> desconectados.
Com os sockets não conectados, você deve especificar o destino
de um pacote toda vez que você enviar um, e é por isso que os últimos parâmetros
de <b><tt class="func">sendto()</tt></b> definem para onde o pacote irá.</p>

<p> Com <b><tt class="func">send()</tt></b> e <b><tt class="func">sendto()</tt></b>, o
parâmetro <i><tt class="var">s</tt></i> é o socket, <i><tt class="var">buf</tt></i> é um ponteiro para
os dados que você deseja enviar, <i><tt class="var">len</tt></i> é o número de bytes que você deseja
enviar e <i><tt class="var">flags</tt></i> permite que você especifique mais informações sobre
como os dados devem ser enviados. Defina <i><tt class="var">flags</tt></i> para zero se você quiser que sejam
dados "normais". Aqui estão algumas das flags comumente usadas, mas
verifique as suas man pages locais de <b><tt class="func">send()</tt></b> para mais detalhes:</p>

<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="30%%"><a name="indexId434909-309"></a> <tt class="const">MSG_OOB</tt></td>
 <td valign="top" align="left" width="68%%">Enviar dados
como <a name="indexId434909-310"></a> "out of band". TCP suporta isso,
e é uma maneira de informar ao sistema receptor que esses dados têm uma maior
prioridade que os dados normais. O receptor receberá o sinal
<a name="indexId434909-311"></a> <tt class="const">SIGURG</tt> e poderá receber esses dados sem antes
receber todos os demais dados normais da fila.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-312"></a> <tt class="const">MSG_DONTROUTE</tt></td>

<td valign="top" align="left">Não envie esses dados através de um roteador, apenas mantenha-os
localmente.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-313"></a> <tt class="const">MSG_DONTWAIT</tt></td>

<td valign="top" align="left">Se <b><tt class="func">send()</tt></b> bloquear porque o tráfego de saída
está obstruído, faça-o retornar <a name="indexId434909-314"></a> <tt class="const">EAGAIN</tt>. Isto é como um "ativar <a name="indexId434909-315"></a> non-blocking somente para este send." Veja a
seção sobre <a href="#blocking">blocking</a> para obter mais detalhes.</td>
</tr>


<tr> <td valign="top" align="left"><a name="indexId434909-316"></a> <tt class="const">MSG_NOSIGNAL</tt></td>

<td valign="top" align="left">Se você enviar com <b><tt class="func">send()</tt></b> a um host remoto que já não
esta executando <b><tt class="func">recv()</tt></b>, você normalmente obterá o sinal <a name="indexId434909-317"></a> <tt class="const">SIGPIPE</tt>. A adição desta flag impede que o
sinal se levante.</td>
</tr>


</table></center>


<h3 class="sect2title">Valor de retorno</h3>

<p> Retorna o número de bytes realmente enviados ou <tt class="const">-1</tt> em caso de
erro (e <b><tt class="func">errno</tt></b> será definido em conformidade.). Observe que o
número de bytes realmente enviados pode ser menor que o número que você pediu para
enviar! Veja a seção sobre <a href="#sendall">manipulando <b><tt class="func">send()</tt></b>s parcialmente</a> para uma função auxiliar para contornar este problema.</p>

<p> Além disso, se o socket for fechado por qualquer um dos lados, o processo que
chamar <b> <tt class="func">send()</tt></b> obterá o sinal <tt class="const">SIGPIPE</tt>.
(A menos que <b><tt class="func">send()</tt></b> tenha sido chamado com a flag <tt class="const">MSG_NOSIGNAL</tt>.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int spatula_count = 3490;
char *secret_message = "The Cheese is in The Toaster";

int stream_socket, dgram_socket;
struct sockaddr_in dest;
int temp;

// primeiro com sockets TCP stream:

// assumir que sockets estão criados e conectados
//stream_socket = socket(...
//connect(stream_socket, ...

// converter para network byte order
temp = htonl(spatula_count);
// envia dados com send normalmente:
send(stream_socket, &amp;temp, sizeof temp, 0);

// envia mensagem secreta out of band:
send(stream_socket, secret_message, strlen(secret_message)+1, MSG_OOB);

// agora com sockets UDP datagram:
//getaddrinfo(...
//dest = ...  // assuma que "dest" contém o endereço do destino
//dgram_socket = socket(...

// envia mensagem secreta normalmente:
sendto(dgram_socket, secret_message, strlen(secret_message)+1, 0, 
       (struct sockaddr*)&amp;dest, sizeof dest);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#recvman"><b> <tt class="func">recv()</tt></b></a>,
<a href="#recvman"><b> <tt class="func">recvfrom()</tt></b></a></p>



<hr class="mainsectbreak"/>
<h2 class="sect1title">9.22. <a name="shutdownman"><b> <tt class="titlefunc">shutdown()</tt></b></a></h2>

<p>Para de enviar e ou receber em um socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/socket.h&gt;

int shutdown(int s, int how);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-318"></a>É isso aí! Nós temos isso! Se não quero mais permitir
<b><tt class="func">send()</tt></b>s no socket, mas eu ainda quero receber dados com
<b><tt class="func">recv()</tt></b> por ele! Ou vice-versa! Como posso fazer isso?</p>

<p> Quando você fecha um descritor de socket com <b><tt class="func">close()</tt></b>, ele fecha ambos
os lados do socket para leitura e escrita, e libera o descritor de socket. Se você quiser apenas para fechar um lado ou outro, você pode
usar esta chamada <b><tt class="func">shutdown()</tt></b>.</p>

<p> Quanto aos parâmetros, <i><tt class="var">s</tt></i> é, obviamente, o socket no qual você quer
executar esta ação, e a ação escolhida e que possa ser especificada estará no
parâmetro <i><tt class="var">how</tt></i>. How pode ser <tt class="const">SHUT_RD</tt> para
evitar mais <b><tt class="func">recv()</tt></b>s, <tt class="const">SHUT_WR</tt> para proibir
mais <b><tt class="func">send()</tt></b>s, ou <tt class="const">SHUT_RDWR</tt> para ambos.</p>

<p> Note que <b><tt class="func">shutdown()</tt></b> não libera o descritor de socket, então você ainda tem que fechar o socket com <b><tt class="func">close()</tt></b>, mesmo que tenha sido completamente desligado.</p>

<p> Esta é uma chamada de sistema raramente usada.</p>


<h3 class="sect2title">Valor de retorno</h3>

<p>Retorna zero em caso de sucesso, ou <tt class="const">-1</tt> em caso de erro (e
<b><tt class="func">errno</tt></b> será definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">int s = socket(PF_INET, SOCK_STREAM, 0);

// ...faça algum send() e coisas aqui...

// e agora que terminamos, não permita mais send()s:
shutdown(s, SHUT_WR);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#closeman"><b> <tt class="func">close()</tt></b></a></p>



<hr class="mainsectbreak" />
<h2 class="sect1title">9.23. <a name="socketman"><b> <tt class="titlefunc">socket()</tt></b></a></h2>

<p> Aloca um descritor de socket</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);</pre>



<h3 class="sect2title">Descrição</h3>

<p> <a name="indexId434909-319"></a> Retorna um novo descritor de socket com o qual você pode
fazer coisas de socket. Esta é geralmente a primeira chamada no
processo enorme de escrever um programa com sockets, e você pode usar o resultado
nas chamadas subsequentes como <b><tt class="func">listen()</tt></b>, <tt class="tt">bind()</tt>,
<tt class="tt">accept()</tt>, ou uma variedade de outras funções.</p>

<p> No uso normal, você obtém os valores para esses parâmetros de uma chamada
<b><tt class="func">getaddrinfo()</tt></b>, como é mostrado no exemplo abaixo. Mas você
pode preenchê-los à mão se você realmente quiser.</p>


<center> <table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tr> <td valign="top" align="left" width="20%%"><i><tt class="var">domain</tt></i></td>


<td valign="top" align="left" width="78%%"><i><tt class="var">domain</tt></i> descreve em que tipo de socket
você está interessado. Isso pode, acredite, ser uma grande variedade de
coisas, mas uma vez que este é um guia sobre sockets, ele será <a name="indexId434909-320"></a> <tt class="const">PF_INET</tt> para IPv4 e
<tt class="const">PF_INET6</tt> para o IPv6.</td>
</tr>


<tr> <td valign="top" align="left"><i><tt class="var">type</tt></i></td>


<td valign="top" align="left">Além disso, o parâmetro <i><tt class="var">type</tt></i> pode ser uma série de coisas,
mas você provavelmente o configurará como <a name="indexId434909-321"></a> <tt class="const">SOCK_STREAM</tt> para sockets TPC <a name="indexId434909-322"></a> (<b><tt class="func">send()</tt></b>, <b><tt class="func">recv()</tt></b>) ou <a name="indexId434909-323"></a> <tt class="const">SOCK_DGRAM</tt> para rápidos e não confiáveis sockets UDP <a name="indexId434909-324"></a> (<b><tt class="func">sendto()</tt></b>,
<b><tt class="func">recvfrom()</tt></b>.)

<p> (Outro tipo de socket interessante é <a name="indexId434909-325"></a> <tt class="const">SOCK_RAW</tt>, que pode ser usado para construir
pacotes manualmente. É bem legal.)</p></td>
</tr>


<tr> <td valign="top" align="left"><i><tt class="var">protocol</tt></i></td>


<td valign="top" align="left">Finalmente, o parâmetro <i><tt class="var">protocol</tt></i> informa qual protocolo
usar com um determinado tipo de socket. Como eu já disse, por exemplo,
<tt class="const">SOCK_STREAM</tt> usa TCP. Felizmente para você, ao usar
<tt class="const">SOCK_STREAM</tt> ou <tt class="const">SOCK_DGRAM</tt>, você pode apenas
definir o protocolo como 0, e ele usará o protocolo apropriado automaticamente.
Caso contrário, você pode usar <a name="indexId434909-326"></a> <b> <tt class="func">getprotobyname()</tt></b> para procurar o
número de protocolo correto.</td>


</tr>
</table></center>


<h3 class="sect2title">Valor de retorno</h3>

<p> O novo descritor de socket para ser usado em chamadas subsequentes, ou
<tt class="const">-1</tt> em caso de erro (e <b> <tt class="func">errno</tt></b> será definido em conformidade.)</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// Primeiro, carregue as estruturas de endereço com getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;     // AF_INET, AF_INET6, ou AF_UNSPEC
hints.ai_socktype = SOCK_STREAM; // SOCK_STREAM ou SOCK_DGRAM

getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);

// crie um socket usando as informações obtidas com getaddrinfo():
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#acceptman"><b> <tt class="func">accept()</tt></b></a>,
<a href="#bindman"><b> <tt class="func">bind()</tt></b></a>,
<a href="#getaddrinfoman"><b> <tt class="func">getaddrinfo()</tt></b></a>,
<a href="#listenman"><b> <tt class="func">listen()</tt></b></a></p>




<hr class="mainsectbreak"/>
<h2 class="sect1title">9.24. <a name="sockaddr_inman"><nobr> <b> <tt class="titletype">struct sockaddr</tt></b></nobr> e companhia</a></h2>

<p> Estruturas para a manipulação de endereços de internet</p>

<h3 class="sect2title">Protótipos</h3>

<pre class="code">#include &lt;netinet/in.h&gt;

// Todos os ponteiros para estruturas de endereços de socket são frequentemente convertidos em ponteiros
// para este tipo antes de usar em várias funções e chamadas de sistema:

struct sockaddr {
    unsigned short    <i><tt class="var em1">sa_family</tt></i>;    // família de endereço, AF_xxx
    char              <i><tt class="var em1">sa_data</tt></i>[14];  // 14 bytes do endereço do protocolo
};


// sockets IPv4 AF_INET:

struct sockaddr_in {
    short            <i><tt class="var em1">sin_family</tt></i>;   // exem: AF_INET, AF_INET6
    unsigned short   <i><tt class="var em1">sin_port</tt></i>;     // exem: htons(3490)
    struct in_addr   <i><tt class="var em1">sin_addr</tt></i>;     // veja struct in_addr, abaixo
    char             <i><tt class="var em1">sin_zero</tt></i>[8];  // zere isso se você quiser
};

struct in_addr {
    unsigned long <i><tt class="var em1">s_addr</tt></i>;          // carregar com inet_pton()
};


// sockets IPv6 AF_INET6:

struct sockaddr_in6 {
    u_int16_t       <i><tt class="var em1">sin6_family</tt></i>;   // família de endereço, AF_INET6
    u_int16_t       <i><tt class="var em1">sin6_port</tt></i>;     // número da porta, Network Byte Order
    u_int32_t       <i><tt class="var em1">sin6_flowinfo</tt></i>; // informação de fluxo IPv6
    struct in6_addr <i><tt class="var em1">sin6_addr</tt></i>;     // endereço IPv6
    u_int32_t       <i><tt class="var em1">sin6_scope_id</tt></i>; // ID do escopo
};

struct in6_addr {
    unsigned char   <i><tt class="var em1">s6_addr[16]</tt></i>;   // carregar com inet_pton()
};


// Estrutura geral de retenção de endereços de sockets, grande o suficiente para segurar
// dados struct sockaddr_in ou struct sockaddr_in6:

struct sockaddr_storage {
    sa_family_t  <i><tt class="var em1">ss_family</tt></i>;     // família de endereço

    // tudo isso é preenchimento, implementação específica, ignore-os:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};</pre>


<h3 class="sect2title">Descrição</h3>


<p> <a name="indexId434909-327"></a> <a name="indexId434909-328"></a> Estas são as
estruturas básicas para todas as syscalls e funções que lidam com endereços da internet.
Muitas vezes você usará <b> <tt class="func">getaddrinfo()</tt></b> para preencher estas
estruturas, e, em seguida, você a lerá quando for necessário.</p>

<p> Na memória, a <nobr><tt class="type">struct sockaddr_in</tt></nobr> e a <nobr><tt class="type">struct
sockaddr_in6</tt></nobr> partilham a mesma estrutura inicial que <a name="indexId434909-329"></a> <nobr> <tt class="type">struct sockaddr</tt></nobr>, e você pode livremente
converter o ponteiro de um tipo para outro, sem qualquer dano, exceto o possível fim do universo.</p>

<p> Estou apenas brincando na parte do fim-do-universo... se o universo terminar,
quando você tentar um cast de <nobr> <tt class="type">struct sockaddr_in*</tt></nobr> para uma <nobr><tt class="type">struct
sockaddr*</tt></nobr>, eu prometo a você que é pura coincidência e você não deveria nem se preocupar com isso.</p>

<p> Então, com isso em mente, lembre-se que sempre que uma função disser que
é necessária uma <nobr><tt class="type">struct sockaddr*</tt></nobr> você pode realizar um cast com a sua <nobr><tt class="type">struct
sockaddr_in*</tt></nobr>, <nobr><tt class="type">struct sockaddr_in6*</tt></nobr> ou <nobr><tt class="type">struct
sockaddr_storage*</tt></nobr> para aquele tipo com facilidade e segurança.</p>

<p> <nobr><tt class="type">struct sockaddr_in</tt></nobr> é a estrutura utilizada com
endereços IPv4 (por exemplo, "192.0.2.10"). Ela mantém uma família de endereços
(<tt class="const">AF_INET</tt>), uma porta em <i><tt class="var">sin_port</tt></i>, e um endereço IPv4
em <i><tt class="var">sin_addr</tt></i>.</p>

<p> Há também este campo <nobr><tt class="type">sin_zero</tt></nobr> em <nobr><tt class="type">struct
sockaddr_in</tt></nobr>, que algumas pessoas afirmam que deve ser definido para zero. Outras pessoas
não afirmam nada sobre isso (a documentação Linux nem sequer menciona isso), e defini-lo como zero não parece ser
realmente necessário. Então, se você quiser, defina-o para zero usando <b><tt class="func">memset()</tt></b>.</p>

<p> Agora, essa <nobr><tt class="type">struct in_addr</tt></nobr> é uma besta estranha em diferentes
sistemas. Às vezes é uma <tt class="tt">union louca</tt> com todos os tipos de
<tt class="tt">#define</tt>s e outras bobagens. Mas o que você deve fazer é usar apenas o
campo <i><tt class="var">s_addr</tt></i> nessa estrutura, porque muitos sistemas
só implementam esse.</p>

<p><nobr><tt class="type">struct sockaddr_in6</tt></nobr> e <nobr><tt class="type">struct in6_addr</tt></nobr> são
muito semelhantes, exceto que elas são usadas ​​para IPv6.</p>

<p><nobr><tt class="type">struct sockaddr_storage</tt></nobr> é uma struct que você pode passar para
<b><tt class="func">accept()</tt></b> ou <b><tt class="func">recvfrom()</tt></b> quando estiver tentando
escrever um código independente de versão IP e não souber se o novo endereço será
IPv4 ou IPv6. A estrutura <nobr><tt class="type">struct sockaddr_storage</tt></nobr> é grande o suficiente para conter os dois tipos, ao contrário da pequena
<nobr><tt class="type">struct sockaddr</tt></nobr> original.</p>


<h3 class="sect2title">Exemplo</h3>

<pre class="code">// IPv4:

struct sockaddr_in ip4addr;
int s;

ip4addr.sin_family = AF_INET;
ip4addr.sin_port = htons(3490);
inet_pton(AF_INET, "10.0.0.1", &amp;ip4addr.sin_addr);

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;ip4addr, sizeof ip4addr);</pre>

<pre class="code">// IPv6:

struct sockaddr_in6 ip6addr;
int s;

ip6addr.sin6_family = AF_INET6;
ip6addr.sin6_port = htons(4950);
inet_pton(AF_INET6, "2001:db8:8714:3a90::12", &amp;ip6addr.sin6_addr);

s = socket(PF_INET6, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;ip6addr, sizeof ip6addr);</pre>



<h3 class="sect2title">Consulte também</h3>

<p> <a href="#acceptman"><b> <tt class="func">accept()</tt></b></a>,
<a href="#bindman"><b> <tt class="func">bind()</tt></b></a>,
<a href="#connectman"><b> <tt class="func">connect()</tt></b></a>,
<a href="#inet_ntoaman"><b> <tt class="func">inet_aton()</tt></b></a>,
<a href="#inet_ntoaman"><b> <tt class="func">inet_ntoa()</tt></b></a></p>



<hr class="mainsectbreak"/> <h2 class="sect1title">10. <a name="reference">Mais Referências</a></h2> <hr class="mainsecthr"/>


<p> Você chegou até aqui, e agora está gritando por mais! Onde
mais você pode ir para aprender mais sobre tudo isso?</p>



<h3 class="sect2title">10.1. <a name="books">Livros</a></h3>


<p> <a name="indexId434909-330"></a> <a name="indexId434909-331"></a> Para um livro de papel de celulose, old-school,
segure-isso-em-suas-mãos, experimente alguns dos seguintes
excelentes livros. Eu costumava ser filiado a um vendedor de livros muito popular na internet,
mas o seu novo sistema de rastreamento de clientes é incompatível com
um documento impresso. Como tal, eu não consigo mais comissões. Se você sente
compaixão por minha difícil situação, faça uma doação via PayPal para
<tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>. <tt>:-)</tt></p>



<p><i>Unix Network Programming, volumes 1-2</i> by W.
Richard Stevens.  Published by Prentice Hall.  ISBNs for volumes 1-2:
<a href="http://beej.us/guide/url/unixnet1" target="_blank">0131411551</a>,
<a href="http://beej.us/guide/url/unixnet2" target="_blank">0130810819</a>.
</p>


<p><i>Internetworking with TCP/IP, volumes I-III</i> by
Douglas E. Comer and David L. Stevens.  Published by Prentice Hall.
ISBNs for volumes I, II, and III:
<a href="http://beej.us/guide/url/intertcp1" target="_blank">0131876716</a>,
<a href="http://beej.us/guide/url/intertcp2" target="_blank">0130319961</a>,
<a href="http://beej.us/guide/url/intertcp3" target="_blank">0130320714</a>.
</p>


<p><i>TCP/IP Illustrated, volumes 1-3</i> by W.
Richard Stevens and Gary R. Wright.  Published by Addison Wesley.  ISBNs
for volumes 1, 2, and 3 (and a 3-volume set):
<a href="http://beej.us/guide/url/tcpi1" target="_blank">0201633469</a>,
<a href="http://beej.us/guide/url/tcpi2" target="_blank">020163354X</a>,
<a href="http://beej.us/guide/url/tcpi3" target="_blank">0201634953</a>,
(<a href="http://beej.us/guide/url/tcpi123" target="_blank">0201776316</a>).
</p>


<p><i>TCP/IP Network Administration</i> by Craig
Hunt.  Published by O'Reilly &amp; Associates, Inc.  ISBN
<a href="http://beej.us/guide/url/tcpna" target="_blank">0596002971</a>.
</p>


<p><i>Advanced Programming in the UNIX
Environment</i> by W. Richard Stevens.  Published by Addison
Wesley.  ISBN
<a href="http://beej.us/guide/url/advunix" target="_blank">0201433079</a>.
</p>



<h3 class="sect2title">10.2. <a name="webref">Web Referências</a></h3>


<p> <a name="indexId434909-332"></a> Na web:</p>


<p><i><a href="http://www.cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html" target="_blank">BSD Sockets: A Quick And
Dirty Primer</a></i> (Informações de programação dos sistemas Unix, também!)</p>


<p><i><a href="http://www.developerweb.net/forum/forumdisplay.php?f=70" target="_blank">The Unix Socket
FAQ</a></i></p>


<p><i><a href="http://pclt.cis.yale.edu/pclt/COMM/TCPIP.HTM" target="_blank">Intro to
TCP/IP</a></i></p>


<p><i><a href="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/" target="_blank">TCP/IP
FAQ</a></i></p>


<p><i><a href="http://tangentsoft.net/wskfaq/" target="_blank">The Winsock
FAQ</a></i></p>



<p>E aqui estão algumas páginas relevantes na Wikipédia:</p>



<p><i><a href="http://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank">Berkeley
Sockets</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Internet_Protocol" target="_blank">Internet Protocol
(IP)</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank">Transmission Control Protocol
(TCP)</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank">User Datagram Protocol
(UDP)</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Client-server" target="_blank">Client-Server</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Serialization" target="_blank">Serialization</a></i> (empacotando e desempacotando dados)</p>




<h3 class="sect2title">10.3. <a name="rfcs">RFCs</a></h3>


<p> <a name="indexId434909-333"></a> <a href="http://www.rfc-editor.org/" target="_blank">RFCs</a>—a verdadeira
sujeira! Estes são documentos que descrevem números atribuídos, APIs de programação
e protocolos usados ​​na Internet. Eu incluí links
para alguns deles aqui para sua diversão, então pegue um balde de pipoca
e vista o sua capa do pensamento:</p>


<p> <i><a href="http://tools.ietf.org/html/rfc1" target="_blank">RFC 1</a></i>—O primeiro RFC;
Isso lhe dá uma idéia de como era a "Internet", assim como ela estava ganhando vida, e uma visão de como ela estava sendo projetada desde o
zero. (Esta RFC é completamente obsoleta, obviamente!)</p>


<p><a name="indexId434909-334"></a><i><a href="http://tools.ietf.org/html/rfc768" target="_blank">RFC 768</a></i>—The User
Datagram Protocol (UDP)</p>


<p><a name="indexId434909-335"></a><i><a href="http://tools.ietf.org/html/rfc791" target="_blank">RFC
791</a></i>—The Internet Protocol (IP)</p>


<p><a name="indexId434909-336"></a><i><a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC
793</a></i>—The Transmission Control Protocol
(TCP)</p>


<p><a name="indexId434909-337"></a><i><a href="http://tools.ietf.org/html/rfc854" target="_blank">RFC 854</a></i>—The Telnet
Protocol</p>


<p><a name="indexId434909-338"></a><i><a href="http://tools.ietf.org/html/rfc959" target="_blank">RFC 959</a></i>—File Transfer
Protocol (FTP)</p>


<p><a name="indexId434909-339"></a><i><a href="http://tools.ietf.org/html/rfc1350" target="_blank">RFC
1350</a></i>—The Trivial File Transfer Protocol
(TFTP)</p>


<p><a name="indexId434909-340"></a><i><a href="http://tools.ietf.org/html/rfc1459" target="_blank">RFC
1459</a></i>—Internet Relay Chat Protocol
(IRC)</p>


<p><i><a href="http://tools.ietf.org/html/rfc1918" target="_blank">RFC
1918</a></i>—Address Allocation for Private
Internets</p>


<p><a name="indexId434909-341"></a><i><a href="http://tools.ietf.org/html/rfc2131" target="_blank">RFC
2131</a></i>—Dynamic Host Configuration Protocol
(DHCP)</p>


<p><a name="indexId434909-342"></a><i><a href="http://tools.ietf.org/html/rfc2616" target="_blank">RFC
2616</a></i>—Hypertext Transfer Protocol
(HTTP)</p>


<p><a name="indexId434909-343"></a><i><a href="http://tools.ietf.org/html/rfc2821" target="_blank">RFC
2821</a></i>—Simple Mail Transfer Protocol
(SMTP)</p>


<p><i><a href="http://tools.ietf.org/html/rfc3330" target="_blank">RFC
3330</a></i>—Special-Use IPv4 Addresses</p>


<p><i><a href="http://tools.ietf.org/html/rfc3493" target="_blank">RFC
3493</a></i>—Basic Socket Interface Extensions for
IPv6</p>


<p><i><a href="http://tools.ietf.org/html/rfc3542" target="_blank">RFC
3542</a></i>—Advanced Sockets Application Program
Interface (API) for IPv6</p>


<p><i><a href="http://tools.ietf.org/html/rfc3849" target="_blank">RFC
3849</a></i>—IPv6 Address Prefix Reserved for
Documentation</p>


<p><a name="indexId434909-344"></a><i><a href="http://tools.ietf.org/html/rfc3920" target="_blank">RFC
3920</a></i>—Extensible Messaging and Presence Protocol
(XMPP)</p>


<p><a name="indexId434909-345"></a><i><a href="http://tools.ietf.org/html/rfc3977" target="_blank">RFC
3977</a></i>—Network News Transfer Protocol
(NNTP)</p>


<p><i><a href="http://tools.ietf.org/html/rfc4193" target="_blank">RFC
4193</a></i>—Unique Local IPv6 Unicast
Addresses</p>


<p><a name="indexId434909-346"></a><i><a href="http://tools.ietf.org/html/rfc4506" target="_blank">RFC
4506</a></i>—External Data Representation Standard
(XDR)</p>




<p>O IETF tem uma boa ferramenta online para <a href="http://tools.ietf.org/rfc/" target="_blank">pesquisar e navegar entre RFCs</a>.</p>


<hr class="mainsectbreak"><h2 class="sect1title">Índice<a name="zindex"></a></h2><a name="zindex">
<hr class="mainsecthr">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.x.x.x:</a><a href="#indexId434909-85">3.4.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;192.168.x.x: <a href="#indexId434909-86">3.4.1</a><br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255.255.255.255: <a href="#indexId434909-176">7.6</a>, <a href="#indexId434909-271">9.13</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">accept()</tt></b>: <a href="#indexId434909-109">5.5</a>, <a href="#indexId434909-111">5.6</a>, <a href="#indexId434909-223">9.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Endereço já em uso: <a href="#indexId434909-100">5.3</a>, <a href="#indexId434909-183">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">AF_INET</tt>: <a href="#indexId434909-70">3.3</a>, <a href="#indexId434909-93">5.2</a>, <a href="#indexId434909-208">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">AF_INET6</tt>: <a href="#indexId434909-71">3.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E/S assíncrona: <a href="#indexId434909-257">9.11</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bapper: <a href="#indexId434909-180">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">bind()</tt></b>: <a href="#indexId434909-94">5.3</a>, <a href="#indexId434909-186">8.0</a>, <a href="#indexId434909-229">9.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implicito: <a href="#indexId434909-103">5.3</a>, <a href="#indexId434909-107">5.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blá-blá-blá: <a href="#indexId434909-56">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blocking: <a href="#indexId434909-142">7.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;livros: <a href="#indexId434909-330">10.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;broadcast: <a href="#indexId434909-173">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordenação de bytes: <a href="#indexId434909-61">3.2</a>, <a href="#indexId434909-73">3.3</a>, <a href="#indexId434909-167">7.4</a>, <a href="#indexId434909-263">9.12</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cliente: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datagram: <a href="#indexId434909-140">6.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream: <a href="#indexId434909-137">6.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client/server: <a href="#indexId434909-132">6.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">close()</tt></b>: <a href="#indexId434909-120">5.9</a>, <a href="#indexId434909-234">9.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">closesocket()</tt></b>: <a href="#indexId434909-11">1.5</a>, <a href="#indexId434909-124">5.9</a>, <a href="#indexId434909-238">9.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compiladores: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">gcc</b>: <a href="#indexId434909-2">1.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compressão: <a href="#indexId434909-206">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">connect()</tt></b>: <a href="#indexId434909-37">2.1</a>, <a href="#indexId434909-97">5.3</a>, <a href="#indexId434909-104">5.3</a>, <a href="#indexId434909-105">5.4</a>, <a href="#indexId434909-232">9.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;em sockets datagram: <a href="#indexId434909-119">5.8</a>, <a href="#indexId434909-141">6.3</a>, <a href="#indexId434909-233">9.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conexão recusada: <a href="#indexId434909-138">6.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">CreateProcess()</tt></b>: <a href="#indexId434909-16">1.5</a>, <a href="#indexId434909-212">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">CreateThread()</tt></b>: <a href="#indexId434909-17">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">CSocket</tt></nobr>: <a href="#indexId434909-13">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cygwin: <a href="#indexId434909-7">1.5</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encapsulamento de dados: <a href="#indexId434909-46">2.2</a>, <a href="#indexId434909-162">7.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DHCP: <a href="#indexId434909-341">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rede desconectada: veja rede privada.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DNS: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;domain name service: veja DNS.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;burros: <a href="#indexId434909-161">7.3</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">EAGAIN</tt>: <a href="#indexId434909-145">7.1</a>, <a href="#indexId434909-147">7.1</a>, <a href="#indexId434909-314">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;email para Beej: <a href="#indexId434909-18">1.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encriptação: <a href="#indexId434909-203">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">EPIPE</tt>: <a href="#indexId434909-236">9.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i><tt class="var">errno</tt></i>: <a href="#indexId434909-251">9.10</a>, <a href="#indexId434909-275">9.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ethernet: <a href="#indexId434909-52">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">EWOULDBLOCK</tt>: <a href="#indexId434909-146">7.1</a>, <a href="#indexId434909-148">7.1</a>, <a href="#indexId434909-228">9.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Excalibur: <a href="#indexId434909-171">7.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external data representation standard: veja XDR.<br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">F_SETFL</tt>: <a href="#indexId434909-255">9.11</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">fcntl()</tt></b>: <a href="#indexId434909-144">7.1</a>, <a href="#indexId434909-227">9.1</a>, <a href="#indexId434909-254">9.11</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_CLR()</tt></b>: <a href="#indexId434909-152">7.2</a>, <a href="#indexId434909-291">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_ISSET()</tt></b>: <a href="#indexId434909-153">7.2</a>, <a href="#indexId434909-292">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_SET()</tt></b>: <a href="#indexId434909-151">7.2</a>, <a href="#indexId434909-290">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_ZERO()</tt></b>: <a href="#indexId434909-154">7.2</a>, <a href="#indexId434909-293">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descritor de arquivo: <a href="#indexId434909-22">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firewall: <a href="#indexId434909-83">3.4.1</a>, <a href="#indexId434909-178">7.6</a>, <a href="#indexId434909-213">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fazendo furos em: <a href="#indexId434909-214">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rodapé: <a href="#indexId434909-48">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">fork()</tt></b>: <a href="#indexId434909-15">1.5</a>, <a href="#indexId434909-133">6.0</a>, <a href="#indexId434909-211">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FTP: <a href="#indexId434909-338">10.3</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getaddrinfo()</tt></b>: <a href="#indexId434909-68">3.3</a>, <a href="#indexId434909-89">4.0</a>, <a href="#indexId434909-91">5.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gethostbyaddr()</tt></b>: <a href="#indexId434909-128">5.10</a>, <a href="#indexId434909-243">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gethostbyname()</tt></b>: <a href="#indexId434909-130">5.11</a>, <a href="#indexId434909-240">9.6</a>, <a href="#indexId434909-242">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gethostname()</tt></b>: <a href="#indexId434909-129">5.11</a>, <a href="#indexId434909-239">9.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getnameinfo()</tt></b>: <a href="#indexId434909-90">4.0</a>, <a href="#indexId434909-127">5.10</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getpeername()</tt></b>: <a href="#indexId434909-125">5.10</a>, <a href="#indexId434909-248">9.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getprotobyname()</tt></b>: <a href="#indexId434909-326">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getsockopt()</tt></b>: <a href="#indexId434909-295">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gettimeofday()</tt></b>: <a href="#indexId434909-156">7.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cabra: <a href="#indexId434909-192">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="tt">goto</tt>: <a href="#indexId434909-199">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cabeçalhos: <a href="#indexId434909-47">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arquivos de cabeçalhos: <a href="#indexId434909-181">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">herror()</tt></b>: <a href="#indexId434909-246">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">hstrerror()</tt></b>: <a href="#indexId434909-247">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">htonl()</tt></b>: <a href="#indexId434909-63">3.2</a>, <a href="#indexId434909-260">9.12</a>, <a href="#indexId434909-265">9.12</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">htons()</tt></b>: <a href="#indexId434909-62">3.2</a>, <a href="#indexId434909-74">3.3</a>, <a href="#indexId434909-166">7.4</a>, <a href="#indexId434909-259">9.12</a>, <a href="#indexId434909-264">9.12</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP: <a href="#indexId434909-342">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protocolo HTTP: <a href="#indexId434909-40">2.1</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ICMP: <a href="#indexId434909-195">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IEEE-754: <a href="#indexId434909-168">7.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">INADDR_ANY</tt>: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">INADDR_BROADCAST</tt>: <a href="#indexId434909-177">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_addr()</tt></b>: <a href="#indexId434909-78">3.4</a>, <a href="#indexId434909-270">9.13</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_aton()</tt></b>: <a href="#indexId434909-79">3.4</a>, <a href="#indexId434909-269">9.13</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_ntoa()</tt></b>: <a href="#indexId434909-81">3.4</a>, <a href="#indexId434909-268">9.13</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_ntoa()</tt></b>: <a href="#indexId434909-80">3.4</a>, <a href="#indexId434909-126">5.10</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_pton()</tt></b>: <a href="#indexId434909-77">3.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internet Control Message Protocol: veja ICMP.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internet protocol: veja IP.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internet Relay Chat: veja IRC.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioctl(): <a href="#indexId434909-217">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP: <a href="#indexId434909-42">2.1</a>, <a href="#indexId434909-51">2.2</a>, <a href="#indexId434909-57">3.0</a>, <a href="#indexId434909-76">3.4</a>, <a href="#indexId434909-98">5.3</a>, <a href="#indexId434909-115">5.8</a>, <a href="#indexId434909-131">5.11</a>, <a href="#indexId434909-335">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP address: <a href="#indexId434909-230">9.2</a>, <a href="#indexId434909-241">9.6</a>, <a href="#indexId434909-244">9.7</a>, <a href="#indexId434909-249">9.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IPv4: <a href="#indexId434909-58">3.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IPv6: <a href="#indexId434909-60">3.1</a>, <a href="#indexId434909-75">3.3</a>, <a href="#indexId434909-87">3.4.1</a>, <a href="#indexId434909-88">4.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRC: <a href="#indexId434909-165">7.4</a>, <a href="#indexId434909-340">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISO/OSI: <a href="#indexId434909-53">2.2</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modelo de rede em camadas: veja ISO/OSI.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux: <a href="#indexId434909-6">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">listen()</tt></b>: <a href="#indexId434909-96">5.3</a>, <a href="#indexId434909-108">5.5</a>, <a href="#indexId434909-272">9.15</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backlog: <a href="#indexId434909-110">5.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com select(): <a href="#indexId434909-158">7.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="tt">lo</tt>: veja dispositivo de loopback.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localhost: <a href="#indexId434909-193">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispositivo de loopback: <a href="#indexId434909-191">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">man</b> pages: <a href="#indexId434909-222">9.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum Transmission Unit: veja MTU.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirroring: <a href="#indexId434909-19">1.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_DONTROUTE</tt>: <a href="#indexId434909-312">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_DONTWAIT</tt>: <a href="#indexId434909-313">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_NOSIGNAL</tt>: <a href="#indexId434909-316">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_OOB</tt>: <a href="#indexId434909-283">9.18</a>, <a href="#indexId434909-309">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_PEEK</tt>: <a href="#indexId434909-286">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_WAITALL</tt>: <a href="#indexId434909-287">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MTU: <a href="#indexId434909-210">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAT: <a href="#indexId434909-84">3.4.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">netstat</b>: <a href="#indexId434909-188">8.0</a>, <a href="#indexId434909-190">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network address translation: veja NAT.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NNTP: <a href="#indexId434909-345">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sockets non-blocking: <a href="#indexId434909-143">7.1</a>, <a href="#indexId434909-163">7.3</a>, <a href="#indexId434909-226">9.1</a>, <a href="#indexId434909-256">9.11</a>, <a href="#indexId434909-294">9.19</a>, <a href="#indexId434909-315">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">ntohl()</tt></b>: <a href="#indexId434909-65">3.2</a>, <a href="#indexId434909-262">9.12</a>, <a href="#indexId434909-267">9.12</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">ntohs()</tt></b>: <a href="#indexId434909-64">3.2</a>, <a href="#indexId434909-261">9.12</a>, <a href="#indexId434909-266">9.12</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">O_ASYNC</tt>: veja E/S assíncrona.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">O_NONBLOCK</tt>: veja sockets non-blocking.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenSSL: <a href="#indexId434909-205">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dados out-of-band: <a href="#indexId434909-284">9.18</a>, <a href="#indexId434909-310">9.21</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet sniffer: <a href="#indexId434909-215">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pat: <a href="#indexId434909-179">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">perror()</tt></b>: <a href="#indexId434909-252">9.10</a>, <a href="#indexId434909-273">9.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">PF_INET</tt>: <a href="#indexId434909-207">8.0</a>, <a href="#indexId434909-320">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ping: <a href="#indexId434909-194">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">poll()</tt></b>: <a href="#indexId434909-159">7.2</a>, <a href="#indexId434909-276">9.17</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;porta: <a href="#indexId434909-116">5.8</a>, <a href="#indexId434909-231">9.2</a>, <a href="#indexId434909-250">9.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;portas: <a href="#indexId434909-95">5.3</a>, <a href="#indexId434909-99">5.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rede privada: <a href="#indexId434909-82">3.4.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modo promíscuo: <a href="#indexId434909-216">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raw sockets: <a href="#indexId434909-33">2.1</a>, <a href="#indexId434909-196">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">read()</tt></b>: <a href="#indexId434909-27">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">recv()</tt></b>: <a href="#indexId434909-26">2.0</a>, <a href="#indexId434909-30">2.0</a>, <a href="#indexId434909-113">5.7</a>, <a href="#indexId434909-278">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: <a href="#indexId434909-200">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">recvfrom()</tt></b>: <a href="#indexId434909-117">5.8</a>, <a href="#indexId434909-279">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">recvtimeout()</tt></b>: <a href="#indexId434909-202">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;referências: <a href="#indexId434909-331">10.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Na web: <a href="#indexId434909-332">10.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RFCs: <a href="#indexId434909-333">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">route</b>: <a href="#indexId434909-189">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SA_RESTART</tt>: <a href="#indexId434909-198">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Secure Sockets Layer: veja SSL.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segurança: <a href="#indexId434909-209">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">select()</tt></b>: <a href="#indexId434909-12">1.5</a>, <a href="#indexId434909-149">7.1</a>, <a href="#indexId434909-150">7.2</a>, <a href="#indexId434909-187">8.0</a>, <a href="#indexId434909-201">8.0</a>, <a href="#indexId434909-288">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com listen(): <a href="#indexId434909-157">7.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">send()</tt></b>: <a href="#indexId434909-25">2.0</a>, <a href="#indexId434909-29">2.0</a>, <a href="#indexId434909-54">2.2</a>, <a href="#indexId434909-112">5.7</a>, <a href="#indexId434909-305">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">sendall()</tt></b>: <a href="#indexId434909-160">7.3</a>, <a href="#indexId434909-170">7.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">sendto()</tt></b>: <a href="#indexId434909-55">2.2</a>, <a href="#indexId434909-306">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialização: <a href="#indexId434909-164">7.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servidor: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datagram: <a href="#indexId434909-139">6.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream: <a href="#indexId434909-134">6.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">setsockopt()</tt></b>: <a href="#indexId434909-101">5.3</a>, <a href="#indexId434909-174">7.6</a>, <a href="#indexId434909-184">8.0</a>, <a href="#indexId434909-221">8.0</a>, <a href="#indexId434909-296">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">shutdown()</tt></b>: <a href="#indexId434909-121">5.9</a>, <a href="#indexId434909-318">9.22</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">sigaction()</tt></b>: <a href="#indexId434909-135">6.1</a>, <a href="#indexId434909-197">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SIGIO</tt>: <a href="#indexId434909-258">9.11</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SIGPIPE</tt>: <a href="#indexId434909-235">9.4</a>, <a href="#indexId434909-317">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SIGURG</tt>: <a href="#indexId434909-285">9.18</a>, <a href="#indexId434909-311">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMTP: <a href="#indexId434909-343">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_BINDTODEVICE</tt>: <a href="#indexId434909-298">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_BROADCAST</tt>: <a href="#indexId434909-175">7.6</a>, <a href="#indexId434909-300">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_RCVTIMEO</tt>: <a href="#indexId434909-219">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_REUSEADDR</tt>: <a href="#indexId434909-102">5.3</a>, <a href="#indexId434909-185">8.0</a>, <a href="#indexId434909-299">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_SNDTIMEO</tt>: <a href="#indexId434909-220">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SOCK_DGRAM</tt>: veja socket;datagram.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOCK_RAW: <a href="#indexId434909-325">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SOCK_STREAM</tt>: veja socket;stream.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket: <a href="#indexId434909-21">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datagram: <a href="#indexId434909-36">2.1</a>, <a href="#indexId434909-43">2.1</a>, <a href="#indexId434909-45">2.2</a>, <a href="#indexId434909-114">5.8</a>, <a href="#indexId434909-281">9.18</a>, <a href="#indexId434909-301">9.20</a>, <a href="#indexId434909-308">9.21</a>, <a href="#indexId434909-323">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raw: <a href="#indexId434909-34">2.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream: <a href="#indexId434909-35">2.1</a>, <a href="#indexId434909-38">2.1</a>, <a href="#indexId434909-224">9.1</a>, <a href="#indexId434909-280">9.18</a>, <a href="#indexId434909-307">9.21</a>, <a href="#indexId434909-321">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tipos: <a href="#indexId434909-31">2.0</a>, <a href="#indexId434909-32">2.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descritor de socket: <a href="#indexId434909-24">2.0</a>, <a href="#indexId434909-66">3.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">socket()</tt></b>: <a href="#indexId434909-23">2.0</a>, <a href="#indexId434909-92">5.2</a>, <a href="#indexId434909-319">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SOL_SOCKET</tt>: <a href="#indexId434909-297">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solaris: <a href="#indexId434909-3">1.4</a>, <a href="#indexId434909-303">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL: <a href="#indexId434909-204">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">strerror()</tt></b>: <a href="#indexId434909-253">9.10</a>, <a href="#indexId434909-274">9.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct addrinfo</tt></nobr>: <a href="#indexId434909-67">3.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct hostent</tt></nobr>: <a href="#indexId434909-245">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct in_addr</tt></nobr>: <a href="#indexId434909-328">9.24</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct pollfd</tt></nobr>: <a href="#indexId434909-277">9.17</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct sockaddr</tt></nobr>: <a href="#indexId434909-69">3.3</a>, <a href="#indexId434909-118">5.8</a>, <a href="#indexId434909-282">9.18</a>, <a href="#indexId434909-329">9.24</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct sockaddr_in</tt></nobr>: <a href="#indexId434909-72">3.3</a>, <a href="#indexId434909-225">9.1</a>, <a href="#indexId434909-327">9.24</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct timeval</tt></nobr>: <a href="#indexId434909-155">7.2</a>, <a href="#indexId434909-289">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SunOS: <a href="#indexId434909-4">1.4</a>, <a href="#indexId434909-302">9.20</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP: <a href="#indexId434909-41">2.1</a>, <a href="#indexId434909-322">9.23</a>, <a href="#indexId434909-336">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">gcc</b>: <a href="#indexId434909-39">2.1</a>, <a href="#indexId434909-337">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TFTP: <a href="#indexId434909-49">2.2</a>, <a href="#indexId434909-339">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout, configurando: <a href="#indexId434909-218">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traduções: <a href="#indexId434909-20">1.8</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transmission control protocol: veja TCP.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRON: <a href="#indexId434909-106">5.4</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UDP: <a href="#indexId434909-44">2.1</a>, <a href="#indexId434909-50">2.2</a>, <a href="#indexId434909-172">7.6</a>, <a href="#indexId434909-324">9.23</a>, <a href="#indexId434909-334">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user datagram protocol: veja UDP.<br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vint Cerf: <a href="#indexId434909-59">3.1</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows: <a href="#indexId434909-5">1.5</a>, <a href="#indexId434909-122">5.9</a>, <a href="#indexId434909-182">8.0</a>, <a href="#indexId434909-237">9.4</a>, <a href="#indexId434909-304">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Winsock: <a href="#indexId434909-8">1.5</a>, <a href="#indexId434909-123">5.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Winsock FAQ: <a href="#indexId434909-14">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">write()</tt></b>: <a href="#indexId434909-28">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">WSACleanup()</tt></b>: <a href="#indexId434909-10">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">WSAStartup()</tt></b>: <a href="#indexId434909-9">1.5</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDR: <a href="#indexId434909-169">7.4</a>, <a href="#indexId434909-346">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XMPP: <a href="#indexId434909-344">10.3</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processo zumbi: <a href="#indexId434909-136">6.1</a><br>
</p>


</body></html>
